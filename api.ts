/* tslint:disable */
/* eslint-disable */
/**
 * FlowHunt
 * FlowHunt API
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AdditionalImageLink
 */
export interface AdditionalImageLink {
}
/**
 * 
 * @export
 * @interface AgeGroup
 */
export interface AgeGroup {
}
/**
 * Schema for bulk insert response.
 * @export
 * @interface AgentGridBulkInsertResponse
 */
export interface AgentGridBulkInsertResponse {
    /**
     * Number of rows inserted
     * @type {number}
     * @memberof AgentGridBulkInsertResponse
     */
    'inserted_count': number;
}
/**
 * Schema for creating a new agent grid (Flow Table).
 * @export
 * @interface AgentGridCreateRequest
 */
export interface AgentGridCreateRequest {
    /**
     * Name of the Agent Grid (must be snake_case: lowercase letters, numbers, underscores only)
     * @type {string}
     * @memberof AgentGridCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AgentGridCreateRequest
     */
    'description'?: string | null;
    /**
     * List of fields defining the table schema
     * @type {Array<AgentGridFieldRequest>}
     * @memberof AgentGridCreateRequest
     */
    'schema_fields': Array<AgentGridFieldRequest>;
    /**
     * Whether semantic search is enabled (not yet available)
     * @type {boolean}
     * @memberof AgentGridCreateRequest
     */
    'semantic_search_enabled'?: boolean;
}
/**
 * Schema for a single field in an agent grid schema.
 * @export
 * @interface AgentGridFieldRequest
 */
export interface AgentGridFieldRequest {
    /**
     * Field name (must be snake_case: lowercase letters, numbers, underscores only)
     * @type {string}
     * @memberof AgentGridFieldRequest
     */
    'name': string;
    /**
     * Field type
     * @type {AgentGridFieldType}
     * @memberof AgentGridFieldRequest
     */
    'field_type': AgentGridFieldType;
    /**
     * Whether the field is required
     * @type {boolean}
     * @memberof AgentGridFieldRequest
     */
    'required'?: boolean;
}


/**
 * Schema for a single field in an agent grid schema.
 * @export
 * @interface AgentGridFieldResponse
 */
export interface AgentGridFieldResponse {
    /**
     * Field name
     * @type {string}
     * @memberof AgentGridFieldResponse
     */
    'name': string;
    /**
     * Field type
     * @type {AgentGridFieldType}
     * @memberof AgentGridFieldResponse
     */
    'field_type': AgentGridFieldType;
    /**
     * Whether the field is required
     * @type {boolean}
     * @memberof AgentGridFieldResponse
     */
    'required': boolean;
}


/**
 * Field types supported in AgentGrid schemas.
 * @export
 * @enum {string}
 */

export const AgentGridFieldType = {
    Text: 'text',
    Keyword: 'keyword',
    Number: 'number',
    Boolean: 'boolean',
    Date: 'date',
    Datetime: 'datetime'
} as const;

export type AgentGridFieldType = typeof AgentGridFieldType[keyof typeof AgentGridFieldType];


/**
 * Schema for a single import error.
 * @export
 * @interface AgentGridImportError
 */
export interface AgentGridImportError {
    /**
     * Row number where the error occurred (1-indexed)
     * @type {number}
     * @memberof AgentGridImportError
     */
    'row': number;
    /**
     * Field name that caused the error
     * @type {string}
     * @memberof AgentGridImportError
     */
    'field': string;
    /**
     * Error message
     * @type {string}
     * @memberof AgentGridImportError
     */
    'error': string;
}
/**
 * Schema for CSV import start response.
 * @export
 * @interface AgentGridImportStartResponse
 */
export interface AgentGridImportStartResponse {
    /**
     * Unique identifier for tracking the import
     * @type {string}
     * @memberof AgentGridImportStartResponse
     */
    'import_id': string;
    /**
     * Total number of rows to import
     * @type {number}
     * @memberof AgentGridImportStartResponse
     */
    'total_rows': number;
    /**
     * Status message
     * @type {string}
     * @memberof AgentGridImportStartResponse
     */
    'message': string;
}
/**
 * Schema for CSV import status response.
 * @export
 * @interface AgentGridImportStatusResponse
 */
export interface AgentGridImportStatusResponse {
    /**
     * Import identifier
     * @type {string}
     * @memberof AgentGridImportStatusResponse
     */
    'import_id': string;
    /**
     * Import status: processing, completed, or failed
     * @type {string}
     * @memberof AgentGridImportStatusResponse
     */
    'status': string;
    /**
     * Total number of rows being imported
     * @type {number}
     * @memberof AgentGridImportStatusResponse
     */
    'total_rows': number;
    /**
     * Number of batches processed so far
     * @type {number}
     * @memberof AgentGridImportStatusResponse
     */
    'processed_batches': number;
    /**
     * Total number of batches
     * @type {number}
     * @memberof AgentGridImportStatusResponse
     */
    'total_batches': number;
    /**
     * Number of rows successfully imported
     * @type {number}
     * @memberof AgentGridImportStatusResponse
     */
    'successful_rows': number;
    /**
     * Number of rows that failed to import
     * @type {number}
     * @memberof AgentGridImportStatusResponse
     */
    'failed_rows': number;
    /**
     * Import progress as a percentage (0-100)
     * @type {number}
     * @memberof AgentGridImportStatusResponse
     */
    'progress_percentage': number;
    /**
     * List of import errors (max 1000)
     * @type {Array<AgentGridImportError>}
     * @memberof AgentGridImportStatusResponse
     */
    'errors'?: Array<AgentGridImportError>;
    /**
     * 
     * @type {string}
     * @memberof AgentGridImportStatusResponse
     */
    'started_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AgentGridImportStatusResponse
     */
    'completed_at'?: string | null;
}
/**
 * Schema for agent grid preview response (first N rows).
 * @export
 * @interface AgentGridPreviewResponse
 */
export interface AgentGridPreviewResponse {
    /**
     * Preview rows
     * @type {Array<{ [key: string]: any; }>}
     * @memberof AgentGridPreviewResponse
     */
    'rows': Array<{ [key: string]: any; }>;
    /**
     * Total number of rows in the table
     * @type {number}
     * @memberof AgentGridPreviewResponse
     */
    'total_count': number;
}
/**
 * Schema for an agent grid (Flow Table) response.
 * @export
 * @interface AgentGridResponse
 */
export interface AgentGridResponse {
    /**
     * Agent Grid ID
     * @type {string}
     * @memberof AgentGridResponse
     */
    'agent_grid_id': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof AgentGridResponse
     */
    'workspace_id': string;
    /**
     * Name of the Flow Table
     * @type {string}
     * @memberof AgentGridResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AgentGridResponse
     */
    'description'?: string | null;
    /**
     * List of fields defining the table schema
     * @type {Array<AgentGridFieldResponse>}
     * @memberof AgentGridResponse
     */
    'schema_fields': Array<AgentGridFieldResponse>;
    /**
     * Whether semantic search is enabled
     * @type {boolean}
     * @memberof AgentGridResponse
     */
    'semantic_search_enabled': boolean;
    /**
     * Number of rows in the table
     * @type {number}
     * @memberof AgentGridResponse
     */
    'row_count': number;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof AgentGridResponse
     */
    'created_at': string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof AgentGridResponse
     */
    'updated_at': string;
}
/**
 * Schema for inserting a single row into an agent grid.
 * @export
 * @interface AgentGridRowInsertRequest
 */
export interface AgentGridRowInsertRequest {
    /**
     * Row data matching the table schema
     * @type {{ [key: string]: any; }}
     * @memberof AgentGridRowInsertRequest
     */
    'data': { [key: string]: any; };
}
/**
 * Schema for row insert response.
 * @export
 * @interface AgentGridRowInsertResponse
 */
export interface AgentGridRowInsertResponse {
    /**
     * ID of the inserted row
     * @type {string}
     * @memberof AgentGridRowInsertResponse
     */
    'row_id': string;
}
/**
 * Schema for bulk inserting rows into an agent grid.
 * @export
 * @interface AgentGridRowsBulkInsertRequest
 */
export interface AgentGridRowsBulkInsertRequest {
    /**
     * List of rows to insert
     * @type {Array<{ [key: string]: any; }>}
     * @memberof AgentGridRowsBulkInsertRequest
     */
    'rows': Array<{ [key: string]: any; }>;
}
/**
 * Schema for searching rows in an agent grid.
 * @export
 * @interface AgentGridSearchRequest
 */
export interface AgentGridSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentGridSearchRequest
     */
    'query'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AgentGridSearchRequest
     */
    'filters'?: { [key: string]: any; } | null;
    /**
     * Maximum number of rows to return
     * @type {number}
     * @memberof AgentGridSearchRequest
     */
    'limit'?: number;
    /**
     * Number of rows to skip
     * @type {number}
     * @memberof AgentGridSearchRequest
     */
    'offset'?: number;
}
/**
 * Schema for agent grid search response.
 * @export
 * @interface AgentGridSearchResponse
 */
export interface AgentGridSearchResponse {
    /**
     * Search result rows
     * @type {Array<{ [key: string]: any; }>}
     * @memberof AgentGridSearchResponse
     */
    'rows': Array<{ [key: string]: any; }>;
    /**
     * Total number of matching rows
     * @type {number}
     * @memberof AgentGridSearchResponse
     */
    'total_count': number;
}
/**
 * 
 * @export
 * @interface AllFlowsSearchRequest
 */
export interface AllFlowsSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof AllFlowsSearchRequest
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiKeyCreateRequest
 */
export interface ApiKeyCreateRequest {
    /**
     * User defined name of the API key
     * @type {string}
     * @memberof ApiKeyCreateRequest
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyCreateRequest
     */
    'valid_to'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiKeyResponse
 */
export interface ApiKeyResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'workspace_id': string;
    /**
     * API Key ID
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'api_key_id': string;
    /**
     * Name of the API key
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'display_name': string;
    /**
     * Masked API Key
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'mask': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'last_used'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'valid_to'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiKeySearchRequest
 */
export interface ApiKeySearchRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeySearchRequest
     */
    'api_key_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiKeySearchRequest
     */
    'display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiKeySearchRequest
     */
    'mask'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiKeyUpdateRequest
 */
export interface ApiKeyUpdateRequest {
    /**
     * User defined name of the API key
     * @type {string}
     * @memberof ApiKeyUpdateRequest
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyUpdateRequest
     */
    'valid_to'?: string | null;
}
/**
 * 
 * @export
 * @interface AppUrlInput
 */
export interface AppUrlInput {
    /**
     * 
     * @type {Array<any>}
     * @memberof AppUrlInput
     */
    'parsed_url'?: Array<any>;
    /**
     * The URL.
     * @type {string}
     * @memberof AppUrlInput
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface AppUrlOutput
 */
export interface AppUrlOutput {
    /**
     * The URL.
     * @type {string}
     * @memberof AppUrlOutput
     */
    'url': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AspecRatio = {
    _11: '1:1',
    _169: '16:9',
    _219: '21:9',
    _32: '3:2',
    _23: '2:3',
    _45: '4:5',
    _54: '5:4',
    _34: '3:4',
    _43: '4:3',
    _916: '9:16',
    _921: '9:21'
} as const;

export type AspecRatio = typeof AspecRatio[keyof typeof AspecRatio];


/**
 * 
 * @export
 * @interface Availability
 */
export interface Availability {
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BaseFoundationModel = {
    FluxDev: 'flux-dev',
    FluxSchnell: 'flux-schnell',
    StableDiffusion35Medium: 'stable-diffusion-3.5-medium',
    StableDiffusion35LargeTurbo: 'stable-diffusion-3.5-large-turbo',
    StableDiffusion35Large: 'stable-diffusion-3.5-large',
    Imagen3: 'imagen-3',
    Imagen3Fast: 'imagen-3-fast',
    IdeogramV2: 'ideogram-v2',
    IdeogramV2Turbo: 'ideogram-v2-turbo',
    IdeogramV2a: 'ideogram-v2a',
    IdeogramV2aTurbo: 'ideogram-v2a-turbo',
    IdeogramV3Quality: 'ideogram-v3-quality',
    IdeogramV3Turbo: 'ideogram-v3-turbo',
    IdeogramV3Balanced: 'ideogram-v3-balanced',
    GptImage15: 'gpt-image-1.5',
    Sora2: 'sora-2',
    NanoBanana: 'nano-banana',
    NanoBananaPro: 'nano-banana-pro',
    Gemini25Flash: 'gemini-2.5-flash',
    QwenImageEditPlus: 'qwen-image-edit-plus',
    QwenImage: 'qwen-image',
    Wan22AnimateReplace: 'wan-2.2-animate-replace',
    Wan25T2vFast: 'wan-2.5-t2v-fast',
    Wan22AnimateAnimation: 'wan-2.2-animate-animation',
    Wan25I2vFast: 'wan-2.5-i2v-fast',
    Wan25I2v: 'wan-2.5-i2v',
    Veo31: 'veo-3.1',
    Veo31Fast: 'veo-3.1-fast'
} as const;

export type BaseFoundationModel = typeof BaseFoundationModel[keyof typeof BaseFoundationModel];


/**
 * 
 * @export
 * @enum {string}
 */

export const BillingProvider = {
    S: 'S',
    H: 'H'
} as const;

export type BillingProvider = typeof BillingProvider[keyof typeof BillingProvider];


/**
 * 
 * @export
 * @enum {string}
 */

export const BoolChar = {
    Y: 'Y',
    N: 'N'
} as const;

export type BoolChar = typeof BoolChar[keyof typeof BoolChar];


/**
 * 
 * @export
 * @interface Brand
 */
export interface Brand {
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CategoryType = {
    M: 'M',
    D: 'D'
} as const;

export type CategoryType = typeof CategoryType[keyof typeof CategoryType];


/**
 * 
 * @export
 * @interface ChartSessionDurationResponse
 */
export interface ChartSessionDurationResponse {
    /**
     * 
     * @type {Array<PerDaySessionDurationResponse>}
     * @memberof ChartSessionDurationResponse
     */
    'per_day'?: Array<PerDaySessionDurationResponse> | null;
}
/**
 * 
 * @export
 * @interface ChartsFeedbackRequest
 */
export interface ChartsFeedbackRequest {
    /**
     * 
     * @type {string}
     * @memberof ChartsFeedbackRequest
     */
    'start_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChartsFeedbackRequest
     */
    'end_date'?: string | null;
}
/**
 * 
 * @export
 * @interface ChatbotCreateRequest
 */
export interface ChatbotCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'description'?: string | null;
    /**
     * Chatbot Agent ID
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'flow_id'?: string;
    /**
     * 
     * @type {ChatbotStatus}
     * @memberof ChatbotCreateRequest
     */
    'status': ChatbotStatus;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'url_suffix'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'theme'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'max_window_size'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotCreateRequest
     */
    'msg_rpm'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotCreateRequest
     */
    'msg_ip_rpm'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'ratelimit_msg'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chatbot_description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotCreateRequest
     */
    'show_chatbot_header'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chat_bubble_bg_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chat_bubble_icon_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chat_bubble_img_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chatbot_theme'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chatbot_position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'text_direction'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'message_placeholder'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chatbot_header_text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chatbot_header_logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'assistant_avatar_image_url'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotCreateRequest
     */
    'remove_branding'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chatbot_style'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotCreateRequest
     */
    'session_message_history'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotCreateRequest
     */
    'chatbot_bubble_size'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'message_header_logo_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChatbotCreateRequest
     */
    'popup_messages'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotCreateRequest
     */
    'popup_messages_delay'?: number | null;
}


/**
 * 
 * @export
 * @interface ChatbotResponse
 */
export interface ChatbotResponse {
    /**
     * Workspace id
     * @type {string}
     * @memberof ChatbotResponse
     */
    'workspace_id': string;
    /**
     * Chatbot id
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chatbot_id': string;
    /**
     * Tenant name
     * @type {string}
     * @memberof ChatbotResponse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'description'?: string | null;
    /**
     * Agent ID
     * @type {string}
     * @memberof ChatbotResponse
     */
    'flow_id': string;
    /**
     * 
     * @type {ChatbotStatus}
     * @memberof ChatbotResponse
     */
    'status': ChatbotStatus | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'url_suffix'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'theme'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'max_window_size'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotResponse
     */
    'msg_rpm'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotResponse
     */
    'msg_ip_rpm'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'ratelimit_msg'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chatbot_description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotResponse
     */
    'show_chatbot_header'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chat_bubble_bg_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chat_bubble_icon_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chat_bubble_img_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chatbot_theme'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chatbot_position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'text_direction'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'message_placeholder'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chatbot_header_text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chatbot_header_logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'assistant_avatar_image_url'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotResponse
     */
    'remove_branding'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chatbot_style'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotResponse
     */
    'session_message_history'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotResponse
     */
    'chatbot_bubble_size'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'message_header_logo_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChatbotResponse
     */
    'popup_messages'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotResponse
     */
    'popup_messages_delay'?: number | null;
}


/**
 * 
 * @export
 * @interface ChatbotSearchRequest
 */
export interface ChatbotSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotSearchRequest
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotSearchRequest
     */
    'status'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Pagination}
     * @memberof ChatbotSearchRequest
     */
    'pagination'?: Pagination | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ChatbotStatus = {
    A: 'A',
    I: 'I'
} as const;

export type ChatbotStatus = typeof ChatbotStatus[keyof typeof ChatbotStatus];


/**
 * 
 * @export
 * @interface ChatbotUpdateRequest
 */
export interface ChatbotUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'flow_id'?: string | null;
    /**
     * 
     * @type {ChatbotStatus}
     * @memberof ChatbotUpdateRequest
     */
    'status'?: ChatbotStatus | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'url_suffix'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'theme'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'max_window_size'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotUpdateRequest
     */
    'msg_rpm'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotUpdateRequest
     */
    'msg_ip_rpm'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'ratelimit_msg'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chatbot_description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotUpdateRequest
     */
    'show_chatbot_header'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chat_bubble_bg_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chat_bubble_icon_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chat_bubble_img_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chatbot_theme'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chatbot_position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'text_direction'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'message_placeholder'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chatbot_header_text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chatbot_header_logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'assistant_avatar_image_url'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotUpdateRequest
     */
    'remove_branding'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chatbot_style'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotUpdateRequest
     */
    'session_message_history'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotUpdateRequest
     */
    'chatbot_bubble_size'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'message_header_logo_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChatbotUpdateRequest
     */
    'popup_messages'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotUpdateRequest
     */
    'popup_messages_delay'?: number | null;
}


/**
 * 
 * @export
 * @interface Color
 */
export interface Color {
}
/**
 * 
 * @export
 * @interface CommunityImageGenerationsResponse
 */
export interface CommunityImageGenerationsResponse {
    /**
     * 
     * @type {string}
     * @memberof CommunityImageGenerationsResponse
     */
    'generated_image': string;
    /**
     * 
     * @type {string}
     * @memberof CommunityImageGenerationsResponse
     */
    'prompt': string;
}
/**
 * 
 * @export
 * @interface Completed
 */
export interface Completed {
    /**
     * 
     * @type {string}
     * @memberof Completed
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface Condition
 */
export interface Condition {
}
/**
 * 
 * @export
 * @interface CreditBalanceResponse
 */
export interface CreditBalanceResponse {
    /**
     * Current User ID
     * @type {string}
     * @memberof CreditBalanceResponse
     */
    'user_id': string;
    /**
     * Amount of remaining credits
     * @type {number}
     * @memberof CreditBalanceResponse
     */
    'credits': number;
}
/**
 * A single row in the chart data representing one day\'s transactions.
 * @export
 * @interface CreditDailyChartDataRow
 */
export interface CreditDailyChartDataRow {
    /**
     * Date in YYYY-MM-DD format
     * @type {string}
     * @memberof CreditDailyChartDataRow
     */
    'date': string;
    /**
     * Dictionary of transaction type codes to their total amounts
     * @type {{ [key: string]: number; }}
     * @memberof CreditDailyChartDataRow
     */
    'transaction_types': { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface CreditDailyChartRequest
 */
export interface CreditDailyChartRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditDailyChartRequest
     */
    'created_at_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreditDailyChartRequest
     */
    'created_at_to'?: string | null;
    /**
     * 
     * @type {TransactionType}
     * @memberof CreditDailyChartRequest
     */
    'transaction_type'?: TransactionType | null;
}


/**
 * Response containing chart data for daily credit transactions.
 * @export
 * @interface CreditDailyChartResponse
 */
export interface CreditDailyChartResponse {
    /**
     * List of daily transaction data rows
     * @type {Array<CreditDailyChartDataRow>}
     * @memberof CreditDailyChartResponse
     */
    'per_day': Array<CreditDailyChartDataRow>;
    /**
     * List of all transaction type codes present in the data
     * @type {Array<TransactionType>}
     * @memberof CreditDailyChartResponse
     */
    'transaction_types': Array<TransactionType>;
}
/**
 * 
 * @export
 * @interface CreditDailyTransactionResponse
 */
export interface CreditDailyTransactionResponse {
    /**
     * Transactions from date
     * @type {string}
     * @memberof CreditDailyTransactionResponse
     */
    'created_at': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof CreditDailyTransactionResponse
     */
    'workspace_id': string;
    /**
     * Transaction type
     * @type {TransactionType}
     * @memberof CreditDailyTransactionResponse
     */
    'transaction_type': TransactionType;
    /**
     * Amount of credits
     * @type {number}
     * @memberof CreditDailyTransactionResponse
     */
    'amount': number;
    /**
     * Number of transactions
     * @type {number}
     * @memberof CreditDailyTransactionResponse
     */
    'cnt': number;
}


/**
 * 
 * @export
 * @interface CreditDailyTransactionSearchRequest
 */
export interface CreditDailyTransactionSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditDailyTransactionSearchRequest
     */
    'created_at_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreditDailyTransactionSearchRequest
     */
    'created_at_to'?: string | null;
    /**
     * 
     * @type {TransactionType}
     * @memberof CreditDailyTransactionSearchRequest
     */
    'transaction_type'?: TransactionType | null;
    /**
     * 
     * @type {number}
     * @memberof CreditDailyTransactionSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Pagination}
     * @memberof CreditDailyTransactionSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * 
 * @export
 * @interface CreditTransactionResponse
 */
export interface CreditTransactionResponse {
    /**
     * Transaction ID
     * @type {string}
     * @memberof CreditTransactionResponse
     */
    'transaction_id': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof CreditTransactionResponse
     */
    'workspace_id': string;
    /**
     * User ID or user to whom is transaction assigned
     * @type {string}
     * @memberof CreditTransactionResponse
     */
    'user_id': string;
    /**
     * Transaction creation date
     * @type {string}
     * @memberof CreditTransactionResponse
     */
    'created_at': string;
    /**
     * Transaction type
     * @type {TransactionType}
     * @memberof CreditTransactionResponse
     */
    'transaction_type': TransactionType;
    /**
     * Context ID - identification of transaction context - eg chatbot id
     * @type {string}
     * @memberof CreditTransactionResponse
     */
    'context_id': string;
    /**
     * Context description - description of transaction context
     * @type {string}
     * @memberof CreditTransactionResponse
     */
    'context_desc'?: string;
    /**
     * Amount of credits
     * @type {number}
     * @memberof CreditTransactionResponse
     */
    'amount': number;
}


/**
 * 
 * @export
 * @interface CreditTransactionSearchRequest
 */
export interface CreditTransactionSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditTransactionSearchRequest
     */
    'transaction_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreditTransactionSearchRequest
     */
    'created_at_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreditTransactionSearchRequest
     */
    'created_at_to'?: string | null;
    /**
     * 
     * @type {TransactionType}
     * @memberof CreditTransactionSearchRequest
     */
    'transaction_type'?: TransactionType | null;
    /**
     * 
     * @type {string}
     * @memberof CreditTransactionSearchRequest
     */
    'context_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreditTransactionSearchRequest
     */
    'context_desc'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreditTransactionSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Pagination}
     * @memberof CreditTransactionSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * 
 * @export
 * @interface CustomerDataRequestPayload
 */
export interface CustomerDataRequestPayload {
    /**
     * 
     * @type {number}
     * @memberof CustomerDataRequestPayload
     */
    'shop_id': number;
    /**
     * 
     * @type {string}
     * @memberof CustomerDataRequestPayload
     */
    'shop_domain': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CustomerDataRequestPayload
     */
    'orders_requested': Array<number>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CustomerDataRequestPayload
     */
    'customer': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CustomerDataRequestPayload
     */
    'data_request': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CustomerRedactPayload
 */
export interface CustomerRedactPayload {
    /**
     * 
     * @type {number}
     * @memberof CustomerRedactPayload
     */
    'shop_id': number;
    /**
     * 
     * @type {string}
     * @memberof CustomerRedactPayload
     */
    'shop_domain': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CustomerRedactPayload
     */
    'customer': { [key: string]: any; };
    /**
     * 
     * @type {Array<number>}
     * @memberof CustomerRedactPayload
     */
    'orders_to_redact': Array<number>;
}
/**
 * Document linked to vector
 * @export
 * @interface Data
 */
export interface Data {
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'schedule_id': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'domain_id': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'url_id': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'last_text_timestamp': string;
    /**
     * 
     * @type {UrlScreenshotResponse}
     * @memberof Data
     */
    'page_screenshot': UrlScreenshotResponse;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'url_title': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'url_meta_description': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'url_og_image': string;
    /**
     * 
     * @type {boolean}
     * @memberof Data
     */
    'is_original_url': boolean;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'dest_url_id': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'created_at': string;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof Data
     */
    'url_text': Array<{ [key: string]: string; }>;
    /**
     * FAQ ID
     * @type {string}
     * @memberof Data
     */
    'faq_id': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof Data
     */
    'workspace_id': string;
    /**
     * Category ID
     * @type {string}
     * @memberof Data
     */
    'cat_id': string;
    /**
     * Question
     * @type {string}
     * @memberof Data
     */
    'question': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'answer'?: string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'parent_faq_id'?: string;
    /**
     * Document status
     * @type {string}
     * @memberof Data
     */
    'status': string;
    /**
     * Document updated at
     * @type {string}
     * @memberof Data
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'indexed_at'?: string;
    /**
     * Document ID
     * @type {string}
     * @memberof Data
     */
    'doc_id': string;
    /**
     * Document name
     * @type {string}
     * @memberof Data
     */
    'doc_name': string;
    /**
     * Document type
     * @type {string}
     * @memberof Data
     */
    'doc_type': string;
    /**
     * User status
     * @type {string}
     * @memberof Data
     */
    'user_status': string;
}
/**
 * 
 * @export
 * @interface DeleteNodeRequest
 */
export interface DeleteNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteNodeRequest
     */
    'cat_id'?: string | null;
}
/**
 * 
 * @export
 * @interface Description
 */
export interface Description {
}
/**
 * 
 * @export
 * @interface DocumentCategoryCreateRequest
 */
export interface DocumentCategoryCreateRequest {
    /**
     * Category name
     * @type {string}
     * @memberof DocumentCategoryCreateRequest
     */
    'cat_name': string;
    /**
     * Category color
     * @type {string}
     * @memberof DocumentCategoryCreateRequest
     */
    'cat_color': string;
    /**
     * 
     * @type {CategoryType}
     * @memberof DocumentCategoryCreateRequest
     */
    'cat_type'?: CategoryType | null;
}


/**
 * 
 * @export
 * @interface DocumentCategoryResponse
 */
export interface DocumentCategoryResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof DocumentCategoryResponse
     */
    'workspace_id': string;
    /**
     * Category ID
     * @type {string}
     * @memberof DocumentCategoryResponse
     */
    'cat_id': string;
    /**
     * Category name
     * @type {string}
     * @memberof DocumentCategoryResponse
     */
    'cat_name': string;
    /**
     * Category color
     * @type {string}
     * @memberof DocumentCategoryResponse
     */
    'cat_color': string;
}
/**
 * 
 * @export
 * @interface DocumentCategorySearchRequest
 */
export interface DocumentCategorySearchRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentCategorySearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentCategorySearchRequest
     */
    'cat_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentCategorySearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {CategoryType}
     * @memberof DocumentCategorySearchRequest
     */
    'cat_type'?: CategoryType | null;
}


/**
 * 
 * @export
 * @interface DocumentCategoryUpdateRequest
 */
export interface DocumentCategoryUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentCategoryUpdateRequest
     */
    'cat_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentCategoryUpdateRequest
     */
    'cat_color'?: string | null;
}
/**
 * 
 * @export
 * @interface DocumentContent
 */
export interface DocumentContent {
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'img_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentContent
     */
    'status_code'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentContent
     */
    'created_at'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentContent
     */
    'published_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'doc_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'lang'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'content_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'encoding'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'apparent_encoding'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<Array<any>>}
     * @memberof DocumentContent
     */
    'content'?: Array<Array<any>> | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DocumentContent
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentContent
     */
    'alt_content'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'content_hash'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'author'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'channel_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'channel_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'channel_title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentContent
     */
    'duration'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentContent
     */
    'keywords'?: Array<string> | null;
    /**
     * 
     * @type {DocumentType}
     * @memberof DocumentContent
     */
    'doc_type'?: DocumentType | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentContent
     */
    'credits'?: number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DocumentContent
     */
    'url_content'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {MerchantMetadata}
     * @memberof DocumentContent
     */
    'merchant_metadata'?: MerchantMetadata | null;
}


/**
 * 
 * @export
 * @interface DocumentContentResponse
 */
export interface DocumentContentResponse {
    /**
     * Task ID
     * @type {string}
     * @memberof DocumentContentResponse
     */
    'id': string;
    /**
     * Task status
     * @type {TaskStatus}
     * @memberof DocumentContentResponse
     */
    'status': TaskStatus;
    /**
     * 
     * @type {DocumentContent}
     * @memberof DocumentContentResponse
     */
    'result'?: DocumentContent | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContentResponse
     */
    'error_message'?: string | null;
}


/**
 * 
 * @export
 * @interface DocumentResponse
 */
export interface DocumentResponse {
    /**
     * Document ID
     * @type {string}
     * @memberof DocumentResponse
     */
    'doc_id': string;
    /**
     * Category ID
     * @type {string}
     * @memberof DocumentResponse
     */
    'cat_id': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof DocumentResponse
     */
    'workspace_id': string;
    /**
     * Document name
     * @type {string}
     * @memberof DocumentResponse
     */
    'doc_name': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    'url'?: string | null;
    /**
     * Document type
     * @type {string}
     * @memberof DocumentResponse
     */
    'doc_type': string;
    /**
     * User status
     * @type {string}
     * @memberof DocumentResponse
     */
    'user_status': string;
    /**
     * Document status
     * @type {string}
     * @memberof DocumentResponse
     */
    'status': string;
    /**
     * Document updated at
     * @type {string}
     * @memberof DocumentResponse
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface DocumentSearchRequest
 */
export interface DocumentSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentSearchRequest
     */
    'doc_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSearchRequest
     */
    'doc_name'?: string | null;
    /**
     * 
     * @type {DocumentType}
     * @memberof DocumentSearchRequest
     */
    'doc_type'?: DocumentType | null;
    /**
     * 
     * @type {DocumentStatus}
     * @memberof DocumentSearchRequest
     */
    'status'?: DocumentStatus | null;
    /**
     * 
     * @type {UserDocumentStatus}
     * @memberof DocumentSearchRequest
     */
    'user_status'?: UserDocumentStatus | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSearchRequest
     */
    'updated_at_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSearchRequest
     */
    'updated_at_to'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Pagination}
     * @memberof DocumentSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * 
 * @export
 * @interface DocumentSimilarityRequest
 */
export interface DocumentSimilarityRequest {
    /**
     * 
     * @type {VectorDocumentType}
     * @memberof DocumentSimilarityRequest
     */
    'document_type'?: VectorDocumentType | null;
    /**
     * 
     * @type {PointerType}
     * @memberof DocumentSimilarityRequest
     */
    'pointer_type'?: PointerType | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityRequest
     */
    'schema_type'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityRequest
     */
    'score_trheshold'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentSimilarityRequest
     */
    'with_vectors'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityRequest
     */
    'pointer_position_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityRequest
     */
    'pointer_position_to'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityRequest
     */
    'vector_id_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityRequest
     */
    'vector_id_to'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityRequest
     */
    'filter_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentSimilarityRequest
     */
    'filter_domains'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityRequest
     */
    'document_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityRequest
     */
    'faq_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityRequest
     */
    'url_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityRequest
     */
    'url'?: string | null;
}


/**
 * 
 * @export
 * @interface DocumentSimilarityTaskRequest
 */
export interface DocumentSimilarityTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityTaskRequest
     */
    'post_back_url'?: string | null;
    /**
     * 
     * @type {VectorDocumentType}
     * @memberof DocumentSimilarityTaskRequest
     */
    'document_type'?: VectorDocumentType | null;
    /**
     * 
     * @type {PointerType}
     * @memberof DocumentSimilarityTaskRequest
     */
    'pointer_type'?: PointerType | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityTaskRequest
     */
    'schema_type'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityTaskRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityTaskRequest
     */
    'score_trheshold'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentSimilarityTaskRequest
     */
    'with_vectors'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityTaskRequest
     */
    'pointer_position_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityTaskRequest
     */
    'pointer_position_to'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityTaskRequest
     */
    'vector_id_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityTaskRequest
     */
    'vector_id_to'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityTaskRequest
     */
    'filter_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentSimilarityTaskRequest
     */
    'filter_domains'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityTaskRequest
     */
    'document_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityTaskRequest
     */
    'faq_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityTaskRequest
     */
    'url_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityTaskRequest
     */
    'url'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DocumentStatus = {
    N: 'N',
    U: 'U',
    T: 'T',
    I: 'I',
    F: 'F'
} as const;

export type DocumentStatus = typeof DocumentStatus[keyof typeof DocumentStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const DocumentType = {
    Pdf: 'PDF',
    Docx: 'DOCX',
    Xlsx: 'XLSX',
    Pptx: 'PPTX',
    Md: 'MD',
    Txt: 'TXT',
    Html: 'HTML',
    Yt: 'YT',
    Un: 'UN',
    Mp3: 'MP3',
    Flac: 'FLAC',
    Mp4: 'MP4',
    Mpeg: 'MPEG',
    Mpga: 'MPGA',
    M4A: 'M4A',
    Ogg: 'OGG',
    Wav: 'WAV',
    Webm: 'WEBM',
    Jpeg: 'JPEG',
    Jpg: 'JPG',
    Png: 'PNG',
    Gif: 'GIF',
    Webp: 'WEBP',
    Csv: 'CSV',
    Xml: 'XML',
    Json: 'JSON',
    GoogleDocs: 'GOOGLE_DOCS',
    GoogleSheets: 'GOOGLE_SHEETS',
    RssXml: 'RSS_XML',
    GoogleProductsFeed: 'GOOGLE_PRODUCTS_FEED'
} as const;

export type DocumentType = typeof DocumentType[keyof typeof DocumentType];


/**
 * 
 * @export
 * @interface DocumentUpdateRequest
 */
export interface DocumentUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentUpdateRequest
     */
    'doc_name'?: string | null;
    /**
     * 
     * @type {UserDocumentStatus}
     * @memberof DocumentUpdateRequest
     */
    'user_status'?: UserDocumentStatus | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentUpdateRequest
     */
    'cat_id'?: string | null;
}


/**
 * 
 * @export
 * @interface DriverSuccessResponse
 */
export interface DriverSuccessResponse {
    /**
     * 
     * @type {string}
     * @memberof DriverSuccessResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DriverType = {
    LangfuseDriver: 'langfuse_driver',
    FlowhuntDriver: 'flowhunt_driver',
    PowerBiDriver: 'power_bi_driver'
} as const;

export type DriverType = typeof DriverType[keyof typeof DriverType];


/**
 * 
 * @export
 * @enum {string}
 */

export const FTStatus = {
    P: 'P',
    S: 'S',
    F: 'F',
    N: 'N'
} as const;

export type FTStatus = typeof FTStatus[keyof typeof FTStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const FTType = {
    I: 'I',
    V: 'V'
} as const;

export type FTType = typeof FTType[keyof typeof FTType];


/**
 * 
 * @export
 * @interface FailedFaqItem
 */
export interface FailedFaqItem {
    /**
     * Question that failed to import
     * @type {string}
     * @memberof FailedFaqItem
     */
    'question': string;
    /**
     * Answer (truncated to 200 chars)
     * @type {string}
     * @memberof FailedFaqItem
     */
    'answer': string;
    /**
     * Reason for failure
     * @type {string}
     * @memberof FailedFaqItem
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface FaqCreateRequest
 */
export interface FaqCreateRequest {
    /**
     * Category ID
     * @type {string}
     * @memberof FaqCreateRequest
     */
    'cat_id': string;
    /**
     * Question
     * @type {string}
     * @memberof FaqCreateRequest
     */
    'primary_question': string;
    /**
     * 
     * @type {string}
     * @memberof FaqCreateRequest
     */
    'answer'?: string | null;
    /**
     * Parent FAQ ID if current question points to other answer
     * @type {Array<string>}
     * @memberof FaqCreateRequest
     */
    'secondary_questions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FaqImportResponse
 */
export interface FaqImportResponse {
    /**
     * List of successfully imported FAQs
     * @type {Array<FaqResponse>}
     * @memberof FaqImportResponse
     */
    'successful': Array<FaqResponse>;
    /**
     * List of FAQs that failed to import
     * @type {Array<FailedFaqItem>}
     * @memberof FaqImportResponse
     */
    'failed': Array<FailedFaqItem>;
    /**
     * Total number of FAQs attempted
     * @type {number}
     * @memberof FaqImportResponse
     */
    'total_attempted': number;
    /**
     * Number of successfully imported FAQs
     * @type {number}
     * @memberof FaqImportResponse
     */
    'total_successful': number;
    /**
     * Number of failed FAQs
     * @type {number}
     * @memberof FaqImportResponse
     */
    'total_failed': number;
}
/**
 * 
 * @export
 * @interface FaqResponse
 */
export interface FaqResponse {
    /**
     * FAQ ID
     * @type {string}
     * @memberof FaqResponse
     */
    'faq_id': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof FaqResponse
     */
    'workspace_id': string;
    /**
     * Category ID
     * @type {string}
     * @memberof FaqResponse
     */
    'cat_id': string;
    /**
     * Question
     * @type {string}
     * @memberof FaqResponse
     */
    'question': string;
    /**
     * 
     * @type {string}
     * @memberof FaqResponse
     */
    'answer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FaqResponse
     */
    'parent_faq_id'?: string | null;
    /**
     * FAQ status
     * @type {FaqStatus}
     * @memberof FaqResponse
     */
    'status': FaqStatus;
    /**
     * FAQ updated at
     * @type {string}
     * @memberof FaqResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof FaqResponse
     */
    'indexed_at'?: string | null;
}


/**
 * 
 * @export
 * @interface FaqSearchRequest
 */
export interface FaqSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof FaqSearchRequest
     */
    'faq_id'?: string | null;
    /**
     * 
     * @type {FaqStatus}
     * @memberof FaqSearchRequest
     */
    'status'?: FaqStatus | null;
    /**
     * 
     * @type {string}
     * @memberof FaqSearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FaqSearchRequest
     */
    'question'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FaqSearchRequest
     */
    'answer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FaqSearchRequest
     */
    'parent_faq_id'?: string | null;
    /**
     * 
     * @type {FaqType}
     * @memberof FaqSearchRequest
     */
    'faq_type'?: FaqType | null;
    /**
     * 
     * @type {number}
     * @memberof FaqSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Pagination}
     * @memberof FaqSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FaqStatus = {
    N: 'N',
    U: 'U',
    I: 'I'
} as const;

export type FaqStatus = typeof FaqStatus[keyof typeof FaqStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const FaqType = {
    P: 'P',
    S: 'S'
} as const;

export type FaqType = typeof FaqType[keyof typeof FaqType];


/**
 * 
 * @export
 * @interface FaqUpdateRequest
 */
export interface FaqUpdateRequest {
    /**
     * Category ID
     * @type {string}
     * @memberof FaqUpdateRequest
     */
    'cat_id'?: string;
    /**
     * Question
     * @type {string}
     * @memberof FaqUpdateRequest
     */
    'primary_question'?: string;
    /**
     * Answer formatted as markdow
     * @type {string}
     * @memberof FaqUpdateRequest
     */
    'answer'?: string;
    /**
     * Parent FAQ ID if current question points to other answer
     * @type {Array<string>}
     * @memberof FaqUpdateRequest
     */
    'secondary_questions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FeedbackChartResponse
 */
export interface FeedbackChartResponse {
    /**
     * 
     * @type {Array<PerDayFeedback>}
     * @memberof FeedbackChartResponse
     */
    'per_day'?: Array<PerDayFeedback> | null;
    /**
     * 
     * @type {TotalFeedback}
     * @memberof FeedbackChartResponse
     */
    'totals'?: TotalFeedback | null;
}
/**
 * 
 * @export
 * @interface FileUploadResponse
 */
export interface FileUploadResponse {
    /**
     * Image URL
     * @type {Array<string>}
     * @memberof FileUploadResponse
     */
    'file_urls': Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FlowAssistantAIModel = {
    ClaudeSonnet45: 'Claude Sonnet 4.5',
    Gpt41: 'GPT4.1',
    O4Mini: 'O4 Mini',
    O3Mini: 'O3 Mini'
} as const;

export type FlowAssistantAIModel = typeof FlowAssistantAIModel[keyof typeof FlowAssistantAIModel];


/**
 * 
 * @export
 * @interface FlowAssistantAddComponentMetadata
 */
export interface FlowAssistantAddComponentMetadata {
    /**
     * Action ID
     * @type {string}
     * @memberof FlowAssistantAddComponentMetadata
     */
    'action_id': string;
    /**
     * Component ID
     * @type {string}
     * @memberof FlowAssistantAddComponentMetadata
     */
    'component_id': string;
    /**
     * Component name
     * @type {string}
     * @memberof FlowAssistantAddComponentMetadata
     */
    'component_type': string;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantAddComponentMetadata
     */
    'component_display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantAddComponentMetadata
     */
    'component_icon'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowAssistantAddComponentMetadata
     */
    'parameter_values'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface FlowAssistantAddConnectionMetadata
 */
export interface FlowAssistantAddConnectionMetadata {
    /**
     * Action ID
     * @type {string}
     * @memberof FlowAssistantAddConnectionMetadata
     */
    'action_id': string;
    /**
     * Source component ID
     * @type {string}
     * @memberof FlowAssistantAddConnectionMetadata
     */
    'source_component_id': string;
    /**
     * Target component ID
     * @type {string}
     * @memberof FlowAssistantAddConnectionMetadata
     */
    'target_component_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantAddConnectionMetadata
     */
    'source_field_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantAddConnectionMetadata
     */
    'target_field_name'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowAssistantApplyRejectChangesRequest
 */
export interface FlowAssistantApplyRejectChangesRequest {
    /**
     * The Agent ID currently being enhanced by the AI Agent.
     * @type {string}
     * @memberof FlowAssistantApplyRejectChangesRequest
     */
    'flow_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantApplyRejectChangesRequest
     */
    'action_id'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowAssistantCreateBlankFlowMetadata
 */
export interface FlowAssistantCreateBlankFlowMetadata {
    /**
     * Agent name
     * @type {string}
     * @memberof FlowAssistantCreateBlankFlowMetadata
     */
    'flow_name': string;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantCreateBlankFlowMetadata
     */
    'flow_description'?: string | null;
    /**
     * Agent ID
     * @type {string}
     * @memberof FlowAssistantCreateBlankFlowMetadata
     */
    'flow_id': string;
}
/**
 * 
 * @export
 * @interface FlowAssistantDeleteComponentMetadata
 */
export interface FlowAssistantDeleteComponentMetadata {
    /**
     * Action ID
     * @type {string}
     * @memberof FlowAssistantDeleteComponentMetadata
     */
    'action_id': string;
    /**
     * Component ID
     * @type {string}
     * @memberof FlowAssistantDeleteComponentMetadata
     */
    'component_id': string;
    /**
     * Component name
     * @type {string}
     * @memberof FlowAssistantDeleteComponentMetadata
     */
    'component_type': string;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantDeleteComponentMetadata
     */
    'component_display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantDeleteComponentMetadata
     */
    'component_icon'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowAssistantDeleteConnectionMetadata
 */
export interface FlowAssistantDeleteConnectionMetadata {
    /**
     * Action ID
     * @type {string}
     * @memberof FlowAssistantDeleteConnectionMetadata
     */
    'action_id': string;
    /**
     * Source component ID
     * @type {string}
     * @memberof FlowAssistantDeleteConnectionMetadata
     */
    'source_component_id': string;
    /**
     * Target component ID
     * @type {string}
     * @memberof FlowAssistantDeleteConnectionMetadata
     */
    'target_component_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantDeleteConnectionMetadata
     */
    'source_field_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantDeleteConnectionMetadata
     */
    'target_field_name'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowAssistantInvokeRequest
 */
export interface FlowAssistantInvokeRequest {
    /**
     * The message of the user
     * @type {string}
     * @memberof FlowAssistantInvokeRequest
     */
    'message': string;
    /**
     * 
     * @type {FlowAssistantAIModel}
     * @memberof FlowAssistantInvokeRequest
     */
    'ai_model'?: FlowAssistantAIModel | null;
}


/**
 * 
 * @export
 * @interface FlowAssistantSessionCreateRequest
 */
export interface FlowAssistantSessionCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantSessionCreateRequest
     */
    'context_flow_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof FlowAssistantSessionCreateRequest
     */
    'start_with_welcome_message'?: boolean | null;
}
/**
 * 
 * @export
 * @interface FlowAssistantUpdateComponentMetadata
 */
export interface FlowAssistantUpdateComponentMetadata {
    /**
     * Action ID
     * @type {string}
     * @memberof FlowAssistantUpdateComponentMetadata
     */
    'action_id': string;
    /**
     * Component ID
     * @type {string}
     * @memberof FlowAssistantUpdateComponentMetadata
     */
    'component_id': string;
    /**
     * Component name
     * @type {string}
     * @memberof FlowAssistantUpdateComponentMetadata
     */
    'component_type': string;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantUpdateComponentMetadata
     */
    'component_display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantUpdateComponentMetadata
     */
    'component_icon'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowAssistantUpdateComponentMetadata
     */
    'parameter_values'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FlowBranch = {
    P: 'P',
    D: 'D'
} as const;

export type FlowBranch = typeof FlowBranch[keyof typeof FlowBranch];


/**
 * 
 * @export
 * @interface FlowCategoryCreateRequest
 */
export interface FlowCategoryCreateRequest {
    /**
     * The agent category name
     * @type {string}
     * @memberof FlowCategoryCreateRequest
     */
    'cat_name': string;
    /**
     * The agent category color
     * @type {string}
     * @memberof FlowCategoryCreateRequest
     */
    'cat_color': string;
}
/**
 * Agent category response.
 * @export
 * @interface FlowCategoryResponse
 */
export interface FlowCategoryResponse {
    /**
     * 
     * @type {string}
     * @memberof FlowCategoryResponse
     */
    'cat_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowCategoryResponse
     */
    'cat_name': string;
    /**
     * 
     * @type {string}
     * @memberof FlowCategoryResponse
     */
    'cat_color': string;
}
/**
 * 
 * @export
 * @interface FlowCategorySearchRequest
 */
export interface FlowCategorySearchRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowCategorySearchRequest
     */
    'cat_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FlowCategorySearchRequest
     */
    'limit'?: number | null;
}
/**
 * 
 * @export
 * @interface FlowCommitRequest
 */
export interface FlowCommitRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowCommitRequest
     */
    'commit_title'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowCommitResponse
 */
export interface FlowCommitResponse {
    /**
     * 
     * @type {string}
     * @memberof FlowCommitResponse
     */
    'commit_title'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowConfig
 */
export interface FlowConfig {
    /**
     * The agent nodes
     * @type {Array<any>}
     * @memberof FlowConfig
     */
    'nodes': Array<any>;
    /**
     * The agent edges
     * @type {Array<any>}
     * @memberof FlowConfig
     */
    'edges': Array<any>;
}
/**
 * 
 * @export
 * @interface FlowCreate
 */
export interface FlowCreate {
    /**
     * The agent name
     * @type {string}
     * @memberof FlowCreate
     */
    'name': string;
    /**
     * The agent description
     * @type {string}
     * @memberof FlowCreate
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof FlowCreate
     */
    'detailed_description'?: string | null;
    /**
     * The agent configuration
     * @type {FlowConfig}
     * @memberof FlowCreate
     */
    'config': FlowConfig;
    /**
     * 
     * @type {string}
     * @memberof FlowCreate
     */
    'category_id'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowCronCreateRequest
 */
export interface FlowCronCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowCronCreateRequest
     */
    'flow_id': string;
    /**
     * 
     * @type {FlowCronStatus}
     * @memberof FlowCronCreateRequest
     */
    'status': FlowCronStatus;
    /**
     * 
     * @type {string}
     * @memberof FlowCronCreateRequest
     */
    'input_text'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowCronCreateRequest
     */
    'variables'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronCreateRequest
     */
    'interval_settings': string;
    /**
     * 
     * @type {string}
     * @memberof FlowCronCreateRequest
     */
    'cron_name': string;
}


/**
 * Agent cron response.
 * @export
 * @interface FlowCronResponse
 */
export interface FlowCronResponse {
    /**
     * 
     * @type {string}
     * @memberof FlowCronResponse
     */
    'flow_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowCronResponse
     */
    'cron_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowCronResponse
     */
    'last_run'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronResponse
     */
    'next_run'?: string | null;
    /**
     * 
     * @type {FlowCronStatus}
     * @memberof FlowCronResponse
     */
    'status': FlowCronStatus;
    /**
     * 
     * @type {string}
     * @memberof FlowCronResponse
     */
    'input_text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronResponse
     */
    'interval_settings': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowCronResponse
     */
    'variables'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronResponse
     */
    'cron_name': string;
}


/**
 * 
 * @export
 * @interface FlowCronSearchRequest
 */
export interface FlowCronSearchRequest {
    /**
     * 
     * @type {FlowCronStatus}
     * @memberof FlowCronSearchRequest
     */
    'status'?: FlowCronStatus | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronSearchRequest
     */
    'next_run_to'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronSearchRequest
     */
    'next_run_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronSearchRequest
     */
    'last_run_to'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronSearchRequest
     */
    'last_run_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronSearchRequest
     */
    'flow_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronSearchRequest
     */
    'cron_name'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FlowCronStatus = {
    E: 'E',
    P: 'P'
} as const;

export type FlowCronStatus = typeof FlowCronStatus[keyof typeof FlowCronStatus];


/**
 * 
 * @export
 * @interface FlowCronUpdateRequest
 */
export interface FlowCronUpdateRequest {
    /**
     * 
     * @type {FlowCronStatus}
     * @memberof FlowCronUpdateRequest
     */
    'status'?: FlowCronStatus | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronUpdateRequest
     */
    'input_text'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowCronUpdateRequest
     */
    'variables'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronUpdateRequest
     */
    'interval_settings'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronUpdateRequest
     */
    'cron_name'?: string | null;
}


/**
 * 
 * @export
 * @interface FlowDetailResponse
 */
export interface FlowDetailResponse {
    /**
     * Agent ID
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'id': string;
    /**
     * Agent name
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'name': string;
    /**
     * Agent description
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'detailed_description'?: string | null;
    /**
     * Agent configuration
     * @type {FlowConfig}
     * @memberof FlowDetailResponse
     */
    'config': FlowConfig;
    /**
     * Agent type
     * @type {FlowType}
     * @memberof FlowDetailResponse
     */
    'flow_type': FlowType;
    /**
     * 
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'executed_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'category_id'?: string | null;
    /**
     * Agent branch
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'branch': string;
    /**
     * Enable cache
     * @type {boolean}
     * @memberof FlowDetailResponse
     */
    'enable_cache': boolean;
    /**
     * 
     * @type {number}
     * @memberof FlowDetailResponse
     */
    'draft_version_nr'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FlowDetailResponse
     */
    'prod_version_nr'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'last_modified'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FlowEventActionType = {
    Loading: 'loading',
    Message: 'message',
    ToolCall: 'tool_call',
    TaskResponse: 'task_response',
    Failed: 'failed',
    MessageFeedback: 'message_feedback',
    Artefacts: 'artefacts',
    AgentCot: 'agent_cot',
    TodoList: 'todo_list',
    AddComponent: 'add_component',
    DeleteComponent: 'delete_component',
    ConnectComponents: 'connect_components',
    UpdateComponent: 'update_component',
    AddConnection: 'add_connection',
    DeleteConnection: 'delete_connection',
    CreateBlankFlow: 'create_blank_flow'
} as const;

export type FlowEventActionType = typeof FlowEventActionType[keyof typeof FlowEventActionType];


/**
 * 
 * @export
 * @interface FlowEventsSearchRequest
 */
export interface FlowEventsSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowEventsSearchRequest
     */
    'query'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowEventsSearchRequest
     */
    'start_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowEventsSearchRequest
     */
    'end_date'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowEventsSearchResponse
 */
export interface FlowEventsSearchResponse {
    /**
     * Session ID
     * @type {string}
     * @memberof FlowEventsSearchResponse
     */
    'session_id': string;
    /**
     * Event ID
     * @type {string}
     * @memberof FlowEventsSearchResponse
     */
    'event_id': string;
    /**
     * Event type
     * @type {MessageType}
     * @memberof FlowEventsSearchResponse
     */
    'event_type': MessageType;
    /**
     * Action type
     * @type {FlowEventActionType}
     * @memberof FlowEventsSearchResponse
     */
    'action_type': FlowEventActionType;
    /**
     * 
     * @type {string}
     * @memberof FlowEventsSearchResponse
     */
    'date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowEventsSearchResponse
     */
    'message_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowEventsSearchResponse
     */
    'message'?: string | null;
}


/**
 * Enum for FlowHunt product slugs.
 * @export
 * @enum {string}
 */

export const FlowHuntProductSlug = {
    S: 'S',
    P: 'P',
    A: 'A'
} as const;

export type FlowHuntProductSlug = typeof FlowHuntProductSlug[keyof typeof FlowHuntProductSlug];


/**
 * 
 * @export
 * @interface FlowInvokeRequest
 */
export interface FlowInvokeRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowInvokeRequest
     */
    'post_back_url'?: string | null;
    /**
     * The human input
     * @type {string}
     * @memberof FlowInvokeRequest
     */
    'human_input': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowInvokeRequest
     */
    'variables'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface FlowMessageFeedbackRequest
 */
export interface FlowMessageFeedbackRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowMessageFeedbackRequest
     */
    'message_id'?: string | null;
    /**
     * 
     * @type {MessageFeedback}
     * @memberof FlowMessageFeedbackRequest
     */
    'feedback'?: MessageFeedback | null;
}


/**
 * 
 * @export
 * @interface FlowMessageFeedbackResponse
 */
export interface FlowMessageFeedbackResponse {
    /**
     * Response message
     * @type {string}
     * @memberof FlowMessageFeedbackResponse
     */
    'response_message': string;
}
/**
 * 
 * @export
 * @interface FlowResponse
 */
export interface FlowResponse {
    /**
     * Agent ID
     * @type {string}
     * @memberof FlowResponse
     */
    'id': string;
    /**
     * Agent name
     * @type {string}
     * @memberof FlowResponse
     */
    'name': string;
    /**
     * Agent description
     * @type {string}
     * @memberof FlowResponse
     */
    'description': string;
    /**
     * Agent type
     * @type {FlowType}
     * @memberof FlowResponse
     */
    'flow_type': FlowType;
    /**
     * Component count
     * @type {number}
     * @memberof FlowResponse
     */
    'component_count': number;
    /**
     * 
     * @type {string}
     * @memberof FlowResponse
     */
    'executed_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowResponse
     */
    'category_id'?: string | null;
    /**
     * Enable cache
     * @type {boolean}
     * @memberof FlowResponse
     */
    'enable_cache': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlowResponse
     */
    'last_modified'?: string | null;
}


/**
 * 
 * @export
 * @interface FlowSearchRequest
 */
export interface FlowSearchRequest {
    /**
     * 
     * @type {FlowType}
     * @memberof FlowSearchRequest
     */
    'flow_type'?: FlowType | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSearchRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSearchRequest
     */
    'category_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Pagination}
     * @memberof FlowSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * Metadata for agent chain of thought / reasoning events.
 * @export
 * @interface FlowSessionAgentCotMetadata
 */
export interface FlowSessionAgentCotMetadata {
    /**
     * Unique CoT identifier for updates
     * @type {string}
     * @memberof FlowSessionAgentCotMetadata
     */
    'cot_id': string;
    /**
     * Chain of thought / reasoning text
     * @type {string}
     * @memberof FlowSessionAgentCotMetadata
     */
    'content': string;
}
/**
 * Response containing artefact file content.
 * @export
 * @interface FlowSessionArtefactContentResponse
 */
export interface FlowSessionArtefactContentResponse {
    /**
     * Unique artefact identifier
     * @type {string}
     * @memberof FlowSessionArtefactContentResponse
     */
    'id': string;
    /**
     * File name
     * @type {string}
     * @memberof FlowSessionArtefactContentResponse
     */
    'name': string;
    /**
     * Relative path within workspace
     * @type {string}
     * @memberof FlowSessionArtefactContentResponse
     */
    'path': string;
    /**
     * File size in bytes
     * @type {number}
     * @memberof FlowSessionArtefactContentResponse
     */
    'size': number;
    /**
     * Last modification timestamp (ISO format)
     * @type {string}
     * @memberof FlowSessionArtefactContentResponse
     */
    'modified_at': string;
    /**
     * File content
     * @type {string}
     * @memberof FlowSessionArtefactContentResponse
     */
    'content': string;
}
/**
 * Information about a single artefact file.
 * @export
 * @interface FlowSessionArtefactInfo
 */
export interface FlowSessionArtefactInfo {
    /**
     * Unique artefact identifier
     * @type {string}
     * @memberof FlowSessionArtefactInfo
     */
    'id': string;
    /**
     * File name
     * @type {string}
     * @memberof FlowSessionArtefactInfo
     */
    'name': string;
    /**
     * Relative path within workspace
     * @type {string}
     * @memberof FlowSessionArtefactInfo
     */
    'path': string;
    /**
     * File size in bytes
     * @type {number}
     * @memberof FlowSessionArtefactInfo
     */
    'size': number;
    /**
     * Last modification timestamp (ISO format)
     * @type {string}
     * @memberof FlowSessionArtefactInfo
     */
    'modified_at': string;
}
/**
 * Metadata for artefacts created by Deep Agent.
 * @export
 * @interface FlowSessionArtefactsMetadata
 */
export interface FlowSessionArtefactsMetadata {
    /**
     * List of artefact files created by agent
     * @type {Array<FlowSessionArtefactInfo>}
     * @memberof FlowSessionArtefactsMetadata
     */
    'artefacts': Array<FlowSessionArtefactInfo>;
}
/**
 * 
 * @export
 * @interface FlowSessionAttachmentResponse
 */
export interface FlowSessionAttachmentResponse {
    /**
     * File name
     * @type {string}
     * @memberof FlowSessionAttachmentResponse
     */
    'file_name': string;
    /**
     * File type
     * @type {string}
     * @memberof FlowSessionAttachmentResponse
     */
    'file_type': string;
    /**
     * File ID
     * @type {string}
     * @memberof FlowSessionAttachmentResponse
     */
    'file_id': string;
    /**
     * Document type
     * @type {DocumentType}
     * @memberof FlowSessionAttachmentResponse
     */
    'type': DocumentType;
}


/**
 * 
 * @export
 * @interface FlowSessionCreateFromFlowRequest
 */
export interface FlowSessionCreateFromFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'lang'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'access_token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'refresh_token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'password'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'variables'?: { [key: string]: string; } | null;
    /**
     * The agent ID
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'flow_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'on_chat_opened_postback_url'?: string | null;
    /**
     * The agent branch
     * @type {FlowBranch}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'flow_branch'?: FlowBranch;
}


/**
 * 
 * @export
 * @interface FlowSessionCreateRequest
 */
export interface FlowSessionCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'lang'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'access_token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'refresh_token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'password'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof FlowSessionCreateRequest
     */
    'variables'?: { [key: string]: string; } | null;
    /**
     * The chatbot ID
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'chatbot_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'on_chat_opened_postback_url'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowSessionEvent
 */
export interface FlowSessionEvent {
    /**
     * Workspace ID
     * @type {string}
     * @memberof FlowSessionEvent
     */
    'workspace_id': string;
    /**
     * Session ID
     * @type {string}
     * @memberof FlowSessionEvent
     */
    'session_id': string;
    /**
     * Event ID
     * @type {string}
     * @memberof FlowSessionEvent
     */
    'event_id': string;
    /**
     * Event type
     * @type {MessageType}
     * @memberof FlowSessionEvent
     */
    'event_type': MessageType;
    /**
     * Created at
     * @type {string}
     * @memberof FlowSessionEvent
     */
    'created_at_timestamp': string;
    /**
     * Action type
     * @type {FlowEventActionType}
     * @memberof FlowSessionEvent
     */
    'action_type': FlowEventActionType;
    /**
     * Credits
     * @type {number}
     * @memberof FlowSessionEvent
     */
    'credits': number;
    /**
     * 
     * @type {Metadata}
     * @memberof FlowSessionEvent
     */
    'metadata'?: Metadata | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionEvent
     */
    'component_name'?: string | null;
}


/**
 * 
 * @export
 * @interface FlowSessionInvocationResponse
 */
export interface FlowSessionInvocationResponse {
    /**
     * Message ID
     * @type {string}
     * @memberof FlowSessionInvocationResponse
     */
    'message_id': string;
    /**
     * Created at
     * @type {string}
     * @memberof FlowSessionInvocationResponse
     */
    'created_at': string;
    /**
     * 
     * @type {Array<FlowSessionEvent>}
     * @memberof FlowSessionInvocationResponse
     */
    'cached_events'?: Array<FlowSessionEvent> | null;
}
/**
 * 
 * @export
 * @interface FlowSessionInvokeRequest
 */
export interface FlowSessionInvokeRequest {
    /**
     * The message
     * @type {string}
     * @memberof FlowSessionInvokeRequest
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionInvokeRequest
     */
    'post_back_url'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowSessionLoadingMetadata
 */
export interface FlowSessionLoadingMetadata {
    /**
     * Message ID
     * @type {string}
     * @memberof FlowSessionLoadingMetadata
     */
    'message_id': string;
    /**
     * Tool name
     * @type {string}
     * @memberof FlowSessionLoadingMetadata
     */
    'tool_name': string;
    /**
     * Loading description
     * @type {string}
     * @memberof FlowSessionLoadingMetadata
     */
    'loading_desc': string;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionLoadingMetadata
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionLoadingMetadata
     */
    'color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionLoadingMetadata
     */
    'detailed_description'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowSessionMessageFeedbackMetadata
 */
export interface FlowSessionMessageFeedbackMetadata {
    /**
     * Message ID
     * @type {string}
     * @memberof FlowSessionMessageFeedbackMetadata
     */
    'feedback_message_id': string;
    /**
     * 
     * @type {MessageFeedback}
     * @memberof FlowSessionMessageFeedbackMetadata
     */
    'feedback'?: MessageFeedback | null;
}


/**
 * 
 * @export
 * @interface FlowSessionMessageMetadata
 */
export interface FlowSessionMessageMetadata {
    /**
     * Message ID
     * @type {string}
     * @memberof FlowSessionMessageMetadata
     */
    'message_id': string;
    /**
     * Message
     * @type {string}
     * @memberof FlowSessionMessageMetadata
     */
    'message': string;
    /**
     * 
     * @type {HumanAgentSender}
     * @memberof FlowSessionMessageMetadata
     */
    'sender'?: HumanAgentSender | null;
}
/**
 * 
 * @export
 * @interface FlowSessionResponse
 */
export interface FlowSessionResponse {
    /**
     * Session ID
     * @type {string}
     * @memberof FlowSessionResponse
     */
    'session_id': string;
    /**
     * Session created at
     * @type {string}
     * @memberof FlowSessionResponse
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface FlowSessionTaskResponseMetadata
 */
export interface FlowSessionTaskResponseMetadata {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionTaskResponseMetadata
     */
    'task_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionTaskResponseMetadata
     */
    'task_input': string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionTaskResponseMetadata
     */
    'agent': string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionTaskResponseMetadata
     */
    'task_response': string | null;
}
/**
 * Metadata for agent todo list updates.
 * @export
 * @interface FlowSessionTodoListMetadata
 */
export interface FlowSessionTodoListMetadata {
    /**
     * Unique todo list identifier for updates
     * @type {string}
     * @memberof FlowSessionTodoListMetadata
     */
    'todo_id': string;
    /**
     * List of todo items
     * @type {Array<TodoItem>}
     * @memberof FlowSessionTodoListMetadata
     */
    'todos': Array<TodoItem>;
}
/**
 * 
 * @export
 * @interface FlowSessionToolCallMetadata
 */
export interface FlowSessionToolCallMetadata {
    /**
     * Tool name
     * @type {string}
     * @memberof FlowSessionToolCallMetadata
     */
    'tool_name': string;
    /**
     * Search query
     * @type {string}
     * @memberof FlowSessionToolCallMetadata
     */
    'agent_query': string;
    /**
     * Tool response
     * @type {string}
     * @memberof FlowSessionToolCallMetadata
     */
    'tool_response': string;
}
/**
 * 
 * @export
 * @interface FlowSessionViewResponse
 */
export interface FlowSessionViewResponse {
    /**
     * Session ID
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'session_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'chatbot_id'?: string | null;
    /**
     * Agent ID
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'flow_id': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'workspace_id': string;
    /**
     * Created at
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'last_msg_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewResponse
     */
    'msg_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewResponse
     */
    'credits'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'chatbot_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'flow_name'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof FlowSessionViewResponse
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewResponse
     */
    'duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'ipaddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewResponse
     */
    'positive_feedback_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewResponse
     */
    'negative_feedback_count'?: number | null;
}
/**
 * 
 * @export
 * @interface FlowSessionViewSearchRequest
 */
export interface FlowSessionViewSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewSearchRequest
     */
    'chatbot_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewSearchRequest
     */
    'flow_id'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof FlowSessionViewSearchRequest
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowSessionViewSearchRequest
     */
    'created_at_filter'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowSessionViewSearchRequest
     */
    'last_message_at_filter'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowSessionViewSearchRequest
     */
    'duration_filter'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowSessionViewSearchRequest
     */
    'msg_count_filter'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowSessionViewSearchRequest
     */
    'credits_filter'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewSearchRequest
     */
    'chatbot_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewSearchRequest
     */
    'flow_name'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowSessionViewSearchRequest
     */
    'ipaddress_filter'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {Pagination}
     * @memberof FlowSessionViewSearchRequest
     */
    'pagination'?: Pagination | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewSearchRequest
     */
    'positive_feedback'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewSearchRequest
     */
    'negative_feedback'?: number | null;
}
/**
 * 
 * @export
 * @interface FlowSessionViewUpdateRequest
 */
export interface FlowSessionViewUpdateRequest {
    /**
     * New tags value
     * @type {Array<string>}
     * @memberof FlowSessionViewUpdateRequest
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FlowType = {
    P: 'p',
    V: 'v'
} as const;

export type FlowType = typeof FlowType[keyof typeof FlowType];


/**
 * 
 * @export
 * @interface FlowUpdate
 */
export interface FlowUpdate {
    /**
     * The agent name
     * @type {string}
     * @memberof FlowUpdate
     */
    'name': string;
    /**
     * The agent description
     * @type {string}
     * @memberof FlowUpdate
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof FlowUpdate
     */
    'detailed_description'?: string | null;
    /**
     * The agent configuration
     * @type {FlowConfig}
     * @memberof FlowUpdate
     */
    'config': FlowConfig;
    /**
     * 
     * @type {string}
     * @memberof FlowUpdate
     */
    'category_id'?: string | null;
    /**
     * The agent branch
     * @type {FlowBranch}
     * @memberof FlowUpdate
     */
    'branch'?: FlowBranch;
    /**
     * 
     * @type {boolean}
     * @memberof FlowUpdate
     */
    'enable_cache'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof FlowUpdate
     */
    'version_nr'?: number | null;
}


/**
 * 
 * @export
 * @interface FlowVersionHistoryResponse
 */
export interface FlowVersionHistoryResponse {
    /**
     * Agent ID
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'id': string;
    /**
     * Agent name
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'name': string;
    /**
     * Agent description
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof FlowVersionHistoryResponse
     */
    'version_nr'?: number | null;
    /**
     * Agent type
     * @type {FlowType}
     * @memberof FlowVersionHistoryResponse
     */
    'flow_type': FlowType;
    /**
     * 
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'executed_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'category_id'?: string | null;
    /**
     * Enable cache
     * @type {boolean}
     * @memberof FlowVersionHistoryResponse
     */
    'enable_cache': boolean;
    /**
     * 
     * @type {UserResponse}
     * @memberof FlowVersionHistoryResponse
     */
    'user'?: UserResponse | null;
    /**
     * Agent branch
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'branch': string;
    /**
     * 
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'commit_title'?: string | null;
}


/**
 * 
 * @export
 * @interface Gender
 */
export interface Gender {
}
/**
 * General response schema for MCP subserver capabilities
 * @export
 * @interface GeneralMCPSubserverCapabilitiesResponse
 */
export interface GeneralMCPSubserverCapabilitiesResponse {
    /**
     * ID of the capability
     * @type {string}
     * @memberof GeneralMCPSubserverCapabilitiesResponse
     */
    'capability_id': string;
    /**
     * Name of the capability
     * @type {string}
     * @memberof GeneralMCPSubserverCapabilitiesResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GeneralMCPSubserverCapabilitiesResponse
     */
    'description'?: string | null;
}
/**
 * General response schema for MCP subserver binding
 * @export
 * @interface GeneralMCPSubserverResponse
 */
export interface GeneralMCPSubserverResponse {
    /**
     * ID of the MCP subserver
     * @type {string}
     * @memberof GeneralMCPSubserverResponse
     */
    'server_id': string;
    /**
     * Name of the MCP subserver
     * @type {string}
     * @memberof GeneralMCPSubserverResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GeneralMCPSubserverResponse
     */
    'description'?: string | null;
    /**
     * Status of the MCP subserver
     * @type {string}
     * @memberof GeneralMCPSubserverResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof GeneralMCPSubserverResponse
     */
    'icon'?: string | null;
    /**
     * Version of the MCP subserver
     * @type {string}
     * @memberof GeneralMCPSubserverResponse
     */
    'version': string;
    /**
     * List of capabilities for the MCP subserver
     * @type {Array<GeneralMCPSubserverCapabilitiesResponse>}
     * @memberof GeneralMCPSubserverResponse
     */
    'capabilities'?: Array<GeneralMCPSubserverCapabilitiesResponse>;
    /**
     * 
     * @type {IntegrationSlug}
     * @memberof GeneralMCPSubserverResponse
     */
    'integration_slug': IntegrationSlug | null;
}


/**
 * 
 * @export
 * @interface GetNodeRequest
 */
export interface GetNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof GetNodeRequest
     */
    'cat_id'?: string | null;
}
/**
 * 
 * @export
 * @interface GitHubRepoResponse
 */
export interface GitHubRepoResponse {
    /**
     * Repo Name
     * @type {string}
     * @memberof GitHubRepoResponse
     */
    'name'?: string;
    /**
     * Is Private Repo
     * @type {boolean}
     * @memberof GitHubRepoResponse
     */
    'private'?: boolean;
    /**
     * Repo URL
     * @type {string}
     * @memberof GitHubRepoResponse
     */
    'html_url'?: string;
}
/**
 * 
 * @export
 * @interface GitHubReposResponse
 */
export interface GitHubReposResponse {
    /**
     * 
     * @type {Array<GitHubRepoResponse>}
     * @memberof GitHubReposResponse
     */
    'repos': Array<GitHubRepoResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GoogleAdsActionType = {
    I: 'I',
    N: 'N',
    O: 'O',
    Z: 'Z',
    R: 'R',
    H: 'H',
    M: 'M',
    L: 'L'
} as const;

export type GoogleAdsActionType = typeof GoogleAdsActionType[keyof typeof GoogleAdsActionType];


/**
 * 
 * @export
 * @interface GoogleAdsAnalyzeKeywordsRequest
 */
export interface GoogleAdsAnalyzeKeywordsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsAnalyzeKeywordsRequest
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsAnalyzeKeywordsRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsAnalyzeKeywordsRequest
     */
    'group_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsAnalyzeKeywordsRequest
     */
    'date_from'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GoogleAdsAnalyzeKeywordsRequest
     */
    'force_update'?: boolean | null;
}
/**
 * 
 * @export
 * @interface GoogleAdsCampaignResponse
 */
export interface GoogleAdsCampaignResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof GoogleAdsCampaignResponse
     */
    'workspace_id': string;
    /**
     * Google Ads Customer ID
     * @type {string}
     * @memberof GoogleAdsCampaignResponse
     */
    'customer_id': string;
    /**
     * Google Ads Campaign ID
     * @type {string}
     * @memberof GoogleAdsCampaignResponse
     */
    'campaign_id': string;
    /**
     * Google Ads Campaign Name
     * @type {string}
     * @memberof GoogleAdsCampaignResponse
     */
    'campaign_name': string;
    /**
     * Campaign Status
     * @type {GoogleAdsCampaignStatus}
     * @memberof GoogleAdsCampaignResponse
     */
    'campaign_status': GoogleAdsCampaignStatus;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignResponse
     */
    'language_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignResponse
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignResponse
     */
    'last_update'?: string | null;
    /**
     * Action Type
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsCampaignResponse
     */
    'action_type': GoogleAdsActionType;
}


/**
 * The possible statuses of an ad group.
 * @export
 * @enum {number}
 */

export const GoogleAdsCampaignStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type GoogleAdsCampaignStatus = typeof GoogleAdsCampaignStatus[keyof typeof GoogleAdsCampaignStatus];


/**
 * 
 * @export
 * @interface GoogleAdsCampaignUpdateRequest
 */
export interface GoogleAdsCampaignUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignUpdateRequest
     */
    'language_code': string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignUpdateRequest
     */
    'country': string | null;
    /**
     * 
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsCampaignUpdateRequest
     */
    'action_type': GoogleAdsActionType | null;
}


/**
 * 
 * @export
 * @interface GoogleAdsCampaignsResponse
 */
export interface GoogleAdsCampaignsResponse {
    /**
     * List of Google Ads Campaigns
     * @type {Array<GoogleAdsCampaignResponse>}
     * @memberof GoogleAdsCampaignsResponse
     */
    'campaigns': Array<GoogleAdsCampaignResponse>;
}
/**
 * 
 * @export
 * @interface GoogleAdsCampaignsSearchRequest
 */
export interface GoogleAdsCampaignsSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'campaign_name'?: string | null;
    /**
     * 
     * @type {GoogleAdsCampaignStatus}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'campaign_status'?: GoogleAdsCampaignStatus | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'language_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'country'?: string | null;
    /**
     * 
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'action_type'?: GoogleAdsActionType | null;
    /**
     * Limit of the search
     * @type {number}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {Pagination}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * 
 * @export
 * @interface GoogleAdsCustomerResponse
 */
export interface GoogleAdsCustomerResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'workspace_id': string;
    /**
     * Google Ads Customer ID
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'customer_id': string;
    /**
     * Google Ads Customer Name
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'customer_name': string;
    /**
     * Language Code
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'language_code': string;
    /**
     * Country Code
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'country': string;
    /**
     * Minimum Queries
     * @type {number}
     * @memberof GoogleAdsCustomerResponse
     */
    'min_queries': number;
    /**
     * Cluster Strength
     * @type {number}
     * @memberof GoogleAdsCustomerResponse
     */
    'cluster_strength': number;
    /**
     * Minimum Impressions
     * @type {number}
     * @memberof GoogleAdsCustomerResponse
     */
    'min_impressions': number;
    /**
     * Minimum Clicks
     * @type {number}
     * @memberof GoogleAdsCustomerResponse
     */
    'min_clicks': number;
    /**
     * 
     * @type {BoolChar}
     * @memberof GoogleAdsCustomerResponse
     */
    'process_negative_keywords'?: BoolChar | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'last_update'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'next_update'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'cron_settings'?: string | null;
    /**
     * Action Type
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsCustomerResponse
     */
    'action_type': GoogleAdsActionType;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'ga_measurement_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'ga_api_secret'?: string | null;
}


/**
 * 
 * @export
 * @interface GoogleAdsCustomerUpdateRequest
 */
export interface GoogleAdsCustomerUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'language_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'country'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'min_queries'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'cluster_strength'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'min_impressions'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'min_clicks'?: number | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'process_negative_keywords'?: BoolChar | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'cron_settings'?: string | null;
    /**
     * 
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'action_type'?: GoogleAdsActionType | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'ga_measurement_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'ga_api_secret'?: string | null;
}


/**
 * 
 * @export
 * @interface GoogleAdsCustomersResponse
 */
export interface GoogleAdsCustomersResponse {
    /**
     * List of Google Ads Customers
     * @type {Array<GoogleAdsCustomerResponse>}
     * @memberof GoogleAdsCustomersResponse
     */
    'customers': Array<GoogleAdsCustomerResponse>;
}
/**
 * 
 * @export
 * @interface GoogleAdsCustomersSearchRequest
 */
export interface GoogleAdsCustomersSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'customer_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'language_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'country'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'min_queries'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'min_clicks'?: number | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'process_negative_keywords'?: BoolChar | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'min_impressions'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'cluster_strength'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'last_update'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'next_update'?: string | null;
    /**
     * 
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'action_type'?: GoogleAdsActionType | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'ga_measurement_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'ga_api_secret'?: string | null;
}


/**
 * 
 * @export
 * @interface GoogleAdsGroupResponse
 */
export interface GoogleAdsGroupResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'workspace_id': string;
    /**
     * Google Ads Customer ID
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'customer_id': string;
    /**
     * Google Ads Campaign ID
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'campaign_id': string;
    /**
     * Google Ads Group
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'group_id': string;
    /**
     * Google Ads Group Name
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'group_name': string;
    /**
     * Group Status
     * @type {GoogleAdsGroupStatus}
     * @memberof GoogleAdsGroupResponse
     */
    'group_status': GoogleAdsGroupStatus;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'last_update'?: string | null;
    /**
     * Action Type
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsGroupResponse
     */
    'action_type': GoogleAdsActionType;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'language_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'country'?: string | null;
}


/**
 * The possible statuses of an ad group.
 * @export
 * @enum {number}
 */

export const GoogleAdsGroupStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type GoogleAdsGroupStatus = typeof GoogleAdsGroupStatus[keyof typeof GoogleAdsGroupStatus];


/**
 * 
 * @export
 * @interface GoogleAdsGroupUpdateRequest
 */
export interface GoogleAdsGroupUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupUpdateRequest
     */
    'language_code': string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupUpdateRequest
     */
    'country': string | null;
    /**
     * 
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsGroupUpdateRequest
     */
    'action_type': GoogleAdsActionType | null;
}


/**
 * 
 * @export
 * @interface GoogleAdsGroupsResponse
 */
export interface GoogleAdsGroupsResponse {
    /**
     * List of Google Ads Groups
     * @type {Array<GoogleAdsGroupResponse>}
     * @memberof GoogleAdsGroupsResponse
     */
    'groups': Array<GoogleAdsGroupResponse>;
}
/**
 * 
 * @export
 * @interface GoogleAdsGroupsSearchRequest
 */
export interface GoogleAdsGroupsSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'group_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'group_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'language_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'country'?: string | null;
    /**
     * 
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'action_type'?: GoogleAdsActionType | null;
    /**
     * 
     * @type {GoogleAdsGroupStatus}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'group_status'?: GoogleAdsGroupStatus | null;
    /**
     * Limit of the search
     * @type {number}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {Pagination}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * 
 * @export
 * @interface GoogleAdsKeywordAddRequest
 */
export interface GoogleAdsKeywordAddRequest {
    /**
     * Customer id
     * @type {string}
     * @memberof GoogleAdsKeywordAddRequest
     */
    'customer_id': string;
    /**
     * Campaign id
     * @type {string}
     * @memberof GoogleAdsKeywordAddRequest
     */
    'campaign_id': string;
    /**
     * Group id
     * @type {string}
     * @memberof GoogleAdsKeywordAddRequest
     */
    'group_id': string;
    /**
     * List of keywords to add
     * @type {Array<string>}
     * @memberof GoogleAdsKeywordAddRequest
     */
    'keywords': Array<string>;
    /**
     * Is negative keyword
     * @type {boolean}
     * @memberof GoogleAdsKeywordAddRequest
     */
    'is_negative'?: boolean;
    /**
     * Match type
     * @type {GoogleAdsMatchType}
     * @memberof GoogleAdsKeywordAddRequest
     */
    'match_type': GoogleAdsMatchType;
}


/**
 * 
 * @export
 * @interface GoogleAdsKeywordRecommendation
 */
export interface GoogleAdsKeywordRecommendation {
    /**
     * Workspace ID
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'workspace_id': string;
    /**
     * Customer ID
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'customer_id': string;
    /**
     * Campaign ID
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'campaign_id': string;
    /**
     * Campaign Name
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'campaign_name': string;
    /**
     * Group ID
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'group_id': string;
    /**
     * Group Name
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'group_name': string;
    /**
     * Keyword ID
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'keyword_id': string;
    /**
     * Keyword
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'keyword': string;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {Array<GoogleAdsRecommendation>}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'recommendations'?: Array<GoogleAdsRecommendation> | null;
}
/**
 * 
 * @export
 * @interface GoogleAdsKeywordRemoveRequest
 */
export interface GoogleAdsKeywordRemoveRequest {
    /**
     * Customer id
     * @type {string}
     * @memberof GoogleAdsKeywordRemoveRequest
     */
    'customer_id': string;
    /**
     * Campaign id
     * @type {string}
     * @memberof GoogleAdsKeywordRemoveRequest
     */
    'campaign_id': string;
    /**
     * Group id
     * @type {string}
     * @memberof GoogleAdsKeywordRemoveRequest
     */
    'group_id': string;
    /**
     * List of keywords to remove
     * @type {Array<string>}
     * @memberof GoogleAdsKeywordRemoveRequest
     */
    'keywords': Array<string>;
    /**
     * Is negative keyword
     * @type {boolean}
     * @memberof GoogleAdsKeywordRemoveRequest
     */
    'is_negative'?: boolean;
    /**
     * Match type
     * @type {GoogleAdsMatchType}
     * @memberof GoogleAdsKeywordRemoveRequest
     */
    'match_type': GoogleAdsMatchType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const GoogleAdsMatchType = {
    E: 'E',
    P: 'P',
    B: 'B'
} as const;

export type GoogleAdsMatchType = typeof GoogleAdsMatchType[keyof typeof GoogleAdsMatchType];


/**
 * 
 * @export
 * @interface GoogleAdsRecommendation
 */
export interface GoogleAdsRecommendation {
    /**
     * 
     * @type {GoogleAdsRecommendationType}
     * @memberof GoogleAdsRecommendation
     */
    'recommendation_type': GoogleAdsRecommendationType;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsRecommendation
     */
    'campaign_id': string;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsRecommendation
     */
    'campaign_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsRecommendation
     */
    'group_id': string;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsRecommendation
     */
    'group_name'?: string | null;
    /**
     * 
     * @type {GoogleAdsRecommendationStatus}
     * @memberof GoogleAdsRecommendation
     */
    'action_status': GoogleAdsRecommendationStatus;
    /**
     * 
     * @type {GoogleAdsRecommendationConfidence}
     * @memberof GoogleAdsRecommendation
     */
    'confidence'?: GoogleAdsRecommendationConfidence;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const GoogleAdsRecommendationConfidence = {
    H: 'H',
    M: 'M',
    L: 'L'
} as const;

export type GoogleAdsRecommendationConfidence = typeof GoogleAdsRecommendationConfidence[keyof typeof GoogleAdsRecommendationConfidence];


/**
 * 
 * @export
 * @enum {string}
 */

export const GoogleAdsRecommendationStatus = {
    E: 'E',
    S: 'S'
} as const;

export type GoogleAdsRecommendationStatus = typeof GoogleAdsRecommendationStatus[keyof typeof GoogleAdsRecommendationStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const GoogleAdsRecommendationType = {
    A: 'A',
    N: 'N'
} as const;

export type GoogleAdsRecommendationType = typeof GoogleAdsRecommendationType[keyof typeof GoogleAdsRecommendationType];


/**
 * 
 * @export
 * @interface GoogleAdsRecommendationsRequest
 */
export interface GoogleAdsRecommendationsRequest {
    /**
     * Customer id to get recommendations for
     * @type {string}
     * @memberof GoogleAdsRecommendationsRequest
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsRecommendationsRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsRecommendationsRequest
     */
    'group_id'?: string | null;
    /**
     * Limit of the search
     * @type {number}
     * @memberof GoogleAdsRecommendationsRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {Pagination}
     * @memberof GoogleAdsRecommendationsRequest
     */
    'pagination'?: Pagination | null;
}
/**
 * 
 * @export
 * @interface GoogleCalendarResponse
 */
export interface GoogleCalendarResponse {
    /**
     * Calendar ID
     * @type {string}
     * @memberof GoogleCalendarResponse
     */
    'calendar_id': string;
    /**
     * Calendar name
     * @type {string}
     * @memberof GoogleCalendarResponse
     */
    'calendar_name': string;
}
/**
 * 
 * @export
 * @interface GoogleCalendarsResponse
 */
export interface GoogleCalendarsResponse {
    /**
     * 
     * @type {Array<GoogleCalendarResponse>}
     * @memberof GoogleCalendarsResponse
     */
    'calendars': Array<GoogleCalendarResponse>;
}
/**
 * 
 * @export
 * @interface GooglePickerTokenResponse
 */
export interface GooglePickerTokenResponse {
    /**
     * Picker token
     * @type {string}
     * @memberof GooglePickerTokenResponse
     */
    'picker_token': string;
}
/**
 * 
 * @export
 * @interface GoogleProductCategory
 */
export interface GoogleProductCategory {
}
/**
 * 
 * @export
 * @interface GoogleSheetResponse
 */
export interface GoogleSheetResponse {
    /**
     * Sheet ID
     * @type {number}
     * @memberof GoogleSheetResponse
     */
    'sheet_id': number;
    /**
     * Sheet title
     * @type {string}
     * @memberof GoogleSheetResponse
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface GoogleSheetsResponse
 */
export interface GoogleSheetsResponse {
    /**
     * 
     * @type {Array<GoogleSheetResponse>}
     * @memberof GoogleSheetsResponse
     */
    'sheets': Array<GoogleSheetResponse>;
}
/**
 * 
 * @export
 * @interface Gtin
 */
export interface Gtin {
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface HubSpotActorIdResponse
 */
export interface HubSpotActorIdResponse {
    /**
     * Actor ID
     * @type {string}
     * @memberof HubSpotActorIdResponse
     */
    'actor_id': string;
    /**
     * Actor Email
     * @type {string}
     * @memberof HubSpotActorIdResponse
     */
    'actor_email': string;
}
/**
 * 
 * @export
 * @interface HubSpotActorsResponse
 */
export interface HubSpotActorsResponse {
    /**
     * 
     * @type {Array<HubSpotActorIdResponse>}
     * @memberof HubSpotActorsResponse
     */
    'actors': Array<HubSpotActorIdResponse>;
}
/**
 * 
 * @export
 * @interface HumanAgentSender
 */
export interface HumanAgentSender {
    /**
     * 
     * @type {string}
     * @memberof HumanAgentSender
     */
    'sender_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof HumanAgentSender
     */
    'sender_avatar'?: string | null;
}
/**
 * 
 * @export
 * @interface Id
 */
export interface Id {
}
/**
 * 
 * @export
 * @interface ImageConvertRequest
 */
export interface ImageConvertRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageConvertRequest
     */
    'post_back_url'?: string | null;
    /**
     * Image URL to convert
     * @type {string}
     * @memberof ImageConvertRequest
     */
    'image_url': string;
    /**
     * Image format to convert to
     * @type {string}
     * @memberof ImageConvertRequest
     */
    'format': string;
    /**
     * 
     * @type {number}
     * @memberof ImageConvertRequest
     */
    'quality'?: number | null;
}
/**
 * 
 * @export
 * @interface ImageFTCreateRequest
 */
export interface ImageFTCreateRequest {
    /**
     * Fine tuning name
     * @type {string}
     * @memberof ImageFTCreateRequest
     */
    'name': string;
    /**
     * Trigger word
     * @type {string}
     * @memberof ImageFTCreateRequest
     */
    'trigger_word': string;
    /**
     * 
     * @type {number}
     * @memberof ImageFTCreateRequest
     */
    'steps'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ImageFTCreateRequest
     */
    'lora_rank'?: number | null;
    /**
     * Training images
     * @type {Array<string>}
     * @memberof ImageFTCreateRequest
     */
    'training_images': Array<string>;
    /**
     * Cover image
     * @type {string}
     * @memberof ImageFTCreateRequest
     */
    'cover_image': string;
}
/**
 * 
 * @export
 * @interface ImageFTResponse
 */
export interface ImageFTResponse {
    /**
     * Fine tuning type
     * @type {FTType}
     * @memberof ImageFTResponse
     */
    'ft_type': FTType;
    /**
     * Fine tuning id
     * @type {string}
     * @memberof ImageFTResponse
     */
    'ft_id': string;
    /**
     * Fine tuning name
     * @type {string}
     * @memberof ImageFTResponse
     */
    'name': string;
    /**
     * Number of steps
     * @type {number}
     * @memberof ImageFTResponse
     */
    'steps': number;
    /**
     * Lora rank
     * @type {number}
     * @memberof ImageFTResponse
     */
    'lora_rank': number;
    /**
     * Trigger word
     * @type {string}
     * @memberof ImageFTResponse
     */
    'trigger_word': string;
    /**
     * Training images
     * @type {Array<string>}
     * @memberof ImageFTResponse
     */
    'training_images': Array<string>;
    /**
     * Status
     * @type {FTStatus}
     * @memberof ImageFTResponse
     */
    'status': FTStatus;
    /**
     * 
     * @type {string}
     * @memberof ImageFTResponse
     */
    'cover_image': string | null;
}


/**
 * 
 * @export
 * @interface ImageFTSearchRequest
 */
export interface ImageFTSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageFTSearchRequest
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface ImageFTUpdateRequest
 */
export interface ImageFTUpdateRequest {
    /**
     * Fine tuning name
     * @type {string}
     * @memberof ImageFTUpdateRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ImageFTUpdateRequest
     */
    'steps'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ImageFTUpdateRequest
     */
    'lora_rank'?: number | null;
    /**
     * Training images
     * @type {Array<string>}
     * @memberof ImageFTUpdateRequest
     */
    'training_images': Array<string>;
    /**
     * Cover image
     * @type {string}
     * @memberof ImageFTUpdateRequest
     */
    'cover_image': string;
}
/**
 * 
 * @export
 * @interface ImageInferenceRequest
 */
export interface ImageInferenceRequest {
    /**
     * The base model to use for inference
     * @type {BaseFoundationModel}
     * @memberof ImageInferenceRequest
     */
    'base_model': BaseFoundationModel;
    /**
     * The prompt to use for inference
     * @type {string}
     * @memberof ImageInferenceRequest
     */
    'prompt': string;
    /**
     * The list of image FTs to use for inference
     * @type {Array<string>}
     * @memberof ImageInferenceRequest
     */
    'image_fts': Array<string>;
    /**
     * The number of outputs to generate
     * @type {number}
     * @memberof ImageInferenceRequest
     */
    'number_of_outputs'?: number;
    /**
     * The aspect ratio of the output images
     * @type {AspecRatio}
     * @memberof ImageInferenceRequest
     */
    'aspect_ratio'?: AspecRatio;
    /**
     * 
     * @type {number}
     * @memberof ImageInferenceRequest
     */
    'steps'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ImageInferenceRequest
     */
    'guidance_scale'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImageInferenceRequest
     */
    'styles'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImageInferenceRequest
     */
    'effects'?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ImageInferenceRequest
     */
    'use_ai_agent'?: boolean | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImageInferenceRequest
     */
    'reference_images'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImageInferenceRequest
     */
    'reference_videos'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ImageInferenceRequest
     */
    'duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ImageInferenceRequest
     */
    'resolution'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ImageInferenceRequest
     */
    'generate_audio'?: boolean | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImageInferenceRequest
     */
    'start_image'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImageInferenceRequest
     */
    'last_frame'?: Array<string> | null;
}


/**
 * 
 * @export
 * @interface ImageInferenceResponse
 */
export interface ImageInferenceResponse {
    /**
     * The ID of the inference
     * @type {string}
     * @memberof ImageInferenceResponse
     */
    'inference_id': string;
    /**
     * The URL of the image
     * @type {Array<string>}
     * @memberof ImageInferenceResponse
     */
    'image_url_outputs': Array<string>;
    /**
     * The date the image was created
     * @type {string}
     * @memberof ImageInferenceResponse
     */
    'date_created': string;
    /**
     * The prompt used for the inference
     * @type {string}
     * @memberof ImageInferenceResponse
     */
    'prompt': string;
    /**
     * The styles used for the inference
     * @type {Array<string>}
     * @memberof ImageInferenceResponse
     */
    'styles': Array<string>;
    /**
     * The effects used for the inference
     * @type {Array<string>}
     * @memberof ImageInferenceResponse
     */
    'effects': Array<string>;
    /**
     * The aspect ratio of the output images
     * @type {string}
     * @memberof ImageInferenceResponse
     */
    'aspect_ratio': string;
    /**
     * The AI model used for the inference
     * @type {string}
     * @memberof ImageInferenceResponse
     */
    'ai_model': string;
    /**
     * The status of the inference
     * @type {string}
     * @memberof ImageInferenceResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ImageInferenceResponse
     */
    'error_msg'?: string | null;
}
/**
 * 
 * @export
 * @interface ImageInferenceResultResponse
 */
export interface ImageInferenceResultResponse {
    /**
     * 
     * @type {ImageInferenceResponse}
     * @memberof ImageInferenceResultResponse
     */
    'result'?: ImageInferenceResponse | null;
    /**
     * Whether the inference is completed
     * @type {string}
     * @memberof ImageInferenceResultResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ImageInferenceResultResponse
     */
    'error_message'?: string | null;
}
/**
 * 
 * @export
 * @interface ImageInferenceScheduleResponse
 */
export interface ImageInferenceScheduleResponse {
    /**
     * The ID of the inference
     * @type {string}
     * @memberof ImageInferenceScheduleResponse
     */
    'inference_id': string;
}
/**
 * 
 * @export
 * @interface ImageInferenceScrollResponse
 */
export interface ImageInferenceScrollResponse {
    /**
     * 
     * @type {Array<any>}
     * @memberof ImageInferenceScrollResponse
     */
    'search_after'?: Array<any> | null;
    /**
     * The list of inference results
     * @type {Array<ImageInferenceResponse>}
     * @memberof ImageInferenceScrollResponse
     */
    'results': Array<ImageInferenceResponse>;
}
/**
 * 
 * @export
 * @interface ImageLink
 */
export interface ImageLink {
}
/**
 * 
 * @export
 * @interface ImageOptimizeRequest
 */
export interface ImageOptimizeRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageOptimizeRequest
     */
    'post_back_url'?: string | null;
    /**
     * Image URL to optimize
     * @type {string}
     * @memberof ImageOptimizeRequest
     */
    'image_url': string;
    /**
     * 
     * @type {number}
     * @memberof ImageOptimizeRequest
     */
    'quality'?: number | null;
}
/**
 * 
 * @export
 * @interface ImagePromptGenerationRequest
 */
export interface ImagePromptGenerationRequest {
    /**
     * 
     * @type {string}
     * @memberof ImagePromptGenerationRequest
     */
    'current_prompt'?: string | null;
}
/**
 * 
 * @export
 * @interface ImagePromptResponse
 */
export interface ImagePromptResponse {
    /**
     * The prompt generated for the inference
     * @type {string}
     * @memberof ImagePromptResponse
     */
    'prompt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const InferenceFileType = {
    InferenceOutput: 'inference_output',
    TrainingData: 'training_data'
} as const;

export type InferenceFileType = typeof InferenceFileType[keyof typeof InferenceFileType];


/**
 * 
 * @export
 * @interface InferenceHistorySearchRequest
 */
export interface InferenceHistorySearchRequest {
    /**
     * 
     * @type {string}
     * @memberof InferenceHistorySearchRequest
     */
    'from_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InferenceHistorySearchRequest
     */
    'to_date'?: string | null;
    /**
     * The number of results to return
     * @type {number}
     * @memberof InferenceHistorySearchRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof InferenceHistorySearchRequest
     */
    'search_after'?: Array<any> | null;
    /**
     * 
     * @type {BaseFoundationModel}
     * @memberof InferenceHistorySearchRequest
     */
    'base_model'?: BaseFoundationModel | null;
    /**
     * 
     * @type {string}
     * @memberof InferenceHistorySearchRequest
     */
    'style'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InferenceHistorySearchRequest
     */
    'effect'?: string | null;
    /**
     * 
     * @type {AspecRatio}
     * @memberof InferenceHistorySearchRequest
     */
    'aspect_ratio'?: AspecRatio | null;
}


/**
 * 
 * @export
 * @interface InstagramProfileInformationResponse
 */
export interface InstagramProfileInformationResponse {
    /**
     * Instagram profile name
     * @type {string}
     * @memberof InstagramProfileInformationResponse
     */
    'user_name': string;
    /**
     * 
     * @type {string}
     * @memberof InstagramProfileInformationResponse
     */
    'profile_pic_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InstagramProfileInformationResponse
     */
    'biography'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InstagramProfileInformationResponse
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const IntegrationCategory = {
    DevTools: 'dev_tools',
    Crm: 'crm',
    SocialMedia: 'social_media',
    Ecommerce: 'ecommerce',
    Content: 'content',
    Sales: 'sales',
    Marketing: 'marketing',
    Cms: 'cms',
    Google: 'google',
    Communication: 'communication',
    Analytics: 'analytics',
    Finance: 'finance'
} as const;

export type IntegrationCategory = typeof IntegrationCategory[keyof typeof IntegrationCategory];


/**
 * 
 * @export
 * @interface IntegrationDetailResponse
 */
export interface IntegrationDetailResponse {
    /**
     * The type of the integration.
     * @type {string}
     * @memberof IntegrationDetailResponse
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationDetailResponse
     */
    'integration_id'?: string;
    /**
     * The name of the integration.
     * @type {string}
     * @memberof IntegrationDetailResponse
     */
    'integration_name': string;
    /**
     * The creation date of the integration.
     * @type {string}
     * @memberof IntegrationDetailResponse
     */
    'created_at': string;
    /**
     * The metadata of the integration.
     * @type {}
     * @memberof IntegrationDetailResponse
     */
    'metadata'?:  | null;
}
/**
 * 
 * @export
 * @interface IntegrationFlowResponse
 */
export interface IntegrationFlowResponse {
    /**
     * The URL to redirect to.
     * @type {string}
     * @memberof IntegrationFlowResponse
     */
    'redirect_to': string;
}
/**
 * 
 * @export
 * @interface IntegrationResponse
 */
export interface IntegrationResponse {
    /**
     * The slug of the integration.
     * @type {string}
     * @memberof IntegrationResponse
     */
    'slug': string;
    /**
     * The name of the integration.
     * @type {string}
     * @memberof IntegrationResponse
     */
    'name': string;
    /**
     * The description of the integration.
     * @type {string}
     * @memberof IntegrationResponse
     */
    'description': string;
    /**
     * The number of integrated instances.
     * @type {number}
     * @memberof IntegrationResponse
     */
    'integrated_instance_cnt': number;
    /**
     * The categories of the integration.
     * @type {Array<IntegrationCategory>}
     * @memberof IntegrationResponse
     */
    'categories': Array<IntegrationCategory>;
    /**
     * Whether the integration is in alpha or not.
     * @type {boolean}
     * @memberof IntegrationResponse
     */
    'alpha'?: boolean;
    /**
     * Whether the integration is in beta or not.
     * @type {boolean}
     * @memberof IntegrationResponse
     */
    'beta'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IntegrationResponse
     */
    'public_flow_id'?: string | null;
}
/**
 * 
 * @export
 * @interface IntegrationSearchRequest
 */
export interface IntegrationSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationSearchRequest
     */
    'integration_name'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const IntegrationSlug = {
    ShopifyIntegration: 'shopify_integration',
    SlackIntegration: 'slack_integration',
    HubspotIntegration: 'hubspot_integration',
    LiveagentIntegration: 'liveagent_integration',
    HubspotWidgetIntegration: 'hubspot_widget_integration',
    LivechatIntegration: 'livechat_integration',
    SmartsuppIntegration: 'smartsupp_integration',
    FreshchatIntegration: 'freshchat_integration',
    TawkIntegration: 'tawk_integration',
    GoogleIntegration: 'google_integration',
    WordpressIntegration: 'wordpress_integration',
    GmailIntegration: 'gmail_integration',
    InstagramIntegration: 'instagram_integration',
    MicrosoftOutlookIntegration: 'microsoft_outlook_integration',
    MicrosoftIntegration: 'microsoft_integration',
    OdooIntegration: 'odoo_integration',
    AtlassianTokenIntegration: 'atlassian_token_integration',
    BizniswebIntegration: 'biznisweb_integration',
    Bitrix24Integration: 'bitrix24_integration',
    ApiSportsIntegration: 'api_sports_integration',
    GithubIntegration: 'github_integration',
    PowerbiIntegration: 'powerbi_integration',
    BexioIntegration: 'bexio_integration',
    MailchimpIntegration: 'mailchimp_integration',
    LinkedinIntegration: 'linkedin_integration',
    Magento2Integration: 'magento2_integration',
    AlpacaIntegration: 'alpaca_integration',
    PolygonIntegration: 'polygon_integration',
    PostaffiliateproIntegration: 'postaffiliatepro_integration',
    ZohoIntegration: 'zoho_integration',
    TelegramIntegration: 'telegram_integration',
    AirtableIntegration: 'airtable_integration',
    WixIntegration: 'wix_integration',
    ChameleoonIntegration: 'chameleoon_integration',
    NotionIntegration: 'notion_integration',
    KlaviyoIntegration: 'klaviyo_integration',
    GoogleCalendarIntegration: 'google_calendar_integration',
    GoogleAdsIntegration: 'google_ads_integration',
    GoogleDocsIntegration: 'google_docs_integration',
    GoogleDriveIntegration: 'google_drive_integration',
    GoogleSheetsIntegration: 'google_sheets_integration',
    GoogleTasksIntegration: 'google_tasks_integration',
    GoogleMeetIntegration: 'google_meet_integration',
    GoogleSlidesIntegration: 'google_slides_integration',
    GoogleSearchConsoleIntegration: 'google_search_console_integration',
    GoogleBigqueryIntegration: 'google_bigquery_integration',
    MicrosoftCalendarIntegration: 'microsoft_calendar_integration',
    MicrosoftExcelIntegration: 'microsoft_excel_integration',
    MicrosoftOnedriveIntegration: 'microsoft_onedrive_integration',
    MicrosoftSharepointIntegration: 'microsoft_sharepoint_integration',
    MicrosoftOnenoteIntegration: 'microsoft_onenote_integration',
    MicrosoftTodoIntegration: 'microsoft_todo_integration',
    MicrosoftPlannerIntegration: 'microsoft_planner_integration',
    MicrosoftOutlookContactsIntegration: 'microsoft_outlook_contacts_integration',
    MicrosoftTeamsIntegration: 'microsoft_teams_integration'
} as const;

export type IntegrationSlug = typeof IntegrationSlug[keyof typeof IntegrationSlug];


/**
 * 
 * @export
 * @interface ItemGroupId
 */
export interface ItemGroupId {
}
/**
 * 
 * @export
 * @interface LangfuseRequest
 */
export interface LangfuseRequest {
    /**
     * 
     * @type {string}
     * @memberof LangfuseRequest
     */
    'langfuse_public_key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LangfuseRequest
     */
    'langfuse_secret_key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LangfuseRequest
     */
    'langfuse_host'?: string | null;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LogEntryLevel = {
    I: 'I',
    W: 'W',
    E: 'E',
    D: 'D'
} as const;

export type LogEntryLevel = typeof LogEntryLevel[keyof typeof LogEntryLevel];


/**
 * 
 * @export
 * @enum {string}
 */

export const LogEntryType = {
    S: 'S',
    C: 'C',
    I: 'I',
    L: 'L',
    E: 'E'
} as const;

export type LogEntryType = typeof LogEntryType[keyof typeof LogEntryType];


/**
 * 
 * @export
 * @interface LogResponse
 */
export interface LogResponse {
    /**
     * Unique identifier for the log entry
     * @type {string}
     * @memberof LogResponse
     */
    'log_id': string;
    /**
     * Type of log (e.g., \'system\', \'application\', \'user\')
     * @type {LogEntryType}
     * @memberof LogResponse
     */
    'log_type': LogEntryType;
    /**
     * 
     * @type {string}
     * @memberof LogResponse
     */
    'category_id'?: string | null;
    /**
     * Log level (e.g., \'info\', \'warning\', \'error\', \'debug\')
     * @type {LogEntryLevel}
     * @memberof LogResponse
     */
    'log_level': LogEntryLevel;
    /**
     * Log message content
     * @type {string}
     * @memberof LogResponse
     */
    'message': string;
    /**
     * Timestamp when the log was created
     * @type {string}
     * @memberof LogResponse
     */
    'created_at': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof LogResponse
     */
    'metadata'?: { [key: string]: any; } | null;
}


/**
 * Request model for searching logs.
 * @export
 * @interface LogsSearchRequest
 */
export interface LogsSearchRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof LogsSearchRequest
     */
    'log_types'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LogsSearchRequest
     */
    'log_levels'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof LogsSearchRequest
     */
    'category_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LogsSearchRequest
     */
    'from_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LogsSearchRequest
     */
    'to_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LogsSearchRequest
     */
    'search_text'?: string | null;
    /**
     * Page number for pagination
     * @type {number}
     * @memberof LogsSearchRequest
     */
    'page'?: number;
    /**
     * Number of results per page
     * @type {number}
     * @memberof LogsSearchRequest
     */
    'page_size'?: number;
    /**
     * Field to sort results by
     * @type {string}
     * @memberof LogsSearchRequest
     */
    'sort_by'?: string;
    /**
     * Sort direction (asc or desc)
     * @type {SortDirection}
     * @memberof LogsSearchRequest
     */
    'sort_direction'?: SortDirection;
}


/**
 * Represents a binding between an MCP server and a capability
 * @export
 * @interface MCPCapabilityBinding
 */
export interface MCPCapabilityBinding {
    /**
     * 
     * @type {string}
     * @memberof MCPCapabilityBinding
     */
    'capability_id': string;
}
/**
 * Request schema for creating a new MCP server
 * @export
 * @interface MCPServerCreateRequest
 */
export interface MCPServerCreateRequest {
    /**
     * Name of the MCP server
     * @type {string}
     * @memberof MCPServerCreateRequest
     */
    'name': string;
    /**
     * Whether the MCP server is active
     * @type {boolean}
     * @memberof MCPServerCreateRequest
     */
    'is_active'?: boolean;
    /**
     * List of subserver bindings for the MCP server configuration
     * @type {Array<MCPSubServerBinding>}
     * @memberof MCPServerCreateRequest
     */
    'server_configuration': Array<MCPSubServerBinding>;
}
/**
 * Response schema for MCP server
 * @export
 * @interface MCPServerResponse
 */
export interface MCPServerResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof MCPServerResponse
     */
    'workspace_id': string;
    /**
     * MCP Server ID
     * @type {string}
     * @memberof MCPServerResponse
     */
    'mcp_server_id': string;
    /**
     * Name of the MCP server
     * @type {string}
     * @memberof MCPServerResponse
     */
    'name': string;
    /**
     * List of subserver bindings for the MCP server configuration
     * @type {Array<MCPSubServerBinding>}
     * @memberof MCPServerResponse
     */
    'server_configuration': Array<MCPSubServerBinding>;
    /**
     * Whether the MCP server is active
     * @type {boolean}
     * @memberof MCPServerResponse
     */
    'is_active': boolean;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof MCPServerResponse
     */
    'created_at': string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof MCPServerResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof MCPServerResponse
     */
    'remote_mcp_url'?: string | null;
}
/**
 * Request schema for searching MCP servers
 * @export
 * @interface MCPServerSearchRequest
 */
export interface MCPServerSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof MCPServerSearchRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MCPServerSearchRequest
     */
    'active_only'?: boolean | null;
}
/**
 * Represents a binding between an MCP server and an MCP sub server
 * @export
 * @interface MCPSubServerBinding
 */
export interface MCPSubServerBinding {
    /**
     * 
     * @type {string}
     * @memberof MCPSubServerBinding
     */
    'subserver_id': string;
    /**
     * 
     * @type {Array<MCPCapabilityBinding>}
     * @memberof MCPSubServerBinding
     */
    'capabilities': Array<MCPCapabilityBinding>;
}
/**
 * 
 * @export
 * @interface Material
 */
export interface Material {
}
/**
 * 
 * @export
 * @interface MemoryDocumentProcessRequest
 */
export interface MemoryDocumentProcessRequest {
    /**
     * Category ID
     * @type {string}
     * @memberof MemoryDocumentProcessRequest
     */
    'cat_id': string;
    /**
     * Flow ID to process the documents
     * @type {string}
     * @memberof MemoryDocumentProcessRequest
     */
    'flow_id': string;
    /**
     * List of document IDs to process
     * @type {Array<string>}
     * @memberof MemoryDocumentProcessRequest
     */
    'doc_ids': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MemoryDocumentProcessRequest
     */
    'parent_node_id'?: string | null;
}
/**
 * 
 * @export
 * @interface MemoryDocumentUploadResponse
 */
export interface MemoryDocumentUploadResponse {
    /**
     * Document ID
     * @type {string}
     * @memberof MemoryDocumentUploadResponse
     */
    'doc_id': string;
    /**
     * Document name
     * @type {string}
     * @memberof MemoryDocumentUploadResponse
     */
    'doc_name': string;
    /**
     * Upload status message
     * @type {string}
     * @memberof MemoryDocumentUploadResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface MemoryMessageResponse
 */
export interface MemoryMessageResponse {
    /**
     * Response message
     * @type {string}
     * @memberof MemoryMessageResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface MemoryNodeDetailResponse
 */
export interface MemoryNodeDetailResponse {
    /**
     * Node ID
     * @type {string}
     * @memberof MemoryNodeDetailResponse
     */
    'node_id': string;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeDetailResponse
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MemoryNodeDetailResponse
     */
    'depth'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeDetailResponse
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeDetailResponse
     */
    'body'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeDetailResponse
     */
    'path'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MemoryNodeDetailResponse
     */
    'offload_ids'?: Array<string> | null;
    /**
     * 
     * @type {Array<Source>}
     * @memberof MemoryNodeDetailResponse
     */
    'sources'?: Array<Source> | null;
}
/**
 * 
 * @export
 * @interface MemoryNodeNameSearchRequest
 */
export interface MemoryNodeNameSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeNameSearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeNameSearchRequest
     */
    'query'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MemoryNodeNameSearchRequest
     */
    'depth'?: number | null;
}
/**
 * 
 * @export
 * @interface MemoryNodePathSearchRequest
 */
export interface MemoryNodePathSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryNodePathSearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodePathSearchRequest
     */
    'node_path'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MemoryNodePathSearchRequest
     */
    'depth'?: number | null;
}
/**
 * 
 * @export
 * @interface MemoryNodeResponse
 */
export interface MemoryNodeResponse {
    /**
     * Node ID
     * @type {string}
     * @memberof MemoryNodeResponse
     */
    'node_id': string;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeResponse
     */
    'parent_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeResponse
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeResponse
     */
    'body'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeResponse
     */
    'path'?: string | null;
}
/**
 * 
 * @export
 * @interface MemorySearchRequest
 */
export interface MemorySearchRequest {
    /**
     * 
     * @type {string}
     * @memberof MemorySearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemorySearchRequest
     */
    'query'?: string | null;
    /**
     * 
     * @type {SearchType}
     * @memberof MemorySearchRequest
     */
    'search_method'?: SearchType | null;
    /**
     * 
     * @type {number}
     * @memberof MemorySearchRequest
     */
    'depth'?: number | null;
}


/**
 * 
 * @export
 * @interface MemorySearchResponse
 */
export interface MemorySearchResponse {
    /**
     * Node ID
     * @type {string}
     * @memberof MemorySearchResponse
     */
    'node_id': string;
    /**
     * 
     * @type {string}
     * @memberof MemorySearchResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemorySearchResponse
     */
    'path'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemorySearchResponse
     */
    'parent_id'?: string | null;
    /**
     * 
     * @type {Array<MemorySearchResponse>}
     * @memberof MemorySearchResponse
     */
    'children'?: Array<MemorySearchResponse> | null;
}
/**
 * 
 * @export
 * @interface MerchantMetadata
 */
export interface MerchantMetadata {
    [key: string]: any;

    /**
     * 
     * @type {Id}
     * @memberof MerchantMetadata
     */
    'id'?: Id;
    /**
     * 
     * @type {ItemGroupId}
     * @memberof MerchantMetadata
     */
    'item_group_id'?: ItemGroupId;
    /**
     * 
     * @type {Gtin}
     * @memberof MerchantMetadata
     */
    'gtin'?: Gtin;
    /**
     * 
     * @type {Mpn}
     * @memberof MerchantMetadata
     */
    'mpn'?: Mpn;
    /**
     * 
     * @type {Title}
     * @memberof MerchantMetadata
     */
    'title'?: Title;
    /**
     * 
     * @type {Description}
     * @memberof MerchantMetadata
     */
    'description'?: Description;
    /**
     * 
     * @type {Link}
     * @memberof MerchantMetadata
     */
    'link'?: Link;
    /**
     * 
     * @type {Brand}
     * @memberof MerchantMetadata
     */
    'brand'?: Brand;
    /**
     * 
     * @type {Price}
     * @memberof MerchantMetadata
     */
    'price'?: Price;
    /**
     * 
     * @type {ImageLink}
     * @memberof MerchantMetadata
     */
    'image_link'?: ImageLink;
    /**
     * 
     * @type {AdditionalImageLink}
     * @memberof MerchantMetadata
     */
    'additional_image_link'?: AdditionalImageLink;
    /**
     * 
     * @type {Availability}
     * @memberof MerchantMetadata
     */
    'availability'?: Availability;
    /**
     * 
     * @type {Condition}
     * @memberof MerchantMetadata
     */
    'condition'?: Condition;
    /**
     * 
     * @type {GoogleProductCategory}
     * @memberof MerchantMetadata
     */
    'google_product_category'?: GoogleProductCategory;
    /**
     * 
     * @type {ProductType}
     * @memberof MerchantMetadata
     */
    'product_type'?: ProductType;
    /**
     * 
     * @type {Color}
     * @memberof MerchantMetadata
     */
    'color'?: Color;
    /**
     * 
     * @type {Size}
     * @memberof MerchantMetadata
     */
    'size'?: Size;
    /**
     * 
     * @type {Material}
     * @memberof MerchantMetadata
     */
    'material'?: Material;
    /**
     * 
     * @type {AgeGroup}
     * @memberof MerchantMetadata
     */
    'age_group'?: AgeGroup;
    /**
     * 
     * @type {Gender}
     * @memberof MerchantMetadata
     */
    'gender'?: Gender;
    /**
     * 
     * @type {Shipping}
     * @memberof MerchantMetadata
     */
    'shipping'?: Shipping;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MessageFeedback = {
    P: 'P',
    N: 'N'
} as const;

export type MessageFeedback = typeof MessageFeedback[keyof typeof MessageFeedback];


/**
 * 
 * @export
 * @enum {string}
 */

export const MessageType = {
    Ai: 'ai',
    Human: 'human',
    System: 'system',
    FlowAssistantAction: 'flow_assistant_action'
} as const;

export type MessageType = typeof MessageType[keyof typeof MessageType];


/**
 * Metadata
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * Message ID
     * @type {string}
     * @memberof Metadata
     */
    'message_id': string;
    /**
     * Message
     * @type {string}
     * @memberof Metadata
     */
    'message': string;
    /**
     * 
     * @type {HumanAgentSender}
     * @memberof Metadata
     */
    'sender'?: HumanAgentSender;
    /**
     * Tool name
     * @type {string}
     * @memberof Metadata
     */
    'tool_name': string;
    /**
     * Loading description
     * @type {string}
     * @memberof Metadata
     */
    'loading_desc': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'icon'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'detailed_description'?: string;
    /**
     * Message ID
     * @type {string}
     * @memberof Metadata
     */
    'feedback_message_id': string;
    /**
     * 
     * @type {MessageFeedback}
     * @memberof Metadata
     */
    'feedback'?: MessageFeedback;
    /**
     * Search query
     * @type {string}
     * @memberof Metadata
     */
    'agent_query': string;
    /**
     * Tool response
     * @type {string}
     * @memberof Metadata
     */
    'tool_response': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'task_name': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'task_input': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'agent': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'task_response': string;
    /**
     * List of artefact files created by agent
     * @type {Array<FlowSessionArtefactInfo>}
     * @memberof Metadata
     */
    'artefacts': Array<FlowSessionArtefactInfo>;
    /**
     * Unique CoT identifier for updates
     * @type {string}
     * @memberof Metadata
     */
    'cot_id': string;
    /**
     * Chain of thought / reasoning text
     * @type {string}
     * @memberof Metadata
     */
    'content': string;
    /**
     * Unique todo list identifier for updates
     * @type {string}
     * @memberof Metadata
     */
    'todo_id': string;
    /**
     * List of todo items
     * @type {Array<TodoItem>}
     * @memberof Metadata
     */
    'todos': Array<TodoItem>;
    /**
     * Action ID
     * @type {string}
     * @memberof Metadata
     */
    'action_id': string;
    /**
     * Component ID
     * @type {string}
     * @memberof Metadata
     */
    'component_id': string;
    /**
     * Component name
     * @type {string}
     * @memberof Metadata
     */
    'component_type': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'component_display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'component_icon'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Metadata
     */
    'parameter_values'?: { [key: string]: any; };
    /**
     * Source component ID
     * @type {string}
     * @memberof Metadata
     */
    'source_component_id': string;
    /**
     * Target component ID
     * @type {string}
     * @memberof Metadata
     */
    'target_component_id': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'source_field_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'target_field_name'?: string;
    /**
     * Agent name
     * @type {string}
     * @memberof Metadata
     */
    'flow_name': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'flow_description'?: string;
    /**
     * Agent ID
     * @type {string}
     * @memberof Metadata
     */
    'flow_id': string;
}


/**
 * 
 * @export
 * @interface MicrosoftPowerBiDatasetResponse
 */
export interface MicrosoftPowerBiDatasetResponse {
    /**
     * Dataset ID
     * @type {string}
     * @memberof MicrosoftPowerBiDatasetResponse
     */
    'dataset_id': string;
    /**
     * Dataset name
     * @type {string}
     * @memberof MicrosoftPowerBiDatasetResponse
     */
    'dataset_name': string;
}
/**
 * 
 * @export
 * @interface MicrosoftPowerBiDatasetsResponse
 */
export interface MicrosoftPowerBiDatasetsResponse {
    /**
     * 
     * @type {Array<MicrosoftPowerBiDatasetResponse>}
     * @memberof MicrosoftPowerBiDatasetsResponse
     */
    'datasets': Array<MicrosoftPowerBiDatasetResponse>;
}
/**
 * 
 * @export
 * @interface MicrosoftPowerBiPushDatasetResponse
 */
export interface MicrosoftPowerBiPushDatasetResponse {
    /**
     * Power BI workspace ID
     * @type {string}
     * @memberof MicrosoftPowerBiPushDatasetResponse
     */
    'workspace_pbi_id': string;
    /**
     * Dataset ID
     * @type {string}
     * @memberof MicrosoftPowerBiPushDatasetResponse
     */
    'dataset_id': string;
    /**
     * Table name
     * @type {string}
     * @memberof MicrosoftPowerBiPushDatasetResponse
     */
    'table_name': string;
}
/**
 * 
 * @export
 * @interface MicrosoftPowerBiTableResponse
 */
export interface MicrosoftPowerBiTableResponse {
    /**
     * Table name
     * @type {string}
     * @memberof MicrosoftPowerBiTableResponse
     */
    'table_name': string;
}
/**
 * 
 * @export
 * @interface MicrosoftPowerBiTableValidateResponse
 */
export interface MicrosoftPowerBiTableValidateResponse {
    /**
     * Indicates if the table is valid
     * @type {boolean}
     * @memberof MicrosoftPowerBiTableValidateResponse
     */
    'valid': boolean;
}
/**
 * 
 * @export
 * @interface MicrosoftPowerBiTablesResponse
 */
export interface MicrosoftPowerBiTablesResponse {
    /**
     * 
     * @type {Array<MicrosoftPowerBiTableResponse>}
     * @memberof MicrosoftPowerBiTablesResponse
     */
    'tables': Array<MicrosoftPowerBiTableResponse>;
}
/**
 * 
 * @export
 * @interface MicrosoftPowerBiWorkspaceResponse
 */
export interface MicrosoftPowerBiWorkspaceResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof MicrosoftPowerBiWorkspaceResponse
     */
    'workspace_id': string;
    /**
     * Workspace name
     * @type {string}
     * @memberof MicrosoftPowerBiWorkspaceResponse
     */
    'workspace_name': string;
}
/**
 * 
 * @export
 * @interface MicrosoftPowerBiWorkspacesResponse
 */
export interface MicrosoftPowerBiWorkspacesResponse {
    /**
     * 
     * @type {Array<MicrosoftPowerBiWorkspaceResponse>}
     * @memberof MicrosoftPowerBiWorkspacesResponse
     */
    'workspaces': Array<MicrosoftPowerBiWorkspaceResponse>;
}
/**
 * 
 * @export
 * @interface Mpn
 */
export interface Mpn {
}
/**
 * 
 * @export
 * @interface NodeDetailRequest
 */
export interface NodeDetailRequest {
    /**
     * 
     * @type {string}
     * @memberof NodeDetailRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NodeDetailRequest
     */
    'parent_node_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NodeDetailRequest
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NodeDetailRequest
     */
    'body'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof NodeDetailRequest
     */
    'position'?: number | null;
    /**
     * 
     * @type {Array<Source>}
     * @memberof NodeDetailRequest
     */
    'sources'?: Array<Source> | null;
}
/**
 * 
 * @export
 * @interface NodeUpdateRequest
 */
export interface NodeUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof NodeUpdateRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NodeUpdateRequest
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NodeUpdateRequest
     */
    'body'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NodeUpdateRequest
     */
    'appended_offload_id'?: string | null;
}
/**
 * 
 * @export
 * @interface ObservabilityDriverResponse
 */
export interface ObservabilityDriverResponse {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverResponse
     */
    'driver_type': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ObservabilityDriverResponse
     */
    'additional_data'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface OptimizedPromptResponse
 */
export interface OptimizedPromptResponse {
    /**
     * Prompt text
     * @type {string}
     * @memberof OptimizedPromptResponse
     */
    'prompt_text': string;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {string}
     * @memberof Pagination
     */
    'sorting_key_value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Pagination
     */
    'scroll_id'?: string | null;
}
/**
 * 
 * @export
 * @interface PerDayFeedback
 */
export interface PerDayFeedback {
    /**
     * Date in YYYY-MM-DD format
     * @type {string}
     * @memberof PerDayFeedback
     */
    'date': string;
    /**
     * Count of positive feedback
     * @type {number}
     * @memberof PerDayFeedback
     */
    'positive'?: number;
    /**
     * Count of negative feedback
     * @type {number}
     * @memberof PerDayFeedback
     */
    'negative'?: number;
    /**
     * Count of unique sessions (visitor count)
     * @type {number}
     * @memberof PerDayFeedback
     */
    'session_count'?: number;
    /**
     * Count of human messages
     * @type {number}
     * @memberof PerDayFeedback
     */
    'human_message_count'?: number;
    /**
     * Count of tool calls
     * @type {number}
     * @memberof PerDayFeedback
     */
    'tool_calling_count'?: number;
}
/**
 * 
 * @export
 * @interface PerDaySessionDurationResponse
 */
export interface PerDaySessionDurationResponse {
    /**
     * Date in YYYY-MM-DD format
     * @type {string}
     * @memberof PerDaySessionDurationResponse
     */
    'date': string;
    /**
     * Average session duration in seconds
     * @type {number}
     * @memberof PerDaySessionDurationResponse
     */
    'average_duration'?: number;
    /**
     * Count of unique sessions (visitor count)
     * @type {number}
     * @memberof PerDaySessionDurationResponse
     */
    'session_count'?: number;
}
/**
 * 
 * @export
 * @interface PhotoAIEffectResponse
 */
export interface PhotoAIEffectResponse {
    /**
     * 
     * @type {string}
     * @memberof PhotoAIEffectResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIEffectResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIEffectResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIEffectResponse
     */
    'cover_image': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIEffectResponse
     */
    'prompt': string;
    /**
     * 
     * @type {boolean}
     * @memberof PhotoAIEffectResponse
     */
    'featured'?: boolean;
}
/**
 * 
 * @export
 * @interface PhotoAIStyleResponse
 */
export interface PhotoAIStyleResponse {
    /**
     * 
     * @type {string}
     * @memberof PhotoAIStyleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIStyleResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIStyleResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIStyleResponse
     */
    'cover_image': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIStyleResponse
     */
    'prompt': string;
    /**
     * 
     * @type {boolean}
     * @memberof PhotoAIStyleResponse
     */
    'featured'?: boolean;
}
/**
 * 
 * @export
 * @interface PhotoAITemplateResponse
 */
export interface PhotoAITemplateResponse {
    /**
     * 
     * @type {string}
     * @memberof PhotoAITemplateResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAITemplateResponse
     */
    'cover_image': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAITemplateResponse
     */
    'prompt': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAITemplateResponse
     */
    'model': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PhotoAITemplateResponse
     */
    'styles': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PhotoAITemplateResponse
     */
    'effects': Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PointerType = {
    C: 'C',
    J: 'J',
    I: 'I',
    O: 'O',
    A: 'A',
    U: 'U'
} as const;

export type PointerType = typeof PointerType[keyof typeof PointerType];


/**
 * 
 * @export
 * @interface PowerBiDatasetRequest
 */
export interface PowerBiDatasetRequest {
    /**
     * 
     * @type {string}
     * @memberof PowerBiDatasetRequest
     */
    'workspace_pbi_id'?: string | null;
}
/**
 * 
 * @export
 * @interface PowerBiPushDatasetRequest
 */
export interface PowerBiPushDatasetRequest {
    /**
     * 
     * @type {string}
     * @memberof PowerBiPushDatasetRequest
     */
    'workspace_pbi_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PowerBiPushDatasetRequest
     */
    'dataset_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PowerBiPushDatasetRequest
     */
    'table_name'?: string | null;
}
/**
 * 
 * @export
 * @interface PowerBiRequest
 */
export interface PowerBiRequest {
    /**
     * 
     * @type {string}
     * @memberof PowerBiRequest
     */
    'workspace_pbi_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PowerBiRequest
     */
    'dataset_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PowerBiRequest
     */
    'table_name'?: string | null;
}
/**
 * 
 * @export
 * @interface PowerBiTableRequest
 */
export interface PowerBiTableRequest {
    /**
     * 
     * @type {string}
     * @memberof PowerBiTableRequest
     */
    'workspace_pbi_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PowerBiTableRequest
     */
    'dataset_id'?: string | null;
}
/**
 * 
 * @export
 * @interface Price
 */
export interface Price {
}
/**
 * 
 * @export
 * @interface ProductType
 */
export interface ProductType {
}
/**
 * 
 * @export
 * @interface PromptCategoryCreateRequest
 */
export interface PromptCategoryCreateRequest {
    /**
     * Category name
     * @type {string}
     * @memberof PromptCategoryCreateRequest
     */
    'cat_name': string;
    /**
     * Category color
     * @type {string}
     * @memberof PromptCategoryCreateRequest
     */
    'color': string;
    /**
     * 
     * @type {string}
     * @memberof PromptCategoryCreateRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface PromptCategoryResponse
 */
export interface PromptCategoryResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof PromptCategoryResponse
     */
    'workspace_id': string;
    /**
     * Category ID
     * @type {string}
     * @memberof PromptCategoryResponse
     */
    'cat_id': string;
    /**
     * Category name
     * @type {string}
     * @memberof PromptCategoryResponse
     */
    'cat_name': string;
    /**
     * Category color
     * @type {string}
     * @memberof PromptCategoryResponse
     */
    'color': string;
    /**
     * 
     * @type {string}
     * @memberof PromptCategoryResponse
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface PromptCategorySearchRequest
 */
export interface PromptCategorySearchRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptCategorySearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptCategorySearchRequest
     */
    'cat_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptCategorySearchRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PromptCategorySearchRequest
     */
    'limit'?: number | null;
}
/**
 * 
 * @export
 * @interface PromptCategoryUpdateRequest
 */
export interface PromptCategoryUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptCategoryUpdateRequest
     */
    'cat_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptCategoryUpdateRequest
     */
    'color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptCategoryUpdateRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface PromptCreateRequest
 */
export interface PromptCreateRequest {
    /**
     * Category ID
     * @type {string}
     * @memberof PromptCreateRequest
     */
    'cat_id': string;
    /**
     * Document name
     * @type {string}
     * @memberof PromptCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PromptCreateRequest
     */
    'description'?: string | null;
    /**
     * Prompt text
     * @type {string}
     * @memberof PromptCreateRequest
     */
    'prompt_text': string;
    /**
     * 
     * @type {AppUrlInput}
     * @memberof PromptCreateRequest
     */
    'prompt_url'?: AppUrlInput | null;
}
/**
 * 
 * @export
 * @interface PromptOptimizerRequest
 */
export interface PromptOptimizerRequest {
    /**
     * The prompt text to be optimized
     * @type {string}
     * @memberof PromptOptimizerRequest
     */
    'prompt_text': string;
    /**
     * 
     * @type {string}
     * @memberof PromptOptimizerRequest
     */
    'user_instructions'?: string | null;
}
/**
 * 
 * @export
 * @interface PromptResponse
 */
export interface PromptResponse {
    /**
     * Prompt ID
     * @type {string}
     * @memberof PromptResponse
     */
    'prompt_id': string;
    /**
     * Category ID
     * @type {string}
     * @memberof PromptResponse
     */
    'cat_id': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof PromptResponse
     */
    'workspace_id': string;
    /**
     * Prompt name
     * @type {string}
     * @memberof PromptResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PromptResponse
     */
    'description'?: string | null;
    /**
     * Prompt text
     * @type {string}
     * @memberof PromptResponse
     */
    'prompt_text': string;
    /**
     * 
     * @type {string}
     * @memberof PromptResponse
     */
    'prompt_url'?: string | null;
}
/**
 * 
 * @export
 * @interface PromptSearchRequest
 */
export interface PromptSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptSearchRequest
     */
    'prompt_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptSearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptSearchRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptSearchRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptSearchRequest
     */
    'prompt_text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptSearchRequest
     */
    'prompt_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PromptSearchRequest
     */
    'limit'?: number | null;
}
/**
 * 
 * @export
 * @interface PromptUpdateRequest
 */
export interface PromptUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptUpdateRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptUpdateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptUpdateRequest
     */
    'prompt_text'?: string | null;
    /**
     * 
     * @type {AppUrlInput}
     * @memberof PromptUpdateRequest
     */
    'prompt_url'?: AppUrlInput | null;
    /**
     * 
     * @type {string}
     * @memberof PromptUpdateRequest
     */
    'cat_id'?: string | null;
}
/**
 * 
 * @export
 * @interface QuerySimilarityRequest
 */
export interface QuerySimilarityRequest {
    /**
     * 
     * @type {VectorDocumentType}
     * @memberof QuerySimilarityRequest
     */
    'document_type'?: VectorDocumentType | null;
    /**
     * 
     * @type {PointerType}
     * @memberof QuerySimilarityRequest
     */
    'pointer_type'?: PointerType | null;
    /**
     * 
     * @type {string}
     * @memberof QuerySimilarityRequest
     */
    'schema_type'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityRequest
     */
    'score_trheshold'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof QuerySimilarityRequest
     */
    'with_vectors'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityRequest
     */
    'pointer_position_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityRequest
     */
    'pointer_position_to'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityRequest
     */
    'vector_id_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityRequest
     */
    'vector_id_to'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof QuerySimilarityRequest
     */
    'filter_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuerySimilarityRequest
     */
    'filter_domains'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof QuerySimilarityRequest
     */
    'query'?: string;
}


/**
 * 
 * @export
 * @interface QuerySimilarityTaskRequest
 */
export interface QuerySimilarityTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof QuerySimilarityTaskRequest
     */
    'post_back_url'?: string | null;
    /**
     * 
     * @type {VectorDocumentType}
     * @memberof QuerySimilarityTaskRequest
     */
    'document_type'?: VectorDocumentType | null;
    /**
     * 
     * @type {PointerType}
     * @memberof QuerySimilarityTaskRequest
     */
    'pointer_type'?: PointerType | null;
    /**
     * 
     * @type {string}
     * @memberof QuerySimilarityTaskRequest
     */
    'schema_type'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityTaskRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityTaskRequest
     */
    'score_trheshold'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof QuerySimilarityTaskRequest
     */
    'with_vectors'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityTaskRequest
     */
    'pointer_position_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityTaskRequest
     */
    'pointer_position_to'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityTaskRequest
     */
    'vector_id_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityTaskRequest
     */
    'vector_id_to'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof QuerySimilarityTaskRequest
     */
    'filter_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuerySimilarityTaskRequest
     */
    'filter_domains'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof QuerySimilarityTaskRequest
     */
    'query'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const Role = {
    O: 'O',
    A: 'A',
    E: 'E',
    M: 'M',
    G: 'G'
} as const;

export type Role = typeof Role[keyof typeof Role];


/**
 * 
 * @export
 * @interface ScheduleCreateRequest
 */
export interface ScheduleCreateRequest {
    /**
     * 
     * @type {AppUrlInput}
     * @memberof ScheduleCreateRequest
     */
    'url': AppUrlInput;
    /**
     * 
     * @type {ScheduleFrequency}
     * @memberof ScheduleCreateRequest
     */
    'frequency': ScheduleFrequency;
    /**
     * 
     * @type {ScheduleType}
     * @memberof ScheduleCreateRequest
     */
    'schedule_type': ScheduleType;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleCreateRequest
     */
    'with_screenshot'?: BoolChar | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleCreateRequest
     */
    'with_browser'?: BoolChar | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleCreateRequest
     */
    'follow_links'?: BoolChar | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'with_proxy_rotation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'disallow_urls'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'filter_urls'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'custom_headers'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'urls_extra_config'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ScheduleFrequency = {
    D: 'D',
    W: 'W',
    M: 'M',
    Y: 'Y'
} as const;

export type ScheduleFrequency = typeof ScheduleFrequency[keyof typeof ScheduleFrequency];


/**
 * 
 * @export
 * @interface ScheduleResponse
 */
export interface ScheduleResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof ScheduleResponse
     */
    'workspace_id': string;
    /**
     * Schedule ID
     * @type {string}
     * @memberof ScheduleResponse
     */
    'schedule_id': string;
    /**
     * URL to be scheduled
     * @type {string}
     * @memberof ScheduleResponse
     */
    'url': string;
    /**
     * Frequency of the schedule D - Daily, W - Weekly, M - Monthly, Y - Yearly
     * @type {ScheduleFrequency}
     * @memberof ScheduleResponse
     */
    'frequency': ScheduleFrequency;
    /**
     * Type of the schedule (U - URL, D - Domain, S - Sitemap)
     * @type {ScheduleType}
     * @memberof ScheduleResponse
     */
    'schedule_type': ScheduleType;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'start_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'end_time'?: string | null;
    /**
     * Status of the schedule (N - New, F - Finished, P - Pending, E - Error, C - Cancelled
     * @type {ScheduleStatus}
     * @memberof ScheduleResponse
     */
    'status': ScheduleStatus;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'status_message'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ScheduleResponse
     */
    'cnt_scheduled': number | null;
    /**
     * 
     * @type {number}
     * @memberof ScheduleResponse
     */
    'cnt_completed': number | null;
    /**
     * 
     * @type {number}
     * @memberof ScheduleResponse
     */
    'cnt_failed': number | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleResponse
     */
    'with_screenshot': BoolChar | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleResponse
     */
    'with_browser': BoolChar | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleResponse
     */
    'follow_links': BoolChar | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'with_proxy_rotation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'disallow_urls'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'filter_urls'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'custom_headers'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'urls_extra_config'?: string | null;
}


/**
 * 
 * @export
 * @interface ScheduleSearchRequest
 */
export interface ScheduleSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof ScheduleSearchRequest
     */
    'domain_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleSearchRequest
     */
    'url'?: string | null;
    /**
     * 
     * @type {ScheduleStatus}
     * @memberof ScheduleSearchRequest
     */
    'status'?: ScheduleStatus | null;
    /**
     * 
     * @type {ScheduleType}
     * @memberof ScheduleSearchRequest
     */
    'schedule_type'?: ScheduleType | null;
    /**
     * Limit of the search
     * @type {number}
     * @memberof ScheduleSearchRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {Pagination}
     * @memberof ScheduleSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ScheduleStatus = {
    N: 'N',
    F: 'F',
    P: 'P',
    E: 'E',
    C: 'C'
} as const;

export type ScheduleStatus = typeof ScheduleStatus[keyof typeof ScheduleStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const ScheduleType = {
    U: 'U',
    D: 'D',
    S: 'S',
    Y: 'Y',
    L: 'L',
    X: 'X'
} as const;

export type ScheduleType = typeof ScheduleType[keyof typeof ScheduleType];


/**
 * 
 * @export
 * @interface ScheduleUpdateRequest
 */
export interface ScheduleUpdateRequest {
    /**
     * 
     * @type {ScheduleFrequency}
     * @memberof ScheduleUpdateRequest
     */
    'frequency'?: ScheduleFrequency | null;
    /**
     * 
     * @type {ScheduleStatus}
     * @memberof ScheduleUpdateRequest
     */
    'status'?: ScheduleStatus | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleUpdateRequest
     */
    'with_screenshot'?: BoolChar | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleUpdateRequest
     */
    'with_browser'?: BoolChar | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleUpdateRequest
     */
    'follow_links'?: BoolChar | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'with_proxy_rotation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'disallow_urls'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'filter_urls'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'custom_headers'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'urls_extra_config'?: string | null;
}


/**
 * 
 * @export
 * @interface ScheduleUrlDeleteRequest
 */
export interface ScheduleUrlDeleteRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ScheduleUrlDeleteRequest
     */
    'url_blocking_enabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ScheduleUrlDetailResponse
 */
export interface ScheduleUrlDetailResponse {
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'schedule_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'domain_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'url_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'last_text_timestamp': string | null;
    /**
     * 
     * @type {UrlScreenshotResponse}
     * @memberof ScheduleUrlDetailResponse
     */
    'page_screenshot': UrlScreenshotResponse | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'url_title': string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'url_meta_description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'url_og_image': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ScheduleUrlDetailResponse
     */
    'is_original_url': boolean;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'dest_url_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'created_at': string;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof ScheduleUrlDetailResponse
     */
    'url_text': Array<{ [key: string]: string; }> | null;
}
/**
 * 
 * @export
 * @interface ScheduleUrlResponse
 */
export interface ScheduleUrlResponse {
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'schedule_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'domain_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'url_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'last_text_timestamp': string | null;
    /**
     * 
     * @type {UrlScreenshotResponse}
     * @memberof ScheduleUrlResponse
     */
    'page_screenshot': UrlScreenshotResponse | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'url_title': string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'url_meta_description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'url_og_image': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ScheduleUrlResponse
     */
    'is_original_url': boolean;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'dest_url_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface ScheduleUrlSearchRequest
 */
export interface ScheduleUrlSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'schedule_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'domain_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'url_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'text_timestamp_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'text_timestamp_to'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'url_title'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ScheduleUrlSearchRequest
     */
    'is_original_url'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'created_at_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'created_at_to'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ScheduleUrlSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Pagination}
     * @memberof ScheduleUrlSearchRequest
     */
    'pagination'?: Pagination | null;
}
/**
 * 
 * @export
 * @interface ScreenshotRequest
 */
export interface ScreenshotRequest {
    /**
     * 
     * @type {string}
     * @memberof ScreenshotRequest
     */
    'post_back_url'?: string | null;
    /**
     * URL to take screenshot
     * @type {string}
     * @memberof ScreenshotRequest
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ScreenshotRequest
     */
    'validity'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenshotRequest
     */
    'use_proxy'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ScreenshotResponse
 */
export interface ScreenshotResponse {
    /**
     * Task ID
     * @type {string}
     * @memberof ScreenshotResponse
     */
    'id': string;
    /**
     * Task status
     * @type {TaskStatus}
     * @memberof ScreenshotResponse
     */
    'status': TaskStatus;
    /**
     * 
     * @type {string}
     * @memberof ScreenshotResponse
     */
    'result'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScreenshotResponse
     */
    'error_message'?: string | null;
    /**
     * 
     * @type {AppUrlOutput}
     * @memberof ScreenshotResponse
     */
    'original_size_url'?: AppUrlOutput | null;
    /**
     * 
     * @type {AppUrlOutput}
     * @memberof ScreenshotResponse
     */
    'thumbnail_url'?: AppUrlOutput | null;
    /**
     * 
     * @type {AppUrlOutput}
     * @memberof ScreenshotResponse
     */
    'original_size_url_full_page'?: AppUrlOutput | null;
    /**
     * 
     * @type {AppUrlOutput}
     * @memberof ScreenshotResponse
     */
    'thumbnail_url_full_page'?: AppUrlOutput | null;
    /**
     * 
     * @type {number}
     * @memberof ScreenshotResponse
     */
    'timestamp'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ScreenshotResponse
     */
    'domain_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScreenshotResponse
     */
    'url_id'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SearchType = {
    Text: 'text',
    Vector: 'vector',
    Hybrid: 'hybrid'
} as const;

export type SearchType = typeof SearchType[keyof typeof SearchType];


/**
 * 
 * @export
 * @interface SerpClusterAddQueryRequest
 */
export interface SerpClusterAddQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof SerpClusterAddQueryRequest
     */
    'post_back_url'?: string | null;
    /**
     * List of queries
     * @type {Array<SerpKeyword>}
     * @memberof SerpClusterAddQueryRequest
     */
    'queries': Array<SerpKeyword>;
    /**
     * Customer ID of cluster
     * @type {string}
     * @memberof SerpClusterAddQueryRequest
     */
    'customer_id'?: string;
    /**
     * Campaign ID of cluster
     * @type {string}
     * @memberof SerpClusterAddQueryRequest
     */
    'campaign_id'?: string;
    /**
     * Group ID of cluster - will be generated if not provided
     * @type {string}
     * @memberof SerpClusterAddQueryRequest
     */
    'group_id'?: string;
    /**
     * Group name of cluster
     * @type {string}
     * @memberof SerpClusterAddQueryRequest
     */
    'group_name'?: string;
}
/**
 * 
 * @export
 * @interface SerpClusterAddQueryRequests
 */
export interface SerpClusterAddQueryRequests {
    /**
     * List of serp requests
     * @type {Array<SerpClusterAddQueryRequest>}
     * @memberof SerpClusterAddQueryRequests
     */
    'requests': Array<SerpClusterAddQueryRequest>;
}
/**
 * 
 * @export
 * @interface SerpClusterBestGroupsRequest
 */
export interface SerpClusterBestGroupsRequest {
    /**
     * 
     * @type {string}
     * @memberof SerpClusterBestGroupsRequest
     */
    'keyword_id'?: string | null;
    /**
     * Keyword to search
     * @type {string}
     * @memberof SerpClusterBestGroupsRequest
     */
    'keyword': string;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterBestGroupsRequest
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterBestGroupsRequest
     */
    'country'?: string | null;
    /**
     * 
     * @type {SerpSearchEngineType}
     * @memberof SerpClusterBestGroupsRequest
     */
    'search_engine'?: SerpSearchEngineType | null;
    /**
     * Customer ID of cluster
     * @type {string}
     * @memberof SerpClusterBestGroupsRequest
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterBestGroupsRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SerpClusterBestGroupsRequest
     */
    'min_cluster_strength'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SerpClusterBestGroupsRequest
     */
    'min_queries_count'?: number | null;
}


/**
 * 
 * @export
 * @interface SerpClusterGroupIntersectionsRequest
 */
export interface SerpClusterGroupIntersectionsRequest {
    /**
     * Customer ID of cluster
     * @type {string}
     * @memberof SerpClusterGroupIntersectionsRequest
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupIntersectionsRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupIntersectionsRequest
     */
    'group_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SerpClusterGroupIntersectionsRequest
     */
    'min_cluster_strength'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupIntersectionsRequest
     */
    'suggest_other_matching_keywords'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupIntersectionsRequest
     */
    'include_negative_keywords'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupIntersectionsRequest
     */
    'include_all_members'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SerpClusterGroupSearchRequest
 */
export interface SerpClusterGroupSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupSearchRequest
     */
    'search'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupSearchRequest
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupSearchRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupSearchRequest
     */
    'group_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupSearchRequest
     */
    'include_negative_keywords'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SerpClusterGroupSubClustersRequest
 */
export interface SerpClusterGroupSubClustersRequest {
    /**
     * Customer ID of cluster
     * @type {string}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'group_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'min_cluster_strength'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'suggest_other_matching_keywords'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'include_negative_keywords'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'include_all_members'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'include_group_keywords'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SerpClusterKeywordIntersectionsRequest
 */
export interface SerpClusterKeywordIntersectionsRequest {
    /**
     * 
     * @type {string}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'keyword_id'?: string | null;
    /**
     * Keyword to search
     * @type {string}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'keyword': string;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'country'?: string | null;
    /**
     * 
     * @type {SerpSearchEngineType}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'search_engine'?: SerpSearchEngineType | null;
    /**
     * Customer ID of cluster
     * @type {string}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'group_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'min_cluster_strength'?: number | null;
}


/**
 * 
 * @export
 * @interface SerpClusterKeywordResponse
 */
export interface SerpClusterKeywordResponse {
    /**
     * Unique ID
     * @type {string}
     * @memberof SerpClusterKeywordResponse
     */
    'unique_id': string;
    /**
     * Query ID
     * @type {string}
     * @memberof SerpClusterKeywordResponse
     */
    'keyword_id': string;
    /**
     * Query
     * @type {string}
     * @memberof SerpClusterKeywordResponse
     */
    'keyword': string;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterKeywordResponse
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterKeywordResponse
     */
    'language'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterKeywordResponse
     */
    'is_negative'?: boolean | null;
    /**
     * 
     * @type {GoogleAdsMatchType}
     * @memberof SerpClusterKeywordResponse
     */
    'match_type': GoogleAdsMatchType | null;
    /**
     * Campaign ID
     * @type {string}
     * @memberof SerpClusterKeywordResponse
     */
    'campaign_id': string;
    /**
     * Group ID
     * @type {string}
     * @memberof SerpClusterKeywordResponse
     */
    'group_id': string;
    /**
     * 
     * @type {SerpSearchEngineType}
     * @memberof SerpClusterKeywordResponse
     */
    'search_engine': SerpSearchEngineType | null;
}


/**
 * 
 * @export
 * @interface SerpGroupIntersection
 */
export interface SerpGroupIntersection {
    /**
     * 
     * @type {string}
     * @memberof SerpGroupIntersection
     */
    'workspace_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpGroupIntersection
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpGroupIntersection
     */
    'campaign_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpGroupIntersection
     */
    'group_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpGroupIntersection
     */
    'unique_group_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SerpGroupIntersection
     */
    'intersections_count': number;
}
/**
 * 
 * @export
 * @interface SerpKeyword
 */
export interface SerpKeyword {
    /**
     * 
     * @type {string}
     * @memberof SerpKeyword
     */
    'keyword_id'?: string | null;
    /**
     * Keyword to search
     * @type {string}
     * @memberof SerpKeyword
     */
    'keyword': string;
    /**
     * 
     * @type {string}
     * @memberof SerpKeyword
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpKeyword
     */
    'country'?: string | null;
    /**
     * 
     * @type {SerpSearchEngineType}
     * @memberof SerpKeyword
     */
    'search_engine'?: SerpSearchEngineType | null;
}


/**
 * 
 * @export
 * @interface SerpKeywordRelation
 */
export interface SerpKeywordRelation {
    /**
     * The keyword id
     * @type {string}
     * @memberof SerpKeywordRelation
     */
    'keyword_id_1': string;
    /**
     * The keyword
     * @type {string}
     * @memberof SerpKeywordRelation
     */
    'keyword_1': string;
    /**
     * The related keyword id
     * @type {string}
     * @memberof SerpKeywordRelation
     */
    'keyword_id_2': string;
    /**
     * The related keyword
     * @type {string}
     * @memberof SerpKeywordRelation
     */
    'keyword_2': string;
    /**
     * The count of cluster strength
     * @type {number}
     * @memberof SerpKeywordRelation
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface SerpQueryRequest
 */
export interface SerpQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof SerpQueryRequest
     */
    'post_back_url'?: string | null;
    /**
     * List of queries
     * @type {Array<SerpKeyword>}
     * @memberof SerpQueryRequest
     */
    'queries': Array<SerpKeyword>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SerpSearchEngineType = {
    G: 'G',
    D: 'D'
} as const;

export type SerpSearchEngineType = typeof SerpSearchEngineType[keyof typeof SerpSearchEngineType];


/**
 * 
 * @export
 * @interface SerpSearchRequest
 */
export interface SerpSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SerpSearchRequest
     */
    'post_back_url'?: string | null;
    /**
     * Query to search
     * @type {string}
     * @memberof SerpSearchRequest
     */
    'query': string;
    /**
     * 
     * @type {string}
     * @memberof SerpSearchRequest
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpSearchRequest
     */
    'location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpSearchRequest
     */
    'language'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SerpSearchRequest
     */
    'count_urls'?: number | null;
}
/**
 * 
 * @export
 * @interface SerpSearchRequests
 */
export interface SerpSearchRequests {
    /**
     * List of serp requests
     * @type {Array<SerpSearchRequest>}
     * @memberof SerpSearchRequests
     */
    'requests': Array<SerpSearchRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof SerpSearchRequests
     */
    'live_mode'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SerpSubclusterKeywordsResponse
 */
export interface SerpSubclusterKeywordsResponse {
    /**
     * List of keywords not assigned yet
     * @type {Array<string>}
     * @memberof SerpSubclusterKeywordsResponse
     */
    'missing_keywords': Array<string>;
    /**
     * List of keywords already assigned
     * @type {Array<string>}
     * @memberof SerpSubclusterKeywordsResponse
     */
    'keywords': Array<string>;
    /**
     * Count of keywords in subcluster
     * @type {number}
     * @memberof SerpSubclusterKeywordsResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface SerpVolumeRequest
 */
export interface SerpVolumeRequest {
    /**
     * 
     * @type {string}
     * @memberof SerpVolumeRequest
     */
    'post_back_url'?: string | null;
    /**
     * List of queries
     * @type {Array<string>}
     * @memberof SerpVolumeRequest
     */
    'keywords': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SerpVolumeRequest
     */
    'language_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpVolumeRequest
     */
    'location_name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpVolumeRequest
     */
    'include_adult_keywords'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof SerpVolumeRequest
     */
    'date_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpVolumeRequest
     */
    'date_to'?: string | null;
}
/**
 * 
 * @export
 * @interface Shipping
 */
export interface Shipping {
}
/**
 * 
 * @export
 * @interface ShopRedactPayload
 */
export interface ShopRedactPayload {
    /**
     * 
     * @type {number}
     * @memberof ShopRedactPayload
     */
    'shop_id': number;
    /**
     * 
     * @type {string}
     * @memberof ShopRedactPayload
     */
    'shop_domain': string;
}
/**
 * 
 * @export
 * @interface ShopifyIntegrationResponse
 */
export interface ShopifyIntegrationResponse {
    /**
     * 
     * @type {string}
     * @memberof ShopifyIntegrationResponse
     */
    'shop_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopifyIntegrationResponse
     */
    'shopify_client_id'?: string | null;
}
/**
 * 
 * @export
 * @interface Size
 */
export interface Size {
}
/**
 * 
 * @export
 * @interface SlackChannelResponse
 */
export interface SlackChannelResponse {
    /**
     * 
     * @type {string}
     * @memberof SlackChannelResponse
     */
    'channel_id': string;
    /**
     * 
     * @type {string}
     * @memberof SlackChannelResponse
     */
    'channel_name': string;
}
/**
 * 
 * @export
 * @interface SlackWorkspaceResponse
 */
export interface SlackWorkspaceResponse {
    /**
     * 
     * @type {string}
     * @memberof SlackWorkspaceResponse
     */
    'team_id': string;
    /**
     * 
     * @type {string}
     * @memberof SlackWorkspaceResponse
     */
    'workspace_name': string;
    /**
     * 
     * @type {string}
     * @memberof SlackWorkspaceResponse
     */
    'integration_id': string;
}
/**
 * Enum for sort direction options.
 * @export
 * @enum {string}
 */

export const SortDirection = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortDirection = typeof SortDirection[keyof typeof SortDirection];


/**
 * Model for memory source information.
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'source_id': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'source_type': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'source_url'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Source
     */
    'metadata'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SubscriptionPlan = {
    S: 'S',
    P: 'P',
    A: 'A',
    T: 'T',
    C: 'C',
    E: 'E'
} as const;

export type SubscriptionPlan = typeof SubscriptionPlan[keyof typeof SubscriptionPlan];


/**
 * 
 * @export
 * @interface SystemMessageMetadata
 */
export interface SystemMessageMetadata {
    /**
     * Message ID
     * @type {string}
     * @memberof SystemMessageMetadata
     */
    'message_id': string;
    /**
     * Message
     * @type {string}
     * @memberof SystemMessageMetadata
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface TagCreateRequest
 */
export interface TagCreateRequest {
    /**
     * Tag name
     * @type {string}
     * @memberof TagCreateRequest
     */
    'tag_name': string;
    /**
     * Tag color
     * @type {string}
     * @memberof TagCreateRequest
     */
    'tag_color': string;
}
/**
 * 
 * @export
 * @interface TagResponse
 */
export interface TagResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof TagResponse
     */
    'workspace_id': string;
    /**
     * Tag ID
     * @type {string}
     * @memberof TagResponse
     */
    'tag_id': string;
    /**
     * Tag name
     * @type {string}
     * @memberof TagResponse
     */
    'tag_name': string;
    /**
     * Tag color
     * @type {string}
     * @memberof TagResponse
     */
    'tag_color': string;
}
/**
 * 
 * @export
 * @interface TagSearchRequest
 */
export interface TagSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof TagSearchRequest
     */
    'tag_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TagSearchRequest
     */
    'tag_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TagSearchRequest
     */
    'limit'?: number | null;
}
/**
 * 
 * @export
 * @interface TagUpdateRequest
 */
export interface TagUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof TagUpdateRequest
     */
    'tag_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TagUpdateRequest
     */
    'tag_color'?: string | null;
}
/**
 * 
 * @export
 * @interface TaskResponse
 */
export interface TaskResponse {
    /**
     * Task ID
     * @type {string}
     * @memberof TaskResponse
     */
    'id': string;
    /**
     * Task status
     * @type {TaskStatus}
     * @memberof TaskResponse
     */
    'status': TaskStatus;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    'result'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    'error_message'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TaskStatus = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Retry: 'RETRY',
    Revoked: 'REVOKED',
    Received: 'RECEIVED',
    Started: 'STARTED',
    Ignored: 'IGNORED',
    Rejected: 'REJECTED'
} as const;

export type TaskStatus = typeof TaskStatus[keyof typeof TaskStatus];


/**
 * 
 * @export
 * @interface Title
 */
export interface Title {
}
/**
 * Single todo item in agent\'s todo list.
 * @export
 * @interface TodoItem
 */
export interface TodoItem {
    /**
     * Todo item content/description
     * @type {string}
     * @memberof TodoItem
     */
    'content': string;
    /**
     * Todo status: pending, in_progress, or completed
     * @type {string}
     * @memberof TodoItem
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ToolCallFeedbackResponse
 */
export interface ToolCallFeedbackResponse {
    /**
     * Date in YYYY-MM-DD format
     * @type {string}
     * @memberof ToolCallFeedbackResponse
     */
    'date': string;
    /**
     * Tool call count
     * @type {number}
     * @memberof ToolCallFeedbackResponse
     */
    'tool_calling_count'?: number;
    /**
     * 
     * @type {Array<ToolFeedback>}
     * @memberof ToolCallFeedbackResponse
     */
    'tools'?: Array<ToolFeedback> | null;
}
/**
 * 
 * @export
 * @interface ToolFeedback
 */
export interface ToolFeedback {
    /**
     * Tool name
     * @type {string}
     * @memberof ToolFeedback
     */
    'tool_name': string;
    /**
     * Tool call count
     * @type {number}
     * @memberof ToolFeedback
     */
    'tool_call_count': number;
}
/**
 * 
 * @export
 * @interface TotalFeedback
 */
export interface TotalFeedback {
    /**
     * Total count of positive feedback
     * @type {number}
     * @memberof TotalFeedback
     */
    'positive'?: number;
    /**
     * Total count of negative feedback
     * @type {number}
     * @memberof TotalFeedback
     */
    'negative'?: number;
    /**
     * Total count of unique sessions (visitor count)
     * @type {number}
     * @memberof TotalFeedback
     */
    'session_count'?: number;
    /**
     * Average human messages per session
     * @type {number}
     * @memberof TotalFeedback
     */
    'human_message_count'?: number;
    /**
     * Average tool calls per session
     * @type {number}
     * @memberof TotalFeedback
     */
    'tool_calling_count'?: number;
}
/**
 * Enum for tracking click ID names
 * @export
 * @enum {string}
 */

export const TrackingClickIdNames = {
    Gclid: 'gclid',
    Gbraid: 'gbraid',
    Wbraid: 'wbraid',
    Dclid: 'dclid',
    Fbclid: 'fbclid',
    Msclkid: 'msclkid',
    Other: 'other'
} as const;

export type TrackingClickIdNames = typeof TrackingClickIdNames[keyof typeof TrackingClickIdNames];


/**
 * 
 * @export
 * @interface TrackingEventCreateRequest
 */
export interface TrackingEventCreateRequest {
    /**
     * The name of the event
     * @type {string}
     * @memberof TrackingEventCreateRequest
     */
    'event_name': string;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequest
     */
    'unique_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingEventCreateRequest
     */
    'event_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequest
     */
    'currency'?: string | null;
    /**
     * 
     * @type {Array<TrackingEventData>}
     * @memberof TrackingEventCreateRequest
     */
    'event_data'?: Array<TrackingEventData> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingEventCreateRequest
     */
    'link_ids'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequest
     */
    'valid_until'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequest
     */
    'conversion_action_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingEventCreateRequest
     */
    'include_in_conversions_metric'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequest
     */
    'url'?: string | null;
}
/**
 * 
 * @export
 * @interface TrackingEventCreateRequests
 */
export interface TrackingEventCreateRequests {
    /**
     * The list of events to be created
     * @type {Array<TrackingEventCreateRequest>}
     * @memberof TrackingEventCreateRequests
     */
    'events': Array<TrackingEventCreateRequest>;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequests
     */
    'unique_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequests
     */
    'fp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequests
     */
    'session_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingEventCreateRequests
     */
    'with_address'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequests
     */
    'ga'?: string | null;
}
/**
 * Value object for tracking event data
 * @export
 * @interface TrackingEventData
 */
export interface TrackingEventData {
    /**
     * 
     * @type {string}
     * @memberof TrackingEventData
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventData
     */
    'value_text'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingEventData
     */
    'value_number'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingEventData
     */
    'value_boolean'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventData
     */
    'value_datetime'?: string | null;
}
/**
 * 
 * @export
 * @interface TrackingEventResponse
 */
export interface TrackingEventResponse {
    /**
     * 
     * @type {string}
     * @memberof TrackingEventResponse
     */
    'event_id': string;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventResponse
     */
    'unique_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventResponse
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventResponse
     */
    'event_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingEventResponse
     */
    'event_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventResponse
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventResponse
     */
    'valid_until'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingEventResponse
     */
    'include_in_conversions_metric'?: boolean | null;
    /**
     * 
     * @type {Array<TrackingEventData>}
     * @memberof TrackingEventResponse
     */
    'event_data'?: Array<TrackingEventData> | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof TrackingEventResponse
     */
    'link_ids'?: Array<any> | null;
}
/**
 * 
 * @export
 * @interface TrackingEventSearchRequest
 */
export interface TrackingEventSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingEventSearchRequest
     */
    'event_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventSearchRequest
     */
    'from_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventSearchRequest
     */
    'to_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingEventSearchRequest
     */
    'include_expired'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingEventSearchRequest
     */
    'page'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingEventSearchRequest
     */
    'page_size'?: number | null;
}
/**
 * 
 * @export
 * @interface TrackingEventsResponse
 */
export interface TrackingEventsResponse {
    /**
     * 
     * @type {Array<TrackingEventResponse>}
     * @memberof TrackingEventsResponse
     */
    'events': Array<TrackingEventResponse>;
}
/**
 * 
 * @export
 * @interface TrackingLinkCreateRequest
 */
export interface TrackingLinkCreateRequest {
    /**
     * The source link ID
     * @type {string}
     * @memberof TrackingLinkCreateRequest
     */
    'src_link_id': string;
    /**
     * The destination link ID
     * @type {string}
     * @memberof TrackingLinkCreateRequest
     */
    'dst_link_id': string;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkCreateRequest
     */
    'valid_until'?: string | null;
}
/**
 * 
 * @export
 * @interface TrackingLinkResponse
 */
export interface TrackingLinkResponse {
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkResponse
     */
    'src_link_id': string;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkResponse
     */
    'dst_link_id': string;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkResponse
     */
    'valid_until'?: string | null;
}
/**
 * 
 * @export
 * @interface TrackingLinkSearchRequest
 */
export interface TrackingLinkSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkSearchRequest
     */
    'src_link_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkSearchRequest
     */
    'dst_link_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkSearchRequest
     */
    'from_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkSearchRequest
     */
    'to_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingLinkSearchRequest
     */
    'include_expired'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingLinkSearchRequest
     */
    'page'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingLinkSearchRequest
     */
    'page_size'?: number | null;
}
/**
 * 
 * @export
 * @interface TrackingLinksCreateRequest
 */
export interface TrackingLinksCreateRequest {
    /**
     * The list of links to be created
     * @type {Array<TrackingLinkCreateRequest>}
     * @memberof TrackingLinksCreateRequest
     */
    'links': Array<TrackingLinkCreateRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingLinksCreateRequest
     */
    'with_address'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinksCreateRequest
     */
    'unique_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinksCreateRequest
     */
    'fp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinksCreateRequest
     */
    'session_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinksCreateRequest
     */
    'ga'?: string | null;
}
/**
 * 
 * @export
 * @interface TrackingLinksResponse
 */
export interface TrackingLinksResponse {
    /**
     * 
     * @type {Array<TrackingLinkResponse>}
     * @memberof TrackingLinksResponse
     */
    'links': Array<TrackingLinkResponse>;
}
/**
 * 
 * @export
 * @interface TrackingSourceCreateRequest
 */
export interface TrackingSourceCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'click_id'?: string | null;
    /**
     * 
     * @type {TrackingClickIdNames}
     * @memberof TrackingSourceCreateRequest
     */
    'click_id_name'?: TrackingClickIdNames | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'utm_source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'utm_medium'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'utm_campaign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'utm_term'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'utm_content'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'utm_channel'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'ga'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'url'?: string | null;
    /**
     * The links of the traffic source
     * @type {Array<string>}
     * @memberof TrackingSourceCreateRequest
     */
    'links'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof TrackingSourceCreateRequest
     */
    'valid_days'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingSourceCreateRequest
     */
    'with_address'?: boolean | null;
    /**
     * 
     * @type {Array<TrackingEventData>}
     * @memberof TrackingSourceCreateRequest
     */
    'event_data'?: Array<TrackingEventData> | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'unique_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'fp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'session_id'?: string | null;
}


/**
 * 
 * @export
 * @interface TrackingSourceResponse
 */
export interface TrackingSourceResponse {
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'link_id'?: string | null;
    /**
     * 
     * @type {TrackingSourceTypes}
     * @memberof TrackingSourceResponse
     */
    'source_type': TrackingSourceTypes;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'click_id'?: string | null;
    /**
     * 
     * @type {TrackingClickIdNames}
     * @memberof TrackingSourceResponse
     */
    'click_id_name'?: TrackingClickIdNames | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'utm_source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'utm_medium'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'utm_campaign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'utm_term'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'utm_content'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'utm_channel'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'ga'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'valid_until'?: string | null;
    /**
     * 
     * @type {Array<TrackingEventData>}
     * @memberof TrackingSourceResponse
     */
    'event_data'?: Array<TrackingEventData> | null;
}


/**
 * 
 * @export
 * @interface TrackingSourceSearchRequest
 */
export interface TrackingSourceSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {TrackingSourceTypes}
     * @memberof TrackingSourceSearchRequest
     */
    'source_type'?: TrackingSourceTypes | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'click_id'?: string | null;
    /**
     * 
     * @type {TrackingClickIdNames}
     * @memberof TrackingSourceSearchRequest
     */
    'click_id_name'?: TrackingClickIdNames | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'utm_source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'utm_medium'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'utm_campaign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'utm_channel'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'from_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'to_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingSourceSearchRequest
     */
    'include_expired'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingSourceSearchRequest
     */
    'page'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingSourceSearchRequest
     */
    'page_size'?: number | null;
}


/**
 * Enum for tracking source types
 * @export
 * @enum {string}
 */

export const TrackingSourceTypes = {
    Ga: 'ga',
    Fb: 'fb',
    Li: 'li',
    Tw: 'tw',
    Ms: 'ms',
    Ot: 'ot'
} as const;

export type TrackingSourceTypes = typeof TrackingSourceTypes[keyof typeof TrackingSourceTypes];


/**
 * 
 * @export
 * @interface TrackingSourcesResponse
 */
export interface TrackingSourcesResponse {
    /**
     * 
     * @type {Array<TrackingSourceResponse>}
     * @memberof TrackingSourcesResponse
     */
    'sources': Array<TrackingSourceResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionType = {
    G: 'G',
    K: 'K',
    V: 'V',
    S: 'S',
    T: 'T',
    D: 'D',
    M: 'M',
    F: 'F',
    I: 'I',
    C: 'C',
    A: 'A',
    Y: 'Y',
    E: 'E',
    X: 'X',
    P: 'P',
    W: 'W',
    O: 'O',
    N: 'N',
    FtI: 'FT_I',
    Ddg: 'DDG',
    Cgd: 'CGD',
    Cgs: 'CGS',
    Rgs: 'RGS',
    Ugs: 'UGS',
    Igi: 'IGI',
    Tr: 'TR',
    FatGc: 'FAT_GC',
    CeGc: 'CE_GC',
    UeGc: 'UE_GC',
    VeGc: 'VE_GC',
    Cwp: 'CWP',
    DeGc: 'DE_GC',
    AcHs: 'AC_HS',
    LahaHs: 'LAHA_HS',
    LtHs: 'LT_HS',
    GcHs: 'GC_HS',
    UcHs: 'UC_HS',
    ScHs: 'SC_HS',
    EtaHs: 'ETA_HS',
    CnmHs: 'CNM_HS',
    CnpW: 'CNP_W',
    Cne: 'CNE',
    Se: 'SE',
    Ge: 'GE',
    Ale: 'ALE',
    Rle: 'RLE',
    Cps: 'CPS',
    CsGs: 'CS_GS',
    IgApi: 'IG_API',
    Fa: 'FA',
    Hc: 'HC',
    Coe: 'COE',
    Mcp: 'MCP',
    SO: 'S_O',
    SP: 'S_P',
    YF: 'Y_F',
    XS: 'X_S',
    XGps: 'X_GPS',
    XGpgf: 'X_GPGF',
    VT: 'V_T',
    SSm: 'S_SM',
    FVt: 'F_VT',
    RFt: 'R_FT',
    NEt: 'N_ET',
    LTm: 'L_TM',
    JSt: 'J_ST',
    DRt: 'D_RT',
    CdtT: 'CDT_T',
    CsvSt: 'CSV_ST',
    ClT: 'CL_T',
    ApiT: 'API_T',
    TsmT: 'TSM_T',
    SequentialAgent: 'SEQUENTIAL_AGENT',
    SelfManagedAgent: 'SELF_MANAGED_AGENT',
    ToolArxiv: 'TOOL_ARXIV',
    ToolReddit: 'TOOL_REDDIT',
    ToolWikipedia: 'TOOL_WIKIPEDIA',
    ToolDallE: 'TOOL_DALL_E',
    ToolYoutubeSearch: 'TOOL_YOUTUBE_SEARCH',
    ToolIftttWebhook: 'TOOL_IFTTT_WEBHOOK',
    ToolPubmed: 'TOOL_PUBMED',
    ToolStackExchange: 'TOOL_STACK_EXCHANGE',
    MT: 'M_T',
    FtsT: 'FTS_T'
} as const;

export type TransactionType = typeof TransactionType[keyof typeof TransactionType];


/**
 * 
 * @export
 * @interface TranscriptTaskRequest
 */
export interface TranscriptTaskRequest {
    /**
     * The task ID to get the transcript from
     * @type {string}
     * @memberof TranscriptTaskRequest
     */
    'task_id': string;
}
/**
 * 
 * @export
 * @interface TriggerResponse
 */
export interface TriggerResponse {
    /**
     * Trigger types
     * @type {{ [key: string]: string; }}
     * @memberof TriggerResponse
     */
    'triggers': { [key: string]: string; };
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TriggerType = {
    OnChatOpen: 'on_chat_open',
    CustomTrigger: 'custom_trigger',
    ChatInput: 'chat_input',
    SlackMessageReceived: 'slack_message_received',
    SlackShortcuts: 'slack_shortcuts',
    OnHubspotMessage: 'on_hubspot_message',
    OnGmailMessage: 'on_gmail_message',
    OnEmailMessage: 'on_email_message',
    OnOutlookMessage: 'on_outlook_message',
    OnCalendarEventCreated: 'on_calendar_event_created',
    OnTelegramMessage: 'on_telegram_message',
    OnFlowFormSubmission: 'on_flow_form_submission'
} as const;

export type TriggerType = typeof TriggerType[keyof typeof TriggerType];


/**
 * 
 * @export
 * @interface UrlScreenshotResponse
 */
export interface UrlScreenshotResponse {
    /**
     * 
     * @type {string}
     * @memberof UrlScreenshotResponse
     */
    'original_image': string;
    /**
     * 
     * @type {string}
     * @memberof UrlScreenshotResponse
     */
    'thumbnail_image': string;
    /**
     * 
     * @type {string}
     * @memberof UrlScreenshotResponse
     */
    'original_image_full_page': string;
    /**
     * 
     * @type {string}
     * @memberof UrlScreenshotResponse
     */
    'thumbnail_image_full_page': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UserDocumentStatus = {
    E: 'E',
    D: 'D'
} as const;

export type UserDocumentStatus = typeof UserDocumentStatus[keyof typeof UserDocumentStatus];


/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * User ID
     * @type {string}
     * @memberof UserResponse
     */
    'user_id': string;
    /**
     * Email of the user
     * @type {string}
     * @memberof UserResponse
     */
    'email': string;
    /**
     * Name of the user
     * @type {string}
     * @memberof UserResponse
     */
    'username': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponse
     */
    'is_active'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'avatar_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'api_key_workspace_id'?: string | null;
    /**
     * 
     * @type {{ [key: string]: SubscriptionPlan; }}
     * @memberof UserResponse
     */
    'product_plans'?: { [key: string]: SubscriptionPlan; } | null;
    /**
     * 
     * @type {BillingProvider}
     * @memberof UserResponse
     */
    'billing_provider'?: BillingProvider | null;
    /**
     * Whether the user has superuser privileges
     * @type {boolean}
     * @memberof UserResponse
     */
    'sudoer'?: boolean;
}


/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}
/**
 * 
 * @export
 * @interface VectorDocumentResponse
 */
export interface VectorDocumentResponse {
    /**
     * Document ID
     * @type {string}
     * @memberof VectorDocumentResponse
     */
    'document_id': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof VectorDocumentResponse
     */
    'workspace_id': string;
    /**
     * Document type
     * @type {VectorDocumentType}
     * @memberof VectorDocumentResponse
     */
    'document_type': VectorDocumentType;
    /**
     * Point ID
     * @type {string}
     * @memberof VectorDocumentResponse
     */
    'point_id': string;
    /**
     * Pointer position
     * @type {number}
     * @memberof VectorDocumentResponse
     */
    'pointer_position': number;
    /**
     * Pointer type
     * @type {PointerType}
     * @memberof VectorDocumentResponse
     */
    'pointer_type': PointerType;
    /**
     * 
     * @type {string}
     * @memberof VectorDocumentResponse
     */
    'schema_type'?: string | null;
    /**
     * Knowledge key - schedule id or category id
     * @type {string}
     * @memberof VectorDocumentResponse
     */
    'kb_key': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof VectorDocumentResponse
     */
    'vector': Array<number> | null;
    /**
     * Vector ID
     * @type {number}
     * @memberof VectorDocumentResponse
     */
    'vector_id': number;
    /**
     * 
     * @type {Data}
     * @memberof VectorDocumentResponse
     */
    'data'?: Data | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const VectorDocumentType = {
    U: 'U',
    P: 'P',
    Q: 'Q'
} as const;

export type VectorDocumentType = typeof VectorDocumentType[keyof typeof VectorDocumentType];


/**
 * 
 * @export
 * @interface VectorDocumentsTaskResponse
 */
export interface VectorDocumentsTaskResponse {
    /**
     * Task ID
     * @type {string}
     * @memberof VectorDocumentsTaskResponse
     */
    'id': string;
    /**
     * Task status
     * @type {TaskStatus}
     * @memberof VectorDocumentsTaskResponse
     */
    'status': TaskStatus;
    /**
     * 
     * @type {Array<VectorDocumentResponse>}
     * @memberof VectorDocumentsTaskResponse
     */
    'result'?: Array<VectorDocumentResponse> | null;
    /**
     * 
     * @type {string}
     * @memberof VectorDocumentsTaskResponse
     */
    'error_message'?: string | null;
}


/**
 * 
 * @export
 * @interface WixMemberResponse
 */
export interface WixMemberResponse {
    /**
     * Member ID
     * @type {string}
     * @memberof WixMemberResponse
     */
    'member_id': string;
    /**
     * Member name
     * @type {string}
     * @memberof WixMemberResponse
     */
    'member_name': string;
}
/**
 * 
 * @export
 * @interface WixMembersResponse
 */
export interface WixMembersResponse {
    /**
     * 
     * @type {Array<WixMemberResponse>}
     * @memberof WixMembersResponse
     */
    'members': Array<WixMemberResponse>;
}
/**
 * 
 * @export
 * @interface WordPressCategoryResponse
 */
export interface WordPressCategoryResponse {
    /**
     * 
     * @type {number}
     * @memberof WordPressCategoryResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof WordPressCategoryResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WordPressCategoryResponse
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof WordPressCategoryResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof WordPressCategoryResponse
     */
    'link': string;
    /**
     * 
     * @type {number}
     * @memberof WordPressCategoryResponse
     */
    'parent': number;
    /**
     * 
     * @type {number}
     * @memberof WordPressCategoryResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface WordPressSiteResponse
 */
export interface WordPressSiteResponse {
    /**
     * Integration ID
     * @type {string}
     * @memberof WordPressSiteResponse
     */
    'integration_id': string;
    /**
     * Site URL
     * @type {string}
     * @memberof WordPressSiteResponse
     */
    'site_url': string;
    /**
     * 
     * @type {string}
     * @memberof WordPressSiteResponse
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof WordPressSiteResponse
     */
    'home': string | null;
}
/**
 * 
 * @export
 * @interface WordPressTagsResponse
 */
export interface WordPressTagsResponse {
    /**
     * 
     * @type {number}
     * @memberof WordPressTagsResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof WordPressTagsResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WordPressTagsResponse
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof WordPressTagsResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof WordPressTagsResponse
     */
    'link': string;
    /**
     * 
     * @type {number}
     * @memberof WordPressTagsResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface WorkspaceCreateRequest
 */
export interface WorkspaceCreateRequest {
    /**
     * Name of the workspace
     * @type {string}
     * @memberof WorkspaceCreateRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface WorkspaceResponse
 */
export interface WorkspaceResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof WorkspaceResponse
     */
    'workspace_id': string;
    /**
     * Name of the workspace
     * @type {string}
     * @memberof WorkspaceResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface WorkspaceRole
 */
export interface WorkspaceRole {
    /**
     * Workspace ID
     * @type {string}
     * @memberof WorkspaceRole
     */
    'workspace_id': string;
    /**
     * Workspace Name
     * @type {string}
     * @memberof WorkspaceRole
     */
    'workspace_name': string;
    /**
     * Name of the owner of the workspace
     * @type {string}
     * @memberof WorkspaceRole
     */
    'owner_name': string;
    /**
     * Email of the owner of the workspace
     * @type {string}
     * @memberof WorkspaceRole
     */
    'owner_email': string;
    /**
     * Role of the user in the workspace (A - Admin, E - Editor, M - Member, G - Guest)
     * @type {string}
     * @memberof WorkspaceRole
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface WorkspaceSearchRequest
 */
export interface WorkspaceSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSearchRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSearchRequest
     */
    'workspace_id'?: string | null;
    /**
     * 
     * @type {Pagination}
     * @memberof WorkspaceSearchRequest
     */
    'pagination'?: Pagination | null;
    /**
     * 
     * @type {number}
     * @memberof WorkspaceSearchRequest
     */
    'limit'?: number | null;
}
/**
 * 
 * @export
 * @interface WorkspaceUpdateRequest
 */
export interface WorkspaceUpdateRequest {
    /**
     * Name of the workspace
     * @type {string}
     * @memberof WorkspaceUpdateRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface WorkspaceUserCreateRequest
 */
export interface WorkspaceUserCreateRequest {
    /**
     * Email of the user to add to the workspace
     * @type {string}
     * @memberof WorkspaceUserCreateRequest
     */
    'email': string;
    /**
     * Role of the user in the workspace
     * @type {Role}
     * @memberof WorkspaceUserCreateRequest
     */
    'role': Role;
}


/**
 * 
 * @export
 * @interface WorkspaceUserResponse
 */
export interface WorkspaceUserResponse {
    /**
     * User ID
     * @type {string}
     * @memberof WorkspaceUserResponse
     */
    'user_id': string;
    /**
     * Email of the user
     * @type {string}
     * @memberof WorkspaceUserResponse
     */
    'email': string;
    /**
     * Name of the user
     * @type {string}
     * @memberof WorkspaceUserResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceUserResponse
     */
    'avatar_url'?: string | null;
    /**
     * Role of the user (A - Admin, E - Editor, M - member, G - Guest)
     * @type {Role}
     * @memberof WorkspaceUserResponse
     */
    'role': Role;
}


/**
 * 
 * @export
 * @interface WorkspaceUserUpdateRequest
 */
export interface WorkspaceUserUpdateRequest {
    /**
     * Role of the user in the workspace
     * @type {Role}
     * @memberof WorkspaceUserUpdateRequest
     */
    'role'?: Role;
}


/**
 * 
 * @export
 * @interface WorkspaceUsersSearchRequest
 */
export interface WorkspaceUsersSearchRequest {
    /**
     * 
     * @type {Role}
     * @memberof WorkspaceUsersSearchRequest
     */
    'role'?: Role | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceUsersSearchRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceUsersSearchRequest
     */
    'email'?: string | null;
}


/**
 * 
 * @export
 * @interface YoutubeContent
 */
export interface YoutubeContent {
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'img_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof YoutubeContent
     */
    'status_code'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof YoutubeContent
     */
    'created_at'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof YoutubeContent
     */
    'published_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'doc_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'lang'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'content_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'encoding'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'apparent_encoding'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'content'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof YoutubeContent
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof YoutubeContent
     */
    'alt_content'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'content_hash'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'author'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'channel_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'channel_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'channel_title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof YoutubeContent
     */
    'duration'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof YoutubeContent
     */
    'keywords'?: Array<string> | null;
    /**
     * 
     * @type {DocumentType}
     * @memberof YoutubeContent
     */
    'doc_type'?: DocumentType | null;
    /**
     * 
     * @type {number}
     * @memberof YoutubeContent
     */
    'credits'?: number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof YoutubeContent
     */
    'url_content'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {MerchantMetadata}
     * @memberof YoutubeContent
     */
    'merchant_metadata'?: MerchantMetadata | null;
}


/**
 * 
 * @export
 * @interface YoutubeTranscriptRequest
 */
export interface YoutubeTranscriptRequest {
    /**
     * 
     * @type {string}
     * @memberof YoutubeTranscriptRequest
     */
    'post_back_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeTranscriptRequest
     */
    'video_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeTranscriptRequest
     */
    'video_url'?: string | null;
}
/**
 * 
 * @export
 * @interface YoutubeTranscriptResponse
 */
export interface YoutubeTranscriptResponse {
    /**
     * Task ID
     * @type {string}
     * @memberof YoutubeTranscriptResponse
     */
    'id': string;
    /**
     * Task status
     * @type {TaskStatus}
     * @memberof YoutubeTranscriptResponse
     */
    'status': TaskStatus;
    /**
     * 
     * @type {YoutubeContent}
     * @memberof YoutubeTranscriptResponse
     */
    'result'?: YoutubeContent | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeTranscriptResponse
     */
    'error_message'?: string | null;
}



/**
 * AgentGridsApi - axios parameter creator
 * @export
 */
export const AgentGridsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Flow Table with the specified schema.
         * @summary Create a Flow Table
         * @param {string} workspaceId 
         * @param {AgentGridCreateRequest} agentGridCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgentGrid: async (workspaceId: string, agentGridCreateRequest: AgentGridCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createAgentGrid', 'workspaceId', workspaceId)
            // verify required parameter 'agentGridCreateRequest' is not null or undefined
            assertParamExists('createAgentGrid', 'agentGridCreateRequest', agentGridCreateRequest)
            const localVarPath = `/v2/agent_grids/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentGridCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Flow Table and all its data.
         * @summary Delete a Flow Table
         * @param {string} agentGridId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgentGrid: async (agentGridId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentGridId' is not null or undefined
            assertParamExists('deleteAgentGrid', 'agentGridId', agentGridId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteAgentGrid', 'workspaceId', workspaceId)
            const localVarPath = `/v2/agent_grids/{agent_grid_id}`
                .replace(`{${"agent_grid_id"}}`, encodeURIComponent(String(agentGridId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single row from the Flow Table.
         * @summary Delete a row
         * @param {string} agentGridId 
         * @param {string} rowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRow: async (agentGridId: string, rowId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentGridId' is not null or undefined
            assertParamExists('deleteRow', 'agentGridId', agentGridId)
            // verify required parameter 'rowId' is not null or undefined
            assertParamExists('deleteRow', 'rowId', rowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteRow', 'workspaceId', workspaceId)
            const localVarPath = `/v2/agent_grids/{agent_grid_id}/rows/{row_id}`
                .replace(`{${"agent_grid_id"}}`, encodeURIComponent(String(agentGridId)))
                .replace(`{${"row_id"}}`, encodeURIComponent(String(rowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of a specific Flow Table by ID.
         * @summary Get a Flow Table
         * @param {string} agentGridId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentGrid: async (agentGridId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentGridId' is not null or undefined
            assertParamExists('getAgentGrid', 'agentGridId', agentGridId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getAgentGrid', 'workspaceId', workspaceId)
            const localVarPath = `/v2/agent_grids/{agent_grid_id}`
                .replace(`{${"agent_grid_id"}}`, encodeURIComponent(String(agentGridId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the first N rows of a Flow Table.
         * @summary Get Flow Table preview
         * @param {string} agentGridId 
         * @param {string} workspaceId 
         * @param {number} [limit] Number of rows to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentGridPreview: async (agentGridId: string, workspaceId: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentGridId' is not null or undefined
            assertParamExists('getAgentGridPreview', 'agentGridId', agentGridId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getAgentGridPreview', 'workspaceId', workspaceId)
            const localVarPath = `/v2/agent_grids/{agent_grid_id}/preview`
                .replace(`{${"agent_grid_id"}}`, encodeURIComponent(String(agentGridId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Poll for the status of a CSV import. Returns progress, errors, and completion status.
         * @summary Get import status
         * @param {string} agentGridId 
         * @param {string} importId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportStatus: async (agentGridId: string, importId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentGridId' is not null or undefined
            assertParamExists('getImportStatus', 'agentGridId', agentGridId)
            // verify required parameter 'importId' is not null or undefined
            assertParamExists('getImportStatus', 'importId', importId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getImportStatus', 'workspaceId', workspaceId)
            const localVarPath = `/v2/agent_grids/{agent_grid_id}/import-status/{import_id}`
                .replace(`{${"agent_grid_id"}}`, encodeURIComponent(String(agentGridId)))
                .replace(`{${"import_id"}}`, encodeURIComponent(String(importId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start importing rows from a CSV file. The import runs asynchronously. Use the returned import_id to poll for status.
         * @summary Import CSV
         * @param {string} agentGridId 
         * @param {string} workspaceId 
         * @param {File} file CSV file to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCsv: async (agentGridId: string, workspaceId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentGridId' is not null or undefined
            assertParamExists('importCsv', 'agentGridId', agentGridId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('importCsv', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('importCsv', 'file', file)
            const localVarPath = `/v2/agent_grids/{agent_grid_id}/import-csv`
                .replace(`{${"agent_grid_id"}}`, encodeURIComponent(String(agentGridId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts a single row into the Flow Table.
         * @summary Insert a row
         * @param {string} agentGridId 
         * @param {string} workspaceId 
         * @param {AgentGridRowInsertRequest} agentGridRowInsertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertRow: async (agentGridId: string, workspaceId: string, agentGridRowInsertRequest: AgentGridRowInsertRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentGridId' is not null or undefined
            assertParamExists('insertRow', 'agentGridId', agentGridId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('insertRow', 'workspaceId', workspaceId)
            // verify required parameter 'agentGridRowInsertRequest' is not null or undefined
            assertParamExists('insertRow', 'agentGridRowInsertRequest', agentGridRowInsertRequest)
            const localVarPath = `/v2/agent_grids/{agent_grid_id}/rows`
                .replace(`{${"agent_grid_id"}}`, encodeURIComponent(String(agentGridId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentGridRowInsertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts multiple rows into the Flow Table.
         * @summary Bulk insert rows
         * @param {string} agentGridId 
         * @param {string} workspaceId 
         * @param {AgentGridRowsBulkInsertRequest} agentGridRowsBulkInsertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertRowsBulk: async (agentGridId: string, workspaceId: string, agentGridRowsBulkInsertRequest: AgentGridRowsBulkInsertRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentGridId' is not null or undefined
            assertParamExists('insertRowsBulk', 'agentGridId', agentGridId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('insertRowsBulk', 'workspaceId', workspaceId)
            // verify required parameter 'agentGridRowsBulkInsertRequest' is not null or undefined
            assertParamExists('insertRowsBulk', 'agentGridRowsBulkInsertRequest', agentGridRowsBulkInsertRequest)
            const localVarPath = `/v2/agent_grids/{agent_grid_id}/rows/bulk`
                .replace(`{${"agent_grid_id"}}`, encodeURIComponent(String(agentGridId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentGridRowsBulkInsertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all Flow Tables (Agent Grids) for the workspace.
         * @summary List all Flow Tables
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentGrids: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listAgentGrids', 'workspaceId', workspaceId)
            const localVarPath = `/v2/agent_grids/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search rows in the Flow Table using full-text search.
         * @summary Search rows
         * @param {string} agentGridId 
         * @param {string} workspaceId 
         * @param {AgentGridSearchRequest} agentGridSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRows: async (agentGridId: string, workspaceId: string, agentGridSearchRequest: AgentGridSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentGridId' is not null or undefined
            assertParamExists('searchRows', 'agentGridId', agentGridId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchRows', 'workspaceId', workspaceId)
            // verify required parameter 'agentGridSearchRequest' is not null or undefined
            assertParamExists('searchRows', 'agentGridSearchRequest', agentGridSearchRequest)
            const localVarPath = `/v2/agent_grids/{agent_grid_id}/search`
                .replace(`{${"agent_grid_id"}}`, encodeURIComponent(String(agentGridId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentGridSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentGridsApi - functional programming interface
 * @export
 */
export const AgentGridsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentGridsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Flow Table with the specified schema.
         * @summary Create a Flow Table
         * @param {string} workspaceId 
         * @param {AgentGridCreateRequest} agentGridCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAgentGrid(workspaceId: string, agentGridCreateRequest: AgentGridCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentGridResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAgentGrid(workspaceId, agentGridCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGridsApi.createAgentGrid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a Flow Table and all its data.
         * @summary Delete a Flow Table
         * @param {string} agentGridId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAgentGrid(agentGridId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAgentGrid(agentGridId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGridsApi.deleteAgentGrid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a single row from the Flow Table.
         * @summary Delete a row
         * @param {string} agentGridId 
         * @param {string} rowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRow(agentGridId: string, rowId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRow(agentGridId, rowId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGridsApi.deleteRow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns details of a specific Flow Table by ID.
         * @summary Get a Flow Table
         * @param {string} agentGridId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentGrid(agentGridId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentGridResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgentGrid(agentGridId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGridsApi.getAgentGrid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the first N rows of a Flow Table.
         * @summary Get Flow Table preview
         * @param {string} agentGridId 
         * @param {string} workspaceId 
         * @param {number} [limit] Number of rows to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentGridPreview(agentGridId: string, workspaceId: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentGridPreviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgentGridPreview(agentGridId, workspaceId, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGridsApi.getAgentGridPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Poll for the status of a CSV import. Returns progress, errors, and completion status.
         * @summary Get import status
         * @param {string} agentGridId 
         * @param {string} importId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImportStatus(agentGridId: string, importId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentGridImportStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImportStatus(agentGridId, importId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGridsApi.getImportStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start importing rows from a CSV file. The import runs asynchronously. Use the returned import_id to poll for status.
         * @summary Import CSV
         * @param {string} agentGridId 
         * @param {string} workspaceId 
         * @param {File} file CSV file to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importCsv(agentGridId: string, workspaceId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentGridImportStartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importCsv(agentGridId, workspaceId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGridsApi.importCsv']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Inserts a single row into the Flow Table.
         * @summary Insert a row
         * @param {string} agentGridId 
         * @param {string} workspaceId 
         * @param {AgentGridRowInsertRequest} agentGridRowInsertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertRow(agentGridId: string, workspaceId: string, agentGridRowInsertRequest: AgentGridRowInsertRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentGridRowInsertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertRow(agentGridId, workspaceId, agentGridRowInsertRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGridsApi.insertRow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Inserts multiple rows into the Flow Table.
         * @summary Bulk insert rows
         * @param {string} agentGridId 
         * @param {string} workspaceId 
         * @param {AgentGridRowsBulkInsertRequest} agentGridRowsBulkInsertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertRowsBulk(agentGridId: string, workspaceId: string, agentGridRowsBulkInsertRequest: AgentGridRowsBulkInsertRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentGridBulkInsertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertRowsBulk(agentGridId, workspaceId, agentGridRowsBulkInsertRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGridsApi.insertRowsBulk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all Flow Tables (Agent Grids) for the workspace.
         * @summary List all Flow Tables
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgentGrids(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AgentGridResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAgentGrids(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGridsApi.listAgentGrids']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search rows in the Flow Table using full-text search.
         * @summary Search rows
         * @param {string} agentGridId 
         * @param {string} workspaceId 
         * @param {AgentGridSearchRequest} agentGridSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchRows(agentGridId: string, workspaceId: string, agentGridSearchRequest: AgentGridSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentGridSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRows(agentGridId, workspaceId, agentGridSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentGridsApi.searchRows']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AgentGridsApi - factory interface
 * @export
 */
export const AgentGridsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentGridsApiFp(configuration)
    return {
        /**
         * Creates a new Flow Table with the specified schema.
         * @summary Create a Flow Table
         * @param {AgentGridsApiCreateAgentGridRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgentGrid(requestParameters: AgentGridsApiCreateAgentGridRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridResponse> {
            return localVarFp.createAgentGrid(requestParameters.workspaceId, requestParameters.agentGridCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Flow Table and all its data.
         * @summary Delete a Flow Table
         * @param {AgentGridsApiDeleteAgentGridRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgentGrid(requestParameters: AgentGridsApiDeleteAgentGridRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteAgentGrid(requestParameters.agentGridId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single row from the Flow Table.
         * @summary Delete a row
         * @param {AgentGridsApiDeleteRowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRow(requestParameters: AgentGridsApiDeleteRowRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteRow(requestParameters.agentGridId, requestParameters.rowId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of a specific Flow Table by ID.
         * @summary Get a Flow Table
         * @param {AgentGridsApiGetAgentGridRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentGrid(requestParameters: AgentGridsApiGetAgentGridRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridResponse> {
            return localVarFp.getAgentGrid(requestParameters.agentGridId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the first N rows of a Flow Table.
         * @summary Get Flow Table preview
         * @param {AgentGridsApiGetAgentGridPreviewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentGridPreview(requestParameters: AgentGridsApiGetAgentGridPreviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridPreviewResponse> {
            return localVarFp.getAgentGridPreview(requestParameters.agentGridId, requestParameters.workspaceId, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Poll for the status of a CSV import. Returns progress, errors, and completion status.
         * @summary Get import status
         * @param {AgentGridsApiGetImportStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImportStatus(requestParameters: AgentGridsApiGetImportStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridImportStatusResponse> {
            return localVarFp.getImportStatus(requestParameters.agentGridId, requestParameters.importId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Start importing rows from a CSV file. The import runs asynchronously. Use the returned import_id to poll for status.
         * @summary Import CSV
         * @param {AgentGridsApiImportCsvRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCsv(requestParameters: AgentGridsApiImportCsvRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridImportStartResponse> {
            return localVarFp.importCsv(requestParameters.agentGridId, requestParameters.workspaceId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts a single row into the Flow Table.
         * @summary Insert a row
         * @param {AgentGridsApiInsertRowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertRow(requestParameters: AgentGridsApiInsertRowRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridRowInsertResponse> {
            return localVarFp.insertRow(requestParameters.agentGridId, requestParameters.workspaceId, requestParameters.agentGridRowInsertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts multiple rows into the Flow Table.
         * @summary Bulk insert rows
         * @param {AgentGridsApiInsertRowsBulkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertRowsBulk(requestParameters: AgentGridsApiInsertRowsBulkRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridBulkInsertResponse> {
            return localVarFp.insertRowsBulk(requestParameters.agentGridId, requestParameters.workspaceId, requestParameters.agentGridRowsBulkInsertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all Flow Tables (Agent Grids) for the workspace.
         * @summary List all Flow Tables
         * @param {AgentGridsApiListAgentGridsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentGrids(requestParameters: AgentGridsApiListAgentGridsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<AgentGridResponse>> {
            return localVarFp.listAgentGrids(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search rows in the Flow Table using full-text search.
         * @summary Search rows
         * @param {AgentGridsApiSearchRowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRows(requestParameters: AgentGridsApiSearchRowsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridSearchResponse> {
            return localVarFp.searchRows(requestParameters.agentGridId, requestParameters.workspaceId, requestParameters.agentGridSearchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentGridsApi - interface
 * @export
 * @interface AgentGridsApi
 */
export interface AgentGridsApiInterface {
    /**
     * Creates a new Flow Table with the specified schema.
     * @summary Create a Flow Table
     * @param {AgentGridsApiCreateAgentGridRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApiInterface
     */
    createAgentGrid(requestParameters: AgentGridsApiCreateAgentGridRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridResponse>;

    /**
     * Deletes a Flow Table and all its data.
     * @summary Delete a Flow Table
     * @param {AgentGridsApiDeleteAgentGridRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApiInterface
     */
    deleteAgentGrid(requestParameters: AgentGridsApiDeleteAgentGridRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * Deletes a single row from the Flow Table.
     * @summary Delete a row
     * @param {AgentGridsApiDeleteRowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApiInterface
     */
    deleteRow(requestParameters: AgentGridsApiDeleteRowRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * Returns details of a specific Flow Table by ID.
     * @summary Get a Flow Table
     * @param {AgentGridsApiGetAgentGridRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApiInterface
     */
    getAgentGrid(requestParameters: AgentGridsApiGetAgentGridRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridResponse>;

    /**
     * Returns the first N rows of a Flow Table.
     * @summary Get Flow Table preview
     * @param {AgentGridsApiGetAgentGridPreviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApiInterface
     */
    getAgentGridPreview(requestParameters: AgentGridsApiGetAgentGridPreviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridPreviewResponse>;

    /**
     * Poll for the status of a CSV import. Returns progress, errors, and completion status.
     * @summary Get import status
     * @param {AgentGridsApiGetImportStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApiInterface
     */
    getImportStatus(requestParameters: AgentGridsApiGetImportStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridImportStatusResponse>;

    /**
     * Start importing rows from a CSV file. The import runs asynchronously. Use the returned import_id to poll for status.
     * @summary Import CSV
     * @param {AgentGridsApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApiInterface
     */
    importCsv(requestParameters: AgentGridsApiImportCsvRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridImportStartResponse>;

    /**
     * Inserts a single row into the Flow Table.
     * @summary Insert a row
     * @param {AgentGridsApiInsertRowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApiInterface
     */
    insertRow(requestParameters: AgentGridsApiInsertRowRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridRowInsertResponse>;

    /**
     * Inserts multiple rows into the Flow Table.
     * @summary Bulk insert rows
     * @param {AgentGridsApiInsertRowsBulkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApiInterface
     */
    insertRowsBulk(requestParameters: AgentGridsApiInsertRowsBulkRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridBulkInsertResponse>;

    /**
     * Returns a list of all Flow Tables (Agent Grids) for the workspace.
     * @summary List all Flow Tables
     * @param {AgentGridsApiListAgentGridsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApiInterface
     */
    listAgentGrids(requestParameters: AgentGridsApiListAgentGridsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<AgentGridResponse>>;

    /**
     * Search rows in the Flow Table using full-text search.
     * @summary Search rows
     * @param {AgentGridsApiSearchRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApiInterface
     */
    searchRows(requestParameters: AgentGridsApiSearchRowsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentGridSearchResponse>;

}

/**
 * Request parameters for createAgentGrid operation in AgentGridsApi.
 * @export
 * @interface AgentGridsApiCreateAgentGridRequest
 */
export interface AgentGridsApiCreateAgentGridRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiCreateAgentGrid
     */
    readonly workspaceId: string

    /**
     * 
     * @type {AgentGridCreateRequest}
     * @memberof AgentGridsApiCreateAgentGrid
     */
    readonly agentGridCreateRequest: AgentGridCreateRequest
}

/**
 * Request parameters for deleteAgentGrid operation in AgentGridsApi.
 * @export
 * @interface AgentGridsApiDeleteAgentGridRequest
 */
export interface AgentGridsApiDeleteAgentGridRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiDeleteAgentGrid
     */
    readonly agentGridId: string

    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiDeleteAgentGrid
     */
    readonly workspaceId: string
}

/**
 * Request parameters for deleteRow operation in AgentGridsApi.
 * @export
 * @interface AgentGridsApiDeleteRowRequest
 */
export interface AgentGridsApiDeleteRowRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiDeleteRow
     */
    readonly agentGridId: string

    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiDeleteRow
     */
    readonly rowId: string

    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiDeleteRow
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getAgentGrid operation in AgentGridsApi.
 * @export
 * @interface AgentGridsApiGetAgentGridRequest
 */
export interface AgentGridsApiGetAgentGridRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiGetAgentGrid
     */
    readonly agentGridId: string

    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiGetAgentGrid
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getAgentGridPreview operation in AgentGridsApi.
 * @export
 * @interface AgentGridsApiGetAgentGridPreviewRequest
 */
export interface AgentGridsApiGetAgentGridPreviewRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiGetAgentGridPreview
     */
    readonly agentGridId: string

    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiGetAgentGridPreview
     */
    readonly workspaceId: string

    /**
     * Number of rows to return
     * @type {number}
     * @memberof AgentGridsApiGetAgentGridPreview
     */
    readonly limit?: number
}

/**
 * Request parameters for getImportStatus operation in AgentGridsApi.
 * @export
 * @interface AgentGridsApiGetImportStatusRequest
 */
export interface AgentGridsApiGetImportStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiGetImportStatus
     */
    readonly agentGridId: string

    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiGetImportStatus
     */
    readonly importId: string

    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiGetImportStatus
     */
    readonly workspaceId: string
}

/**
 * Request parameters for importCsv operation in AgentGridsApi.
 * @export
 * @interface AgentGridsApiImportCsvRequest
 */
export interface AgentGridsApiImportCsvRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiImportCsv
     */
    readonly agentGridId: string

    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiImportCsv
     */
    readonly workspaceId: string

    /**
     * CSV file to import
     * @type {File}
     * @memberof AgentGridsApiImportCsv
     */
    readonly file: File
}

/**
 * Request parameters for insertRow operation in AgentGridsApi.
 * @export
 * @interface AgentGridsApiInsertRowRequest
 */
export interface AgentGridsApiInsertRowRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiInsertRow
     */
    readonly agentGridId: string

    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiInsertRow
     */
    readonly workspaceId: string

    /**
     * 
     * @type {AgentGridRowInsertRequest}
     * @memberof AgentGridsApiInsertRow
     */
    readonly agentGridRowInsertRequest: AgentGridRowInsertRequest
}

/**
 * Request parameters for insertRowsBulk operation in AgentGridsApi.
 * @export
 * @interface AgentGridsApiInsertRowsBulkRequest
 */
export interface AgentGridsApiInsertRowsBulkRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiInsertRowsBulk
     */
    readonly agentGridId: string

    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiInsertRowsBulk
     */
    readonly workspaceId: string

    /**
     * 
     * @type {AgentGridRowsBulkInsertRequest}
     * @memberof AgentGridsApiInsertRowsBulk
     */
    readonly agentGridRowsBulkInsertRequest: AgentGridRowsBulkInsertRequest
}

/**
 * Request parameters for listAgentGrids operation in AgentGridsApi.
 * @export
 * @interface AgentGridsApiListAgentGridsRequest
 */
export interface AgentGridsApiListAgentGridsRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiListAgentGrids
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchRows operation in AgentGridsApi.
 * @export
 * @interface AgentGridsApiSearchRowsRequest
 */
export interface AgentGridsApiSearchRowsRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiSearchRows
     */
    readonly agentGridId: string

    /**
     * 
     * @type {string}
     * @memberof AgentGridsApiSearchRows
     */
    readonly workspaceId: string

    /**
     * 
     * @type {AgentGridSearchRequest}
     * @memberof AgentGridsApiSearchRows
     */
    readonly agentGridSearchRequest: AgentGridSearchRequest
}

/**
 * AgentGridsApi - object-oriented interface
 * @export
 * @class AgentGridsApi
 * @extends {BaseAPI}
 */
export class AgentGridsApi extends BaseAPI implements AgentGridsApiInterface {
    /**
     * Creates a new Flow Table with the specified schema.
     * @summary Create a Flow Table
     * @param {AgentGridsApiCreateAgentGridRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApi
     */
    public createAgentGrid(requestParameters: AgentGridsApiCreateAgentGridRequest, options?: RawAxiosRequestConfig) {
        return AgentGridsApiFp(this.configuration).createAgentGrid(requestParameters.workspaceId, requestParameters.agentGridCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a Flow Table and all its data.
     * @summary Delete a Flow Table
     * @param {AgentGridsApiDeleteAgentGridRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApi
     */
    public deleteAgentGrid(requestParameters: AgentGridsApiDeleteAgentGridRequest, options?: RawAxiosRequestConfig) {
        return AgentGridsApiFp(this.configuration).deleteAgentGrid(requestParameters.agentGridId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single row from the Flow Table.
     * @summary Delete a row
     * @param {AgentGridsApiDeleteRowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApi
     */
    public deleteRow(requestParameters: AgentGridsApiDeleteRowRequest, options?: RawAxiosRequestConfig) {
        return AgentGridsApiFp(this.configuration).deleteRow(requestParameters.agentGridId, requestParameters.rowId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details of a specific Flow Table by ID.
     * @summary Get a Flow Table
     * @param {AgentGridsApiGetAgentGridRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApi
     */
    public getAgentGrid(requestParameters: AgentGridsApiGetAgentGridRequest, options?: RawAxiosRequestConfig) {
        return AgentGridsApiFp(this.configuration).getAgentGrid(requestParameters.agentGridId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the first N rows of a Flow Table.
     * @summary Get Flow Table preview
     * @param {AgentGridsApiGetAgentGridPreviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApi
     */
    public getAgentGridPreview(requestParameters: AgentGridsApiGetAgentGridPreviewRequest, options?: RawAxiosRequestConfig) {
        return AgentGridsApiFp(this.configuration).getAgentGridPreview(requestParameters.agentGridId, requestParameters.workspaceId, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Poll for the status of a CSV import. Returns progress, errors, and completion status.
     * @summary Get import status
     * @param {AgentGridsApiGetImportStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApi
     */
    public getImportStatus(requestParameters: AgentGridsApiGetImportStatusRequest, options?: RawAxiosRequestConfig) {
        return AgentGridsApiFp(this.configuration).getImportStatus(requestParameters.agentGridId, requestParameters.importId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start importing rows from a CSV file. The import runs asynchronously. Use the returned import_id to poll for status.
     * @summary Import CSV
     * @param {AgentGridsApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApi
     */
    public importCsv(requestParameters: AgentGridsApiImportCsvRequest, options?: RawAxiosRequestConfig) {
        return AgentGridsApiFp(this.configuration).importCsv(requestParameters.agentGridId, requestParameters.workspaceId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts a single row into the Flow Table.
     * @summary Insert a row
     * @param {AgentGridsApiInsertRowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApi
     */
    public insertRow(requestParameters: AgentGridsApiInsertRowRequest, options?: RawAxiosRequestConfig) {
        return AgentGridsApiFp(this.configuration).insertRow(requestParameters.agentGridId, requestParameters.workspaceId, requestParameters.agentGridRowInsertRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts multiple rows into the Flow Table.
     * @summary Bulk insert rows
     * @param {AgentGridsApiInsertRowsBulkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApi
     */
    public insertRowsBulk(requestParameters: AgentGridsApiInsertRowsBulkRequest, options?: RawAxiosRequestConfig) {
        return AgentGridsApiFp(this.configuration).insertRowsBulk(requestParameters.agentGridId, requestParameters.workspaceId, requestParameters.agentGridRowsBulkInsertRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all Flow Tables (Agent Grids) for the workspace.
     * @summary List all Flow Tables
     * @param {AgentGridsApiListAgentGridsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApi
     */
    public listAgentGrids(requestParameters: AgentGridsApiListAgentGridsRequest, options?: RawAxiosRequestConfig) {
        return AgentGridsApiFp(this.configuration).listAgentGrids(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search rows in the Flow Table using full-text search.
     * @summary Search rows
     * @param {AgentGridsApiSearchRowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentGridsApi
     */
    public searchRows(requestParameters: AgentGridsApiSearchRowsRequest, options?: RawAxiosRequestConfig) {
        return AgentGridsApiFp(this.configuration).searchRows(requestParameters.agentGridId, requestParameters.workspaceId, requestParameters.agentGridSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApiKeysApi - axios parameter creator
 * @export
 */
export const ApiKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {string} workspaceId 
         * @param {ApiKeyCreateRequest} apiKeyCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey: async (workspaceId: string, apiKeyCreateRequest: ApiKeyCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createApiKey', 'workspaceId', workspaceId)
            // verify required parameter 'apiKeyCreateRequest' is not null or undefined
            assertParamExists('createApiKey', 'apiKeyCreateRequest', apiKeyCreateRequest)
            const localVarPath = `/v2/api_keys/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} apiKeyId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey: async (apiKeyId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyId' is not null or undefined
            assertParamExists('deleteApiKey', 'apiKeyId', apiKeyId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteApiKey', 'workspaceId', workspaceId)
            const localVarPath = `/v2/api_keys/{api_key_id}`
                .replace(`{${"api_key_id"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Api Key
         * @param {string} workspaceId 
         * @param {ApiKeySearchRequest} apiKeySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchApiKey: async (workspaceId: string, apiKeySearchRequest: ApiKeySearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchApiKey', 'workspaceId', workspaceId)
            // verify required parameter 'apiKeySearchRequest' is not null or undefined
            assertParamExists('searchApiKey', 'apiKeySearchRequest', apiKeySearchRequest)
            const localVarPath = `/v2/api_keys/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeySearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Api Key
         * @param {string} apiKeyId 
         * @param {string} workspaceId 
         * @param {ApiKeyUpdateRequest} apiKeyUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey: async (apiKeyId: string, workspaceId: string, apiKeyUpdateRequest: ApiKeyUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyId' is not null or undefined
            assertParamExists('updateApiKey', 'apiKeyId', apiKeyId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateApiKey', 'workspaceId', workspaceId)
            // verify required parameter 'apiKeyUpdateRequest' is not null or undefined
            assertParamExists('updateApiKey', 'apiKeyUpdateRequest', apiKeyUpdateRequest)
            const localVarPath = `/v2/api_keys/{api_key_id}`
                .replace(`{${"api_key_id"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeysApi - functional programming interface
 * @export
 */
export const ApiKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {string} workspaceId 
         * @param {ApiKeyCreateRequest} apiKeyCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKey(workspaceId: string, apiKeyCreateRequest: ApiKeyCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(workspaceId, apiKeyCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.createApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} apiKeyId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKey(apiKeyId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey(apiKeyId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.deleteApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Api Key
         * @param {string} workspaceId 
         * @param {ApiKeySearchRequest} apiKeySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchApiKey(workspaceId: string, apiKeySearchRequest: ApiKeySearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchApiKey(workspaceId, apiKeySearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.searchApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Api Key
         * @param {string} apiKeyId 
         * @param {string} workspaceId 
         * @param {ApiKeyUpdateRequest} apiKeyUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApiKey(apiKeyId: string, workspaceId: string, apiKeyUpdateRequest: ApiKeyUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApiKey(apiKeyId, workspaceId, apiKeyUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.updateApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiKeysApi - factory interface
 * @export
 */
export const ApiKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiKeysApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {ApiKeysApiCreateApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(requestParameters: ApiKeysApiCreateApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyResponse> {
            return localVarFp.createApiKey(requestParameters.workspaceId, requestParameters.apiKeyCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {ApiKeysApiDeleteApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(requestParameters: ApiKeysApiDeleteApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteApiKey(requestParameters.apiKeyId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Api Key
         * @param {ApiKeysApiSearchApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchApiKey(requestParameters: ApiKeysApiSearchApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiKeyResponse>> {
            return localVarFp.searchApiKey(requestParameters.workspaceId, requestParameters.apiKeySearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Api Key
         * @param {ApiKeysApiUpdateApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey(requestParameters: ApiKeysApiUpdateApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyResponse> {
            return localVarFp.updateApiKey(requestParameters.apiKeyId, requestParameters.workspaceId, requestParameters.apiKeyUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeysApi - interface
 * @export
 * @interface ApiKeysApi
 */
export interface ApiKeysApiInterface {
    /**
     * 
     * @summary Create Api Key
     * @param {ApiKeysApiCreateApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApiInterface
     */
    createApiKey(requestParameters: ApiKeysApiCreateApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyResponse>;

    /**
     * 
     * @summary Delete Api Key
     * @param {ApiKeysApiDeleteApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApiInterface
     */
    deleteApiKey(requestParameters: ApiKeysApiDeleteApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Search Api Key
     * @param {ApiKeysApiSearchApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApiInterface
     */
    searchApiKey(requestParameters: ApiKeysApiSearchApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiKeyResponse>>;

    /**
     * 
     * @summary Update Api Key
     * @param {ApiKeysApiUpdateApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApiInterface
     */
    updateApiKey(requestParameters: ApiKeysApiUpdateApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyResponse>;

}

/**
 * Request parameters for createApiKey operation in ApiKeysApi.
 * @export
 * @interface ApiKeysApiCreateApiKeyRequest
 */
export interface ApiKeysApiCreateApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeysApiCreateApiKey
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ApiKeyCreateRequest}
     * @memberof ApiKeysApiCreateApiKey
     */
    readonly apiKeyCreateRequest: ApiKeyCreateRequest
}

/**
 * Request parameters for deleteApiKey operation in ApiKeysApi.
 * @export
 * @interface ApiKeysApiDeleteApiKeyRequest
 */
export interface ApiKeysApiDeleteApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeysApiDeleteApiKey
     */
    readonly apiKeyId: string

    /**
     * 
     * @type {string}
     * @memberof ApiKeysApiDeleteApiKey
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchApiKey operation in ApiKeysApi.
 * @export
 * @interface ApiKeysApiSearchApiKeyRequest
 */
export interface ApiKeysApiSearchApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeysApiSearchApiKey
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ApiKeySearchRequest}
     * @memberof ApiKeysApiSearchApiKey
     */
    readonly apiKeySearchRequest: ApiKeySearchRequest
}

/**
 * Request parameters for updateApiKey operation in ApiKeysApi.
 * @export
 * @interface ApiKeysApiUpdateApiKeyRequest
 */
export interface ApiKeysApiUpdateApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeysApiUpdateApiKey
     */
    readonly apiKeyId: string

    /**
     * 
     * @type {string}
     * @memberof ApiKeysApiUpdateApiKey
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ApiKeyUpdateRequest}
     * @memberof ApiKeysApiUpdateApiKey
     */
    readonly apiKeyUpdateRequest: ApiKeyUpdateRequest
}

/**
 * ApiKeysApi - object-oriented interface
 * @export
 * @class ApiKeysApi
 * @extends {BaseAPI}
 */
export class ApiKeysApi extends BaseAPI implements ApiKeysApiInterface {
    /**
     * 
     * @summary Create Api Key
     * @param {ApiKeysApiCreateApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public createApiKey(requestParameters: ApiKeysApiCreateApiKeyRequest, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).createApiKey(requestParameters.workspaceId, requestParameters.apiKeyCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Key
     * @param {ApiKeysApiDeleteApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public deleteApiKey(requestParameters: ApiKeysApiDeleteApiKeyRequest, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).deleteApiKey(requestParameters.apiKeyId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Api Key
     * @param {ApiKeysApiSearchApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public searchApiKey(requestParameters: ApiKeysApiSearchApiKeyRequest, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).searchApiKey(requestParameters.workspaceId, requestParameters.apiKeySearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Api Key
     * @param {ApiKeysApiUpdateApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public updateApiKey(requestParameters: ApiKeysApiUpdateApiKeyRequest, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).updateApiKey(requestParameters.apiKeyId, requestParameters.workspaceId, requestParameters.apiKeyUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatbotsApi - axios parameter creator
 * @export
 */
export const ChatbotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Chatbot
         * @param {string} workspaceId 
         * @param {ChatbotCreateRequest} chatbotCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatbot: async (workspaceId: string, chatbotCreateRequest: ChatbotCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createChatbot', 'workspaceId', workspaceId)
            // verify required parameter 'chatbotCreateRequest' is not null or undefined
            assertParamExists('createChatbot', 'chatbotCreateRequest', chatbotCreateRequest)
            const localVarPath = `/v2/chatbots/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatbotCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Chatbot
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChatbot: async (chatbotId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatbotId' is not null or undefined
            assertParamExists('deleteChatbot', 'chatbotId', chatbotId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteChatbot', 'workspaceId', workspaceId)
            const localVarPath = `/v2/chatbots/{chatbot_id}`
                .replace(`{${"chatbot_id"}}`, encodeURIComponent(String(chatbotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Chatbot
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatbot: async (chatbotId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatbotId' is not null or undefined
            assertParamExists('getChatbot', 'chatbotId', chatbotId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getChatbot', 'workspaceId', workspaceId)
            const localVarPath = `/v2/chatbots/{chatbot_id}`
                .replace(`{${"chatbot_id"}}`, encodeURIComponent(String(chatbotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Chatbots
         * @param {string} workspaceId 
         * @param {ChatbotSearchRequest} chatbotSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChatbots: async (workspaceId: string, chatbotSearchRequest: ChatbotSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchChatbots', 'workspaceId', workspaceId)
            // verify required parameter 'chatbotSearchRequest' is not null or undefined
            assertParamExists('searchChatbots', 'chatbotSearchRequest', chatbotSearchRequest)
            const localVarPath = `/v2/chatbots/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatbotSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Chatbot
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {ChatbotUpdateRequest} chatbotUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatbot: async (chatbotId: string, workspaceId: string, chatbotUpdateRequest: ChatbotUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatbotId' is not null or undefined
            assertParamExists('updateChatbot', 'chatbotId', chatbotId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateChatbot', 'workspaceId', workspaceId)
            // verify required parameter 'chatbotUpdateRequest' is not null or undefined
            assertParamExists('updateChatbot', 'chatbotUpdateRequest', chatbotUpdateRequest)
            const localVarPath = `/v2/chatbots/{chatbot_id}`
                .replace(`{${"chatbot_id"}}`, encodeURIComponent(String(chatbotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatbotUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatbotsApi - functional programming interface
 * @export
 */
export const ChatbotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatbotsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Chatbot
         * @param {string} workspaceId 
         * @param {ChatbotCreateRequest} chatbotCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChatbot(workspaceId: string, chatbotCreateRequest: ChatbotCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatbotResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChatbot(workspaceId, chatbotCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotsApi.createChatbot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Chatbot
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChatbot(chatbotId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChatbot(chatbotId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotsApi.deleteChatbot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Chatbot
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatbot(chatbotId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatbotResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatbot(chatbotId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotsApi.getChatbot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Chatbots
         * @param {string} workspaceId 
         * @param {ChatbotSearchRequest} chatbotSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchChatbots(workspaceId: string, chatbotSearchRequest: ChatbotSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChatbotResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchChatbots(workspaceId, chatbotSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotsApi.searchChatbots']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Chatbot
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {ChatbotUpdateRequest} chatbotUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChatbot(chatbotId: string, workspaceId: string, chatbotUpdateRequest: ChatbotUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatbotResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChatbot(chatbotId, workspaceId, chatbotUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotsApi.updateChatbot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatbotsApi - factory interface
 * @export
 */
export const ChatbotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatbotsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Chatbot
         * @param {ChatbotsApiCreateChatbotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatbot(requestParameters: ChatbotsApiCreateChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatbotResponse> {
            return localVarFp.createChatbot(requestParameters.workspaceId, requestParameters.chatbotCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Chatbot
         * @param {ChatbotsApiDeleteChatbotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChatbot(requestParameters: ChatbotsApiDeleteChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteChatbot(requestParameters.chatbotId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Chatbot
         * @param {ChatbotsApiGetChatbotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatbot(requestParameters: ChatbotsApiGetChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatbotResponse> {
            return localVarFp.getChatbot(requestParameters.chatbotId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Chatbots
         * @param {ChatbotsApiSearchChatbotsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChatbots(requestParameters: ChatbotsApiSearchChatbotsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ChatbotResponse>> {
            return localVarFp.searchChatbots(requestParameters.workspaceId, requestParameters.chatbotSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Chatbot
         * @param {ChatbotsApiUpdateChatbotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatbot(requestParameters: ChatbotsApiUpdateChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatbotResponse> {
            return localVarFp.updateChatbot(requestParameters.chatbotId, requestParameters.workspaceId, requestParameters.chatbotUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatbotsApi - interface
 * @export
 * @interface ChatbotsApi
 */
export interface ChatbotsApiInterface {
    /**
     * 
     * @summary Create Chatbot
     * @param {ChatbotsApiCreateChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApiInterface
     */
    createChatbot(requestParameters: ChatbotsApiCreateChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatbotResponse>;

    /**
     * 
     * @summary Delete Chatbot
     * @param {ChatbotsApiDeleteChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApiInterface
     */
    deleteChatbot(requestParameters: ChatbotsApiDeleteChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Get Chatbot
     * @param {ChatbotsApiGetChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApiInterface
     */
    getChatbot(requestParameters: ChatbotsApiGetChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatbotResponse>;

    /**
     * 
     * @summary Search Chatbots
     * @param {ChatbotsApiSearchChatbotsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApiInterface
     */
    searchChatbots(requestParameters: ChatbotsApiSearchChatbotsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ChatbotResponse>>;

    /**
     * 
     * @summary Update Chatbot
     * @param {ChatbotsApiUpdateChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApiInterface
     */
    updateChatbot(requestParameters: ChatbotsApiUpdateChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatbotResponse>;

}

/**
 * Request parameters for createChatbot operation in ChatbotsApi.
 * @export
 * @interface ChatbotsApiCreateChatbotRequest
 */
export interface ChatbotsApiCreateChatbotRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiCreateChatbot
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ChatbotCreateRequest}
     * @memberof ChatbotsApiCreateChatbot
     */
    readonly chatbotCreateRequest: ChatbotCreateRequest
}

/**
 * Request parameters for deleteChatbot operation in ChatbotsApi.
 * @export
 * @interface ChatbotsApiDeleteChatbotRequest
 */
export interface ChatbotsApiDeleteChatbotRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiDeleteChatbot
     */
    readonly chatbotId: string

    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiDeleteChatbot
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getChatbot operation in ChatbotsApi.
 * @export
 * @interface ChatbotsApiGetChatbotRequest
 */
export interface ChatbotsApiGetChatbotRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiGetChatbot
     */
    readonly chatbotId: string

    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiGetChatbot
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchChatbots operation in ChatbotsApi.
 * @export
 * @interface ChatbotsApiSearchChatbotsRequest
 */
export interface ChatbotsApiSearchChatbotsRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiSearchChatbots
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ChatbotSearchRequest}
     * @memberof ChatbotsApiSearchChatbots
     */
    readonly chatbotSearchRequest: ChatbotSearchRequest
}

/**
 * Request parameters for updateChatbot operation in ChatbotsApi.
 * @export
 * @interface ChatbotsApiUpdateChatbotRequest
 */
export interface ChatbotsApiUpdateChatbotRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiUpdateChatbot
     */
    readonly chatbotId: string

    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiUpdateChatbot
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ChatbotUpdateRequest}
     * @memberof ChatbotsApiUpdateChatbot
     */
    readonly chatbotUpdateRequest: ChatbotUpdateRequest
}

/**
 * ChatbotsApi - object-oriented interface
 * @export
 * @class ChatbotsApi
 * @extends {BaseAPI}
 */
export class ChatbotsApi extends BaseAPI implements ChatbotsApiInterface {
    /**
     * 
     * @summary Create Chatbot
     * @param {ChatbotsApiCreateChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApi
     */
    public createChatbot(requestParameters: ChatbotsApiCreateChatbotRequest, options?: RawAxiosRequestConfig) {
        return ChatbotsApiFp(this.configuration).createChatbot(requestParameters.workspaceId, requestParameters.chatbotCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Chatbot
     * @param {ChatbotsApiDeleteChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApi
     */
    public deleteChatbot(requestParameters: ChatbotsApiDeleteChatbotRequest, options?: RawAxiosRequestConfig) {
        return ChatbotsApiFp(this.configuration).deleteChatbot(requestParameters.chatbotId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Chatbot
     * @param {ChatbotsApiGetChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApi
     */
    public getChatbot(requestParameters: ChatbotsApiGetChatbotRequest, options?: RawAxiosRequestConfig) {
        return ChatbotsApiFp(this.configuration).getChatbot(requestParameters.chatbotId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Chatbots
     * @param {ChatbotsApiSearchChatbotsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApi
     */
    public searchChatbots(requestParameters: ChatbotsApiSearchChatbotsRequest, options?: RawAxiosRequestConfig) {
        return ChatbotsApiFp(this.configuration).searchChatbots(requestParameters.workspaceId, requestParameters.chatbotSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Chatbot
     * @param {ChatbotsApiUpdateChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApi
     */
    public updateChatbot(requestParameters: ChatbotsApiUpdateChatbotRequest, options?: RawAxiosRequestConfig) {
        return ChatbotsApiFp(this.configuration).updateChatbot(requestParameters.chatbotId, requestParameters.workspaceId, requestParameters.chatbotUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CreditsApi - axios parameter creator
 * @export
 */
export const CreditsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the credit balance for the current user.
         * @summary Get Credit Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditBalance: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get daily credit transactions aggregated for chart display.
         * @summary Get Daily Chart Data
         * @param {string} workspaceId 
         * @param {CreditDailyChartRequest} creditDailyChartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDailyChartData: async (workspaceId: string, creditDailyChartRequest: CreditDailyChartRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getDailyChartData', 'workspaceId', workspaceId)
            // verify required parameter 'creditDailyChartRequest' is not null or undefined
            assertParamExists('getDailyChartData', 'creditDailyChartRequest', creditDailyChartRequest)
            const localVarPath = `/v2/credits/daily/chart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditDailyChartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the credit balance for a workspace.
         * @summary Get Workspace Credit Balance
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceCreditBalance: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceCreditBalance', 'workspaceId', workspaceId)
            const localVarPath = `/v2/credits/workspace_balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for credit transactions based on criteria.
         * @summary Search Credit Transactions
         * @param {string} workspaceId 
         * @param {CreditTransactionSearchRequest} creditTransactionSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCreditTransactions: async (workspaceId: string, creditTransactionSearchRequest: CreditTransactionSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchCreditTransactions', 'workspaceId', workspaceId)
            // verify required parameter 'creditTransactionSearchRequest' is not null or undefined
            assertParamExists('searchCreditTransactions', 'creditTransactionSearchRequest', creditTransactionSearchRequest)
            const localVarPath = `/v2/credits/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditTransactionSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for daily credit transactions based on criteria.
         * @summary Search Daily Credit Transactions
         * @param {string} workspaceId 
         * @param {CreditDailyTransactionSearchRequest} creditDailyTransactionSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDailyCreditTransactions: async (workspaceId: string, creditDailyTransactionSearchRequest: CreditDailyTransactionSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchDailyCreditTransactions', 'workspaceId', workspaceId)
            // verify required parameter 'creditDailyTransactionSearchRequest' is not null or undefined
            assertParamExists('searchDailyCreditTransactions', 'creditDailyTransactionSearchRequest', creditDailyTransactionSearchRequest)
            const localVarPath = `/v2/credits/search_daily`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditDailyTransactionSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditsApi - functional programming interface
 * @export
 */
export const CreditsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the credit balance for the current user.
         * @summary Get Credit Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCreditBalance(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCreditBalance(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.getCreditBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get daily credit transactions aggregated for chart display.
         * @summary Get Daily Chart Data
         * @param {string} workspaceId 
         * @param {CreditDailyChartRequest} creditDailyChartRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDailyChartData(workspaceId: string, creditDailyChartRequest: CreditDailyChartRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditDailyChartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDailyChartData(workspaceId, creditDailyChartRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.getDailyChartData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the credit balance for a workspace.
         * @summary Get Workspace Credit Balance
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceCreditBalance(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceCreditBalance(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.getWorkspaceCreditBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for credit transactions based on criteria.
         * @summary Search Credit Transactions
         * @param {string} workspaceId 
         * @param {CreditTransactionSearchRequest} creditTransactionSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCreditTransactions(workspaceId: string, creditTransactionSearchRequest: CreditTransactionSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreditTransactionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCreditTransactions(workspaceId, creditTransactionSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.searchCreditTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for daily credit transactions based on criteria.
         * @summary Search Daily Credit Transactions
         * @param {string} workspaceId 
         * @param {CreditDailyTransactionSearchRequest} creditDailyTransactionSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDailyCreditTransactions(workspaceId: string, creditDailyTransactionSearchRequest: CreditDailyTransactionSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreditDailyTransactionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDailyCreditTransactions(workspaceId, creditDailyTransactionSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.searchDailyCreditTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CreditsApi - factory interface
 * @export
 */
export const CreditsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditsApiFp(configuration)
    return {
        /**
         * Get the credit balance for the current user.
         * @summary Get Credit Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditBalance(options?: RawAxiosRequestConfig): AxiosPromise<CreditBalanceResponse> {
            return localVarFp.getCreditBalance(options).then((request) => request(axios, basePath));
        },
        /**
         * Get daily credit transactions aggregated for chart display.
         * @summary Get Daily Chart Data
         * @param {CreditsApiGetDailyChartDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDailyChartData(requestParameters: CreditsApiGetDailyChartDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreditDailyChartResponse> {
            return localVarFp.getDailyChartData(requestParameters.workspaceId, requestParameters.creditDailyChartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the credit balance for a workspace.
         * @summary Get Workspace Credit Balance
         * @param {CreditsApiGetWorkspaceCreditBalanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceCreditBalance(requestParameters: CreditsApiGetWorkspaceCreditBalanceRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreditBalanceResponse> {
            return localVarFp.getWorkspaceCreditBalance(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for credit transactions based on criteria.
         * @summary Search Credit Transactions
         * @param {CreditsApiSearchCreditTransactionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCreditTransactions(requestParameters: CreditsApiSearchCreditTransactionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreditTransactionResponse>> {
            return localVarFp.searchCreditTransactions(requestParameters.workspaceId, requestParameters.creditTransactionSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for daily credit transactions based on criteria.
         * @summary Search Daily Credit Transactions
         * @param {CreditsApiSearchDailyCreditTransactionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDailyCreditTransactions(requestParameters: CreditsApiSearchDailyCreditTransactionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreditDailyTransactionResponse>> {
            return localVarFp.searchDailyCreditTransactions(requestParameters.workspaceId, requestParameters.creditDailyTransactionSearchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditsApi - interface
 * @export
 * @interface CreditsApi
 */
export interface CreditsApiInterface {
    /**
     * Get the credit balance for the current user.
     * @summary Get Credit Balance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApiInterface
     */
    getCreditBalance(options?: RawAxiosRequestConfig): AxiosPromise<CreditBalanceResponse>;

    /**
     * Get daily credit transactions aggregated for chart display.
     * @summary Get Daily Chart Data
     * @param {CreditsApiGetDailyChartDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApiInterface
     */
    getDailyChartData(requestParameters: CreditsApiGetDailyChartDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreditDailyChartResponse>;

    /**
     * Get the credit balance for a workspace.
     * @summary Get Workspace Credit Balance
     * @param {CreditsApiGetWorkspaceCreditBalanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApiInterface
     */
    getWorkspaceCreditBalance(requestParameters: CreditsApiGetWorkspaceCreditBalanceRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreditBalanceResponse>;

    /**
     * Search for credit transactions based on criteria.
     * @summary Search Credit Transactions
     * @param {CreditsApiSearchCreditTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApiInterface
     */
    searchCreditTransactions(requestParameters: CreditsApiSearchCreditTransactionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreditTransactionResponse>>;

    /**
     * Search for daily credit transactions based on criteria.
     * @summary Search Daily Credit Transactions
     * @param {CreditsApiSearchDailyCreditTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApiInterface
     */
    searchDailyCreditTransactions(requestParameters: CreditsApiSearchDailyCreditTransactionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreditDailyTransactionResponse>>;

}

/**
 * Request parameters for getDailyChartData operation in CreditsApi.
 * @export
 * @interface CreditsApiGetDailyChartDataRequest
 */
export interface CreditsApiGetDailyChartDataRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditsApiGetDailyChartData
     */
    readonly workspaceId: string

    /**
     * 
     * @type {CreditDailyChartRequest}
     * @memberof CreditsApiGetDailyChartData
     */
    readonly creditDailyChartRequest: CreditDailyChartRequest
}

/**
 * Request parameters for getWorkspaceCreditBalance operation in CreditsApi.
 * @export
 * @interface CreditsApiGetWorkspaceCreditBalanceRequest
 */
export interface CreditsApiGetWorkspaceCreditBalanceRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditsApiGetWorkspaceCreditBalance
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchCreditTransactions operation in CreditsApi.
 * @export
 * @interface CreditsApiSearchCreditTransactionsRequest
 */
export interface CreditsApiSearchCreditTransactionsRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditsApiSearchCreditTransactions
     */
    readonly workspaceId: string

    /**
     * 
     * @type {CreditTransactionSearchRequest}
     * @memberof CreditsApiSearchCreditTransactions
     */
    readonly creditTransactionSearchRequest: CreditTransactionSearchRequest
}

/**
 * Request parameters for searchDailyCreditTransactions operation in CreditsApi.
 * @export
 * @interface CreditsApiSearchDailyCreditTransactionsRequest
 */
export interface CreditsApiSearchDailyCreditTransactionsRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditsApiSearchDailyCreditTransactions
     */
    readonly workspaceId: string

    /**
     * 
     * @type {CreditDailyTransactionSearchRequest}
     * @memberof CreditsApiSearchDailyCreditTransactions
     */
    readonly creditDailyTransactionSearchRequest: CreditDailyTransactionSearchRequest
}

/**
 * CreditsApi - object-oriented interface
 * @export
 * @class CreditsApi
 * @extends {BaseAPI}
 */
export class CreditsApi extends BaseAPI implements CreditsApiInterface {
    /**
     * Get the credit balance for the current user.
     * @summary Get Credit Balance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public getCreditBalance(options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).getCreditBalance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get daily credit transactions aggregated for chart display.
     * @summary Get Daily Chart Data
     * @param {CreditsApiGetDailyChartDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public getDailyChartData(requestParameters: CreditsApiGetDailyChartDataRequest, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).getDailyChartData(requestParameters.workspaceId, requestParameters.creditDailyChartRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the credit balance for a workspace.
     * @summary Get Workspace Credit Balance
     * @param {CreditsApiGetWorkspaceCreditBalanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public getWorkspaceCreditBalance(requestParameters: CreditsApiGetWorkspaceCreditBalanceRequest, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).getWorkspaceCreditBalance(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for credit transactions based on criteria.
     * @summary Search Credit Transactions
     * @param {CreditsApiSearchCreditTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public searchCreditTransactions(requestParameters: CreditsApiSearchCreditTransactionsRequest, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).searchCreditTransactions(requestParameters.workspaceId, requestParameters.creditTransactionSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for daily credit transactions based on criteria.
     * @summary Search Daily Credit Transactions
     * @param {CreditsApiSearchDailyCreditTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public searchDailyCreditTransactions(requestParameters: CreditsApiSearchDailyCreditTransactionsRequest, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).searchDailyCreditTransactions(requestParameters.workspaceId, requestParameters.creditDailyTransactionSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Document Category
         * @param {string} workspaceId 
         * @param {DocumentCategoryCreateRequest} documentCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentCategory: async (workspaceId: string, documentCategoryCreateRequest: DocumentCategoryCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createDocumentCategory', 'workspaceId', workspaceId)
            // verify required parameter 'documentCategoryCreateRequest' is not null or undefined
            assertParamExists('createDocumentCategory', 'documentCategoryCreateRequest', documentCategoryCreateRequest)
            const localVarPath = `/v2/documents/categories/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentCategoryCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Faq
         * @param {string} workspaceId 
         * @param {FaqCreateRequest} faqCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFaq: async (workspaceId: string, faqCreateRequest: FaqCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createFaq', 'workspaceId', workspaceId)
            // verify required parameter 'faqCreateRequest' is not null or undefined
            assertParamExists('createFaq', 'faqCreateRequest', faqCreateRequest)
            const localVarPath = `/v2/documents/faqs/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(faqCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument: async (docId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('deleteDocument', 'docId', docId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteDocument', 'workspaceId', workspaceId)
            const localVarPath = `/v2/documents/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Document Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentCategory: async (catId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('deleteDocumentCategory', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteDocumentCategory', 'workspaceId', workspaceId)
            const localVarPath = `/v2/documents/categories/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Faq
         * @param {string} faqId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFaq: async (faqId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'faqId' is not null or undefined
            assertParamExists('deleteFaq', 'faqId', faqId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteFaq', 'workspaceId', workspaceId)
            const localVarPath = `/v2/documents/faqs/{faq_id}`
                .replace(`{${"faq_id"}}`, encodeURIComponent(String(faqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Binary Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBinaryDocument: async (docId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('downloadBinaryDocument', 'docId', docId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('downloadBinaryDocument', 'workspaceId', workspaceId)
            const localVarPath = `/v2/documents/download/binary/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Text Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTextDocument: async (docId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('downloadTextDocument', 'docId', docId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('downloadTextDocument', 'workspaceId', workspaceId)
            const localVarPath = `/v2/documents/download/text/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Faq
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFaq: async (workspaceId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('importFaq', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('importFaq', 'file', file)
            const localVarPath = `/v2/documents/faqs/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Document Categories
         * @param {string} workspaceId 
         * @param {DocumentCategorySearchRequest} documentCategorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocumentCategories: async (workspaceId: string, documentCategorySearchRequest: DocumentCategorySearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchDocumentCategories', 'workspaceId', workspaceId)
            // verify required parameter 'documentCategorySearchRequest' is not null or undefined
            assertParamExists('searchDocumentCategories', 'documentCategorySearchRequest', documentCategorySearchRequest)
            const localVarPath = `/v2/documents/categories/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentCategorySearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Documents
         * @param {string} workspaceId 
         * @param {DocumentSearchRequest} documentSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocuments: async (workspaceId: string, documentSearchRequest: DocumentSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchDocuments', 'workspaceId', workspaceId)
            // verify required parameter 'documentSearchRequest' is not null or undefined
            assertParamExists('searchDocuments', 'documentSearchRequest', documentSearchRequest)
            const localVarPath = `/v2/documents/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Faqs
         * @param {string} workspaceId 
         * @param {FaqSearchRequest} faqSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFaqs: async (workspaceId: string, faqSearchRequest: FaqSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchFaqs', 'workspaceId', workspaceId)
            // verify required parameter 'faqSearchRequest' is not null or undefined
            assertParamExists('searchFaqs', 'faqSearchRequest', faqSearchRequest)
            const localVarPath = `/v2/documents/faqs/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(faqSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {DocumentUpdateRequest} documentUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocument: async (docId: string, workspaceId: string, documentUpdateRequest: DocumentUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('updateDocument', 'docId', docId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateDocument', 'workspaceId', workspaceId)
            // verify required parameter 'documentUpdateRequest' is not null or undefined
            assertParamExists('updateDocument', 'documentUpdateRequest', documentUpdateRequest)
            const localVarPath = `/v2/documents/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Document Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {DocumentCategoryUpdateRequest} documentCategoryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentCategory: async (catId: string, workspaceId: string, documentCategoryUpdateRequest: DocumentCategoryUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('updateDocumentCategory', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateDocumentCategory', 'workspaceId', workspaceId)
            // verify required parameter 'documentCategoryUpdateRequest' is not null or undefined
            assertParamExists('updateDocumentCategory', 'documentCategoryUpdateRequest', documentCategoryUpdateRequest)
            const localVarPath = `/v2/documents/categories/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentCategoryUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Faq
         * @param {string} faqId 
         * @param {string} workspaceId 
         * @param {FaqUpdateRequest} faqUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFaq: async (faqId: string, workspaceId: string, faqUpdateRequest: FaqUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'faqId' is not null or undefined
            assertParamExists('updateFaq', 'faqId', faqId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateFaq', 'workspaceId', workspaceId)
            // verify required parameter 'faqUpdateRequest' is not null or undefined
            assertParamExists('updateFaq', 'faqUpdateRequest', faqUpdateRequest)
            const localVarPath = `/v2/documents/faqs/{faq_id}`
                .replace(`{${"faq_id"}}`, encodeURIComponent(String(faqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(faqUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload From Url Document
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {AppUrlInput} appUrlInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFromUrlDocument: async (catId: string, workspaceId: string, appUrlInput: AppUrlInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('uploadFromUrlDocument', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('uploadFromUrlDocument', 'workspaceId', workspaceId)
            // verify required parameter 'appUrlInput' is not null or undefined
            assertParamExists('uploadFromUrlDocument', 'appUrlInput', appUrlInput)
            const localVarPath = `/v2/documents/upload-from-url/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appUrlInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Memory Document
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMemoryDocument: async (catId: string, workspaceId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('uploadMemoryDocument', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('uploadMemoryDocument', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadMemoryDocument', 'file', file)
            const localVarPath = `/v2/documents/upload/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Document Category
         * @param {string} workspaceId 
         * @param {DocumentCategoryCreateRequest} documentCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDocumentCategory(workspaceId: string, documentCategoryCreateRequest: DocumentCategoryCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDocumentCategory(workspaceId, documentCategoryCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.createDocumentCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Faq
         * @param {string} workspaceId 
         * @param {FaqCreateRequest} faqCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFaq(workspaceId: string, faqCreateRequest: FaqCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FaqResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFaq(workspaceId, faqCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.createFaq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocument(docId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocument(docId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.deleteDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Document Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocumentCategory(catId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocumentCategory(catId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.deleteDocumentCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Faq
         * @param {string} faqId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFaq(faqId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFaq(faqId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.deleteFaq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download Binary Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadBinaryDocument(docId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadBinaryDocument(docId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.downloadBinaryDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download Text Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTextDocument(docId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTextDocument(docId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.downloadTextDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Import Faq
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importFaq(workspaceId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaqImportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importFaq(workspaceId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.importFaq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Document Categories
         * @param {string} workspaceId 
         * @param {DocumentCategorySearchRequest} documentCategorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDocumentCategories(workspaceId: string, documentCategorySearchRequest: DocumentCategorySearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentCategoryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDocumentCategories(workspaceId, documentCategorySearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.searchDocumentCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Documents
         * @param {string} workspaceId 
         * @param {DocumentSearchRequest} documentSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDocuments(workspaceId: string, documentSearchRequest: DocumentSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDocuments(workspaceId, documentSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.searchDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Faqs
         * @param {string} workspaceId 
         * @param {FaqSearchRequest} faqSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchFaqs(workspaceId: string, faqSearchRequest: FaqSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FaqResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFaqs(workspaceId, faqSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.searchFaqs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {DocumentUpdateRequest} documentUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDocument(docId: string, workspaceId: string, documentUpdateRequest: DocumentUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDocument(docId, workspaceId, documentUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.updateDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Document Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {DocumentCategoryUpdateRequest} documentCategoryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDocumentCategory(catId: string, workspaceId: string, documentCategoryUpdateRequest: DocumentCategoryUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDocumentCategory(catId, workspaceId, documentCategoryUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.updateDocumentCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Faq
         * @param {string} faqId 
         * @param {string} workspaceId 
         * @param {FaqUpdateRequest} faqUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFaq(faqId: string, workspaceId: string, faqUpdateRequest: FaqUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FaqResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFaq(faqId, workspaceId, faqUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.updateFaq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload From Url Document
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {AppUrlInput} appUrlInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFromUrlDocument(catId: string, workspaceId: string, appUrlInput: AppUrlInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFromUrlDocument(catId, workspaceId, appUrlInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.uploadFromUrlDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Memory Document
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadMemoryDocument(catId: string, workspaceId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadMemoryDocument(catId, workspaceId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.uploadMemoryDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Document Category
         * @param {DocumentsApiCreateDocumentCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentCategory(requestParameters: DocumentsApiCreateDocumentCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentCategoryResponse> {
            return localVarFp.createDocumentCategory(requestParameters.workspaceId, requestParameters.documentCategoryCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Faq
         * @param {DocumentsApiCreateFaqRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFaq(requestParameters: DocumentsApiCreateFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FaqResponse>> {
            return localVarFp.createFaq(requestParameters.workspaceId, requestParameters.faqCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Document
         * @param {DocumentsApiDeleteDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument(requestParameters: DocumentsApiDeleteDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteDocument(requestParameters.docId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Document Category
         * @param {DocumentsApiDeleteDocumentCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentCategory(requestParameters: DocumentsApiDeleteDocumentCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteDocumentCategory(requestParameters.catId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Faq
         * @param {DocumentsApiDeleteFaqRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFaq(requestParameters: DocumentsApiDeleteFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteFaq(requestParameters.faqId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Binary Document
         * @param {DocumentsApiDownloadBinaryDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBinaryDocument(requestParameters: DocumentsApiDownloadBinaryDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.downloadBinaryDocument(requestParameters.docId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Text Document
         * @param {DocumentsApiDownloadTextDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTextDocument(requestParameters: DocumentsApiDownloadTextDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentContent> {
            return localVarFp.downloadTextDocument(requestParameters.docId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import Faq
         * @param {DocumentsApiImportFaqRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFaq(requestParameters: DocumentsApiImportFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<FaqImportResponse> {
            return localVarFp.importFaq(requestParameters.workspaceId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Document Categories
         * @param {DocumentsApiSearchDocumentCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocumentCategories(requestParameters: DocumentsApiSearchDocumentCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<DocumentCategoryResponse>> {
            return localVarFp.searchDocumentCategories(requestParameters.workspaceId, requestParameters.documentCategorySearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Documents
         * @param {DocumentsApiSearchDocumentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocuments(requestParameters: DocumentsApiSearchDocumentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<DocumentResponse>> {
            return localVarFp.searchDocuments(requestParameters.workspaceId, requestParameters.documentSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Faqs
         * @param {DocumentsApiSearchFaqsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFaqs(requestParameters: DocumentsApiSearchFaqsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FaqResponse>> {
            return localVarFp.searchFaqs(requestParameters.workspaceId, requestParameters.faqSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Document
         * @param {DocumentsApiUpdateDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocument(requestParameters: DocumentsApiUpdateDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse> {
            return localVarFp.updateDocument(requestParameters.docId, requestParameters.workspaceId, requestParameters.documentUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Document Category
         * @param {DocumentsApiUpdateDocumentCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentCategory(requestParameters: DocumentsApiUpdateDocumentCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentCategoryResponse> {
            return localVarFp.updateDocumentCategory(requestParameters.catId, requestParameters.workspaceId, requestParameters.documentCategoryUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Faq
         * @param {DocumentsApiUpdateFaqRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFaq(requestParameters: DocumentsApiUpdateFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FaqResponse>> {
            return localVarFp.updateFaq(requestParameters.faqId, requestParameters.workspaceId, requestParameters.faqUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload From Url Document
         * @param {DocumentsApiUploadFromUrlDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFromUrlDocument(requestParameters: DocumentsApiUploadFromUrlDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse> {
            return localVarFp.uploadFromUrlDocument(requestParameters.catId, requestParameters.workspaceId, requestParameters.appUrlInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Memory Document
         * @param {DocumentsApiUploadMemoryDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMemoryDocument(requestParameters: DocumentsApiUploadMemoryDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse> {
            return localVarFp.uploadMemoryDocument(requestParameters.catId, requestParameters.workspaceId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - interface
 * @export
 * @interface DocumentsApi
 */
export interface DocumentsApiInterface {
    /**
     * 
     * @summary Create Document Category
     * @param {DocumentsApiCreateDocumentCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    createDocumentCategory(requestParameters: DocumentsApiCreateDocumentCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentCategoryResponse>;

    /**
     * 
     * @summary Create Faq
     * @param {DocumentsApiCreateFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    createFaq(requestParameters: DocumentsApiCreateFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FaqResponse>>;

    /**
     * 
     * @summary Delete Document
     * @param {DocumentsApiDeleteDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    deleteDocument(requestParameters: DocumentsApiDeleteDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Delete Document Category
     * @param {DocumentsApiDeleteDocumentCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    deleteDocumentCategory(requestParameters: DocumentsApiDeleteDocumentCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Delete Faq
     * @param {DocumentsApiDeleteFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    deleteFaq(requestParameters: DocumentsApiDeleteFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Download Binary Document
     * @param {DocumentsApiDownloadBinaryDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    downloadBinaryDocument(requestParameters: DocumentsApiDownloadBinaryDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Download Text Document
     * @param {DocumentsApiDownloadTextDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    downloadTextDocument(requestParameters: DocumentsApiDownloadTextDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentContent>;

    /**
     * 
     * @summary Import Faq
     * @param {DocumentsApiImportFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    importFaq(requestParameters: DocumentsApiImportFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<FaqImportResponse>;

    /**
     * 
     * @summary Search Document Categories
     * @param {DocumentsApiSearchDocumentCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    searchDocumentCategories(requestParameters: DocumentsApiSearchDocumentCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<DocumentCategoryResponse>>;

    /**
     * 
     * @summary Search Documents
     * @param {DocumentsApiSearchDocumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    searchDocuments(requestParameters: DocumentsApiSearchDocumentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<DocumentResponse>>;

    /**
     * 
     * @summary Search Faqs
     * @param {DocumentsApiSearchFaqsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    searchFaqs(requestParameters: DocumentsApiSearchFaqsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FaqResponse>>;

    /**
     * 
     * @summary Update Document
     * @param {DocumentsApiUpdateDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    updateDocument(requestParameters: DocumentsApiUpdateDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse>;

    /**
     * 
     * @summary Update Document Category
     * @param {DocumentsApiUpdateDocumentCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    updateDocumentCategory(requestParameters: DocumentsApiUpdateDocumentCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentCategoryResponse>;

    /**
     * 
     * @summary Update Faq
     * @param {DocumentsApiUpdateFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    updateFaq(requestParameters: DocumentsApiUpdateFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FaqResponse>>;

    /**
     * 
     * @summary Upload From Url Document
     * @param {DocumentsApiUploadFromUrlDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    uploadFromUrlDocument(requestParameters: DocumentsApiUploadFromUrlDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse>;

    /**
     * 
     * @summary Upload Memory Document
     * @param {DocumentsApiUploadMemoryDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    uploadMemoryDocument(requestParameters: DocumentsApiUploadMemoryDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse>;

}

/**
 * Request parameters for createDocumentCategory operation in DocumentsApi.
 * @export
 * @interface DocumentsApiCreateDocumentCategoryRequest
 */
export interface DocumentsApiCreateDocumentCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiCreateDocumentCategory
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DocumentCategoryCreateRequest}
     * @memberof DocumentsApiCreateDocumentCategory
     */
    readonly documentCategoryCreateRequest: DocumentCategoryCreateRequest
}

/**
 * Request parameters for createFaq operation in DocumentsApi.
 * @export
 * @interface DocumentsApiCreateFaqRequest
 */
export interface DocumentsApiCreateFaqRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiCreateFaq
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FaqCreateRequest}
     * @memberof DocumentsApiCreateFaq
     */
    readonly faqCreateRequest: FaqCreateRequest
}

/**
 * Request parameters for deleteDocument operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDeleteDocumentRequest
 */
export interface DocumentsApiDeleteDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDeleteDocument
     */
    readonly docId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDeleteDocument
     */
    readonly workspaceId: string
}

/**
 * Request parameters for deleteDocumentCategory operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDeleteDocumentCategoryRequest
 */
export interface DocumentsApiDeleteDocumentCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDeleteDocumentCategory
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDeleteDocumentCategory
     */
    readonly workspaceId: string
}

/**
 * Request parameters for deleteFaq operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDeleteFaqRequest
 */
export interface DocumentsApiDeleteFaqRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDeleteFaq
     */
    readonly faqId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDeleteFaq
     */
    readonly workspaceId: string
}

/**
 * Request parameters for downloadBinaryDocument operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDownloadBinaryDocumentRequest
 */
export interface DocumentsApiDownloadBinaryDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDownloadBinaryDocument
     */
    readonly docId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDownloadBinaryDocument
     */
    readonly workspaceId: string
}

/**
 * Request parameters for downloadTextDocument operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDownloadTextDocumentRequest
 */
export interface DocumentsApiDownloadTextDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDownloadTextDocument
     */
    readonly docId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDownloadTextDocument
     */
    readonly workspaceId: string
}

/**
 * Request parameters for importFaq operation in DocumentsApi.
 * @export
 * @interface DocumentsApiImportFaqRequest
 */
export interface DocumentsApiImportFaqRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiImportFaq
     */
    readonly workspaceId: string

    /**
     * 
     * @type {File}
     * @memberof DocumentsApiImportFaq
     */
    readonly file: File
}

/**
 * Request parameters for searchDocumentCategories operation in DocumentsApi.
 * @export
 * @interface DocumentsApiSearchDocumentCategoriesRequest
 */
export interface DocumentsApiSearchDocumentCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiSearchDocumentCategories
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DocumentCategorySearchRequest}
     * @memberof DocumentsApiSearchDocumentCategories
     */
    readonly documentCategorySearchRequest: DocumentCategorySearchRequest
}

/**
 * Request parameters for searchDocuments operation in DocumentsApi.
 * @export
 * @interface DocumentsApiSearchDocumentsRequest
 */
export interface DocumentsApiSearchDocumentsRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiSearchDocuments
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DocumentSearchRequest}
     * @memberof DocumentsApiSearchDocuments
     */
    readonly documentSearchRequest: DocumentSearchRequest
}

/**
 * Request parameters for searchFaqs operation in DocumentsApi.
 * @export
 * @interface DocumentsApiSearchFaqsRequest
 */
export interface DocumentsApiSearchFaqsRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiSearchFaqs
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FaqSearchRequest}
     * @memberof DocumentsApiSearchFaqs
     */
    readonly faqSearchRequest: FaqSearchRequest
}

/**
 * Request parameters for updateDocument operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUpdateDocumentRequest
 */
export interface DocumentsApiUpdateDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUpdateDocument
     */
    readonly docId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUpdateDocument
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DocumentUpdateRequest}
     * @memberof DocumentsApiUpdateDocument
     */
    readonly documentUpdateRequest: DocumentUpdateRequest
}

/**
 * Request parameters for updateDocumentCategory operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUpdateDocumentCategoryRequest
 */
export interface DocumentsApiUpdateDocumentCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUpdateDocumentCategory
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUpdateDocumentCategory
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DocumentCategoryUpdateRequest}
     * @memberof DocumentsApiUpdateDocumentCategory
     */
    readonly documentCategoryUpdateRequest: DocumentCategoryUpdateRequest
}

/**
 * Request parameters for updateFaq operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUpdateFaqRequest
 */
export interface DocumentsApiUpdateFaqRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUpdateFaq
     */
    readonly faqId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUpdateFaq
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FaqUpdateRequest}
     * @memberof DocumentsApiUpdateFaq
     */
    readonly faqUpdateRequest: FaqUpdateRequest
}

/**
 * Request parameters for uploadFromUrlDocument operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUploadFromUrlDocumentRequest
 */
export interface DocumentsApiUploadFromUrlDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUploadFromUrlDocument
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUploadFromUrlDocument
     */
    readonly workspaceId: string

    /**
     * 
     * @type {AppUrlInput}
     * @memberof DocumentsApiUploadFromUrlDocument
     */
    readonly appUrlInput: AppUrlInput
}

/**
 * Request parameters for uploadMemoryDocument operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUploadMemoryDocumentRequest
 */
export interface DocumentsApiUploadMemoryDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUploadMemoryDocument
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUploadMemoryDocument
     */
    readonly workspaceId: string

    /**
     * 
     * @type {File}
     * @memberof DocumentsApiUploadMemoryDocument
     */
    readonly file: File
}

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI implements DocumentsApiInterface {
    /**
     * 
     * @summary Create Document Category
     * @param {DocumentsApiCreateDocumentCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public createDocumentCategory(requestParameters: DocumentsApiCreateDocumentCategoryRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).createDocumentCategory(requestParameters.workspaceId, requestParameters.documentCategoryCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Faq
     * @param {DocumentsApiCreateFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public createFaq(requestParameters: DocumentsApiCreateFaqRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).createFaq(requestParameters.workspaceId, requestParameters.faqCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Document
     * @param {DocumentsApiDeleteDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public deleteDocument(requestParameters: DocumentsApiDeleteDocumentRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).deleteDocument(requestParameters.docId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Document Category
     * @param {DocumentsApiDeleteDocumentCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public deleteDocumentCategory(requestParameters: DocumentsApiDeleteDocumentCategoryRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).deleteDocumentCategory(requestParameters.catId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Faq
     * @param {DocumentsApiDeleteFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public deleteFaq(requestParameters: DocumentsApiDeleteFaqRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).deleteFaq(requestParameters.faqId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Binary Document
     * @param {DocumentsApiDownloadBinaryDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public downloadBinaryDocument(requestParameters: DocumentsApiDownloadBinaryDocumentRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).downloadBinaryDocument(requestParameters.docId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Text Document
     * @param {DocumentsApiDownloadTextDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public downloadTextDocument(requestParameters: DocumentsApiDownloadTextDocumentRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).downloadTextDocument(requestParameters.docId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import Faq
     * @param {DocumentsApiImportFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public importFaq(requestParameters: DocumentsApiImportFaqRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).importFaq(requestParameters.workspaceId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Document Categories
     * @param {DocumentsApiSearchDocumentCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public searchDocumentCategories(requestParameters: DocumentsApiSearchDocumentCategoriesRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).searchDocumentCategories(requestParameters.workspaceId, requestParameters.documentCategorySearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Documents
     * @param {DocumentsApiSearchDocumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public searchDocuments(requestParameters: DocumentsApiSearchDocumentsRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).searchDocuments(requestParameters.workspaceId, requestParameters.documentSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Faqs
     * @param {DocumentsApiSearchFaqsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public searchFaqs(requestParameters: DocumentsApiSearchFaqsRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).searchFaqs(requestParameters.workspaceId, requestParameters.faqSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Document
     * @param {DocumentsApiUpdateDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public updateDocument(requestParameters: DocumentsApiUpdateDocumentRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).updateDocument(requestParameters.docId, requestParameters.workspaceId, requestParameters.documentUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Document Category
     * @param {DocumentsApiUpdateDocumentCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public updateDocumentCategory(requestParameters: DocumentsApiUpdateDocumentCategoryRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).updateDocumentCategory(requestParameters.catId, requestParameters.workspaceId, requestParameters.documentCategoryUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Faq
     * @param {DocumentsApiUpdateFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public updateFaq(requestParameters: DocumentsApiUpdateFaqRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).updateFaq(requestParameters.faqId, requestParameters.workspaceId, requestParameters.faqUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload From Url Document
     * @param {DocumentsApiUploadFromUrlDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public uploadFromUrlDocument(requestParameters: DocumentsApiUploadFromUrlDocumentRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).uploadFromUrlDocument(requestParameters.catId, requestParameters.workspaceId, requestParameters.appUrlInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Memory Document
     * @param {DocumentsApiUploadMemoryDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public uploadMemoryDocument(requestParameters: DocumentsApiUploadMemoryDocumentRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).uploadMemoryDocument(requestParameters.catId, requestParameters.workspaceId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FineTuningsApi - axios parameter creator
 * @export
 */
export const FineTuningsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Image Ft
         * @param {string} workspaceId 
         * @param {ImageFTCreateRequest} imageFTCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageFt: async (workspaceId: string, imageFTCreateRequest: ImageFTCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createImageFt', 'workspaceId', workspaceId)
            // verify required parameter 'imageFTCreateRequest' is not null or undefined
            assertParamExists('createImageFt', 'imageFTCreateRequest', imageFTCreateRequest)
            const localVarPath = `/v2/photo_ai/images/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageFTCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete File Ft
         * @param {string} fileKey 
         * @param {string} workspaceId 
         * @param {InferenceFileType} fileType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileFt: async (fileKey: string, workspaceId: string, fileType: InferenceFileType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileKey' is not null or undefined
            assertParamExists('deleteFileFt', 'fileKey', fileKey)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteFileFt', 'workspaceId', workspaceId)
            // verify required parameter 'fileType' is not null or undefined
            assertParamExists('deleteFileFt', 'fileType', fileType)
            const localVarPath = `/v2/photo_ai/files/{file_key}`
                .replace(`{${"file_key"}}`, encodeURIComponent(String(fileKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (fileType !== undefined) {
                localVarQueryParameter['file_type'] = fileType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Image Ft
         * @param {string} ftId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImageFt: async (ftId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ftId' is not null or undefined
            assertParamExists('deleteImageFt', 'ftId', ftId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteImageFt', 'workspaceId', workspaceId)
            const localVarPath = `/v2/photo_ai/images/{ft_id}`
                .replace(`{${"ft_id"}}`, encodeURIComponent(String(ftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate Image Prompt
         * @param {string} workspaceId 
         * @param {ImagePromptGenerationRequest} imagePromptGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateImagePrompt: async (workspaceId: string, imagePromptGenerationRequest: ImagePromptGenerationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('generateImagePrompt', 'workspaceId', workspaceId)
            // verify required parameter 'imagePromptGenerationRequest' is not null or undefined
            assertParamExists('generateImagePrompt', 'imagePromptGenerationRequest', imagePromptGenerationRequest)
            const localVarPath = `/v2/photo_ai/inference/images/generate-prompt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imagePromptGenerationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate Images
         * @param {string} workspaceId 
         * @param {ImageInferenceRequest} imageInferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateImages: async (workspaceId: string, imageInferenceRequest: ImageInferenceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('generateImages', 'workspaceId', workspaceId)
            // verify required parameter 'imageInferenceRequest' is not null or undefined
            assertParamExists('generateImages', 'imageInferenceRequest', imageInferenceRequest)
            const localVarPath = `/v2/photo_ai/inference/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageInferenceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get File Ft
         * @param {string} fileKey 
         * @param {string} workspaceId 
         * @param {InferenceFileType} fileType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileFt: async (fileKey: string, workspaceId: string, fileType: InferenceFileType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileKey' is not null or undefined
            assertParamExists('getFileFt', 'fileKey', fileKey)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getFileFt', 'workspaceId', workspaceId)
            // verify required parameter 'fileType' is not null or undefined
            assertParamExists('getFileFt', 'fileType', fileType)
            const localVarPath = `/v2/photo_ai/files/{file_key}`
                .replace(`{${"file_key"}}`, encodeURIComponent(String(fileKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (fileType !== undefined) {
                localVarQueryParameter['file_type'] = fileType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Inference Results
         * @param {string} inferenceId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInferenceResults: async (inferenceId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inferenceId' is not null or undefined
            assertParamExists('getInferenceResults', 'inferenceId', inferenceId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getInferenceResults', 'workspaceId', workspaceId)
            const localVarPath = `/v2/photo_ai/inference/results/{inference_id}`
                .replace(`{${"inference_id"}}`, encodeURIComponent(String(inferenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Handle Replicate Webhook
         * @param {string} workspaceId 
         * @param {string} ftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleReplicateWebhook: async (workspaceId: string, ftId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('handleReplicateWebhook', 'workspaceId', workspaceId)
            // verify required parameter 'ftId' is not null or undefined
            assertParamExists('handleReplicateWebhook', 'ftId', ftId)
            const localVarPath = `/v2/photo_ai/webhooks/replicate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (ftId !== undefined) {
                localVarQueryParameter['ft_id'] = ftId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Image Fts
         * @param {string} workspaceId 
         * @param {ImageFTSearchRequest} imageFTSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchImageFts: async (workspaceId: string, imageFTSearchRequest: ImageFTSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchImageFts', 'workspaceId', workspaceId)
            // verify required parameter 'imageFTSearchRequest' is not null or undefined
            assertParamExists('searchImageFts', 'imageFTSearchRequest', imageFTSearchRequest)
            const localVarPath = `/v2/photo_ai/images/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageFTSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Inference History
         * @param {string} workspaceId 
         * @param {InferenceHistorySearchRequest} inferenceHistorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInferenceHistory: async (workspaceId: string, inferenceHistorySearchRequest: InferenceHistorySearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchInferenceHistory', 'workspaceId', workspaceId)
            // verify required parameter 'inferenceHistorySearchRequest' is not null or undefined
            assertParamExists('searchInferenceHistory', 'inferenceHistorySearchRequest', inferenceHistorySearchRequest)
            const localVarPath = `/v2/photo_ai/inference/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inferenceHistorySearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Image Ft
         * @param {string} ftId 
         * @param {string} workspaceId 
         * @param {ImageFTUpdateRequest} imageFTUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImageFt: async (ftId: string, workspaceId: string, imageFTUpdateRequest: ImageFTUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ftId' is not null or undefined
            assertParamExists('updateImageFt', 'ftId', ftId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateImageFt', 'workspaceId', workspaceId)
            // verify required parameter 'imageFTUpdateRequest' is not null or undefined
            assertParamExists('updateImageFt', 'imageFTUpdateRequest', imageFTUpdateRequest)
            const localVarPath = `/v2/photo_ai/images/{ft_id}`
                .replace(`{${"ft_id"}}`, encodeURIComponent(String(ftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageFTUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Image Ft
         * @param {FTType} ftType 
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImageFt: async (ftType: FTType, workspaceId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ftType' is not null or undefined
            assertParamExists('uploadImageFt', 'ftType', ftType)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('uploadImageFt', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadImageFt', 'file', file)
            const localVarPath = `/v2/photo_ai/files/{ft_type}/upload`
                .replace(`{${"ft_type"}}`, encodeURIComponent(String(ftType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FineTuningsApi - functional programming interface
 * @export
 */
export const FineTuningsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FineTuningsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Image Ft
         * @param {string} workspaceId 
         * @param {ImageFTCreateRequest} imageFTCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImageFt(workspaceId: string, imageFTCreateRequest: ImageFTCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageFTResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImageFt(workspaceId, imageFTCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.createImageFt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete File Ft
         * @param {string} fileKey 
         * @param {string} workspaceId 
         * @param {InferenceFileType} fileType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileFt(fileKey: string, workspaceId: string, fileType: InferenceFileType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileFt(fileKey, workspaceId, fileType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.deleteFileFt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Image Ft
         * @param {string} ftId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteImageFt(ftId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImageFt(ftId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.deleteImageFt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate Image Prompt
         * @param {string} workspaceId 
         * @param {ImagePromptGenerationRequest} imagePromptGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateImagePrompt(workspaceId: string, imagePromptGenerationRequest: ImagePromptGenerationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImagePromptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateImagePrompt(workspaceId, imagePromptGenerationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.generateImagePrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate Images
         * @param {string} workspaceId 
         * @param {ImageInferenceRequest} imageInferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateImages(workspaceId: string, imageInferenceRequest: ImageInferenceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageInferenceScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateImages(workspaceId, imageInferenceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.generateImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get File Ft
         * @param {string} fileKey 
         * @param {string} workspaceId 
         * @param {InferenceFileType} fileType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileFt(fileKey: string, workspaceId: string, fileType: InferenceFileType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileFt(fileKey, workspaceId, fileType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.getFileFt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Inference Results
         * @param {string} inferenceId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInferenceResults(inferenceId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageInferenceResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInferenceResults(inferenceId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.getInferenceResults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Handle Replicate Webhook
         * @param {string} workspaceId 
         * @param {string} ftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleReplicateWebhook(workspaceId: string, ftId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleReplicateWebhook(workspaceId, ftId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.handleReplicateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Image Fts
         * @param {string} workspaceId 
         * @param {ImageFTSearchRequest} imageFTSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchImageFts(workspaceId: string, imageFTSearchRequest: ImageFTSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageFTResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchImageFts(workspaceId, imageFTSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.searchImageFts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Inference History
         * @param {string} workspaceId 
         * @param {InferenceHistorySearchRequest} inferenceHistorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInferenceHistory(workspaceId: string, inferenceHistorySearchRequest: InferenceHistorySearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageInferenceScrollResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInferenceHistory(workspaceId, inferenceHistorySearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.searchInferenceHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Image Ft
         * @param {string} ftId 
         * @param {string} workspaceId 
         * @param {ImageFTUpdateRequest} imageFTUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateImageFt(ftId: string, workspaceId: string, imageFTUpdateRequest: ImageFTUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageFTResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateImageFt(ftId, workspaceId, imageFTUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.updateImageFt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Image Ft
         * @param {FTType} ftType 
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadImageFt(ftType: FTType, workspaceId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadImageFt(ftType, workspaceId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.uploadImageFt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FineTuningsApi - factory interface
 * @export
 */
export const FineTuningsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FineTuningsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Image Ft
         * @param {FineTuningsApiCreateImageFtRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageFt(requestParameters: FineTuningsApiCreateImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageFTResponse> {
            return localVarFp.createImageFt(requestParameters.workspaceId, requestParameters.imageFTCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete File Ft
         * @param {FineTuningsApiDeleteFileFtRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileFt(requestParameters: FineTuningsApiDeleteFileFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteFileFt(requestParameters.fileKey, requestParameters.workspaceId, requestParameters.fileType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Image Ft
         * @param {FineTuningsApiDeleteImageFtRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImageFt(requestParameters: FineTuningsApiDeleteImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteImageFt(requestParameters.ftId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate Image Prompt
         * @param {FineTuningsApiGenerateImagePromptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateImagePrompt(requestParameters: FineTuningsApiGenerateImagePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImagePromptResponse> {
            return localVarFp.generateImagePrompt(requestParameters.workspaceId, requestParameters.imagePromptGenerationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate Images
         * @param {FineTuningsApiGenerateImagesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateImages(requestParameters: FineTuningsApiGenerateImagesRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageInferenceScheduleResponse> {
            return localVarFp.generateImages(requestParameters.workspaceId, requestParameters.imageInferenceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get File Ft
         * @param {FineTuningsApiGetFileFtRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileFt(requestParameters: FineTuningsApiGetFileFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getFileFt(requestParameters.fileKey, requestParameters.workspaceId, requestParameters.fileType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Inference Results
         * @param {FineTuningsApiGetInferenceResultsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInferenceResults(requestParameters: FineTuningsApiGetInferenceResultsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageInferenceResultResponse> {
            return localVarFp.getInferenceResults(requestParameters.inferenceId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Handle Replicate Webhook
         * @param {FineTuningsApiHandleReplicateWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleReplicateWebhook(requestParameters: FineTuningsApiHandleReplicateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.handleReplicateWebhook(requestParameters.workspaceId, requestParameters.ftId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Image Fts
         * @param {FineTuningsApiSearchImageFtsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchImageFts(requestParameters: FineTuningsApiSearchImageFtsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ImageFTResponse>> {
            return localVarFp.searchImageFts(requestParameters.workspaceId, requestParameters.imageFTSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Inference History
         * @param {FineTuningsApiSearchInferenceHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInferenceHistory(requestParameters: FineTuningsApiSearchInferenceHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageInferenceScrollResponse> {
            return localVarFp.searchInferenceHistory(requestParameters.workspaceId, requestParameters.inferenceHistorySearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Image Ft
         * @param {FineTuningsApiUpdateImageFtRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImageFt(requestParameters: FineTuningsApiUpdateImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageFTResponse> {
            return localVarFp.updateImageFt(requestParameters.ftId, requestParameters.workspaceId, requestParameters.imageFTUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Image Ft
         * @param {FineTuningsApiUploadImageFtRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImageFt(requestParameters: FineTuningsApiUploadImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadResponse> {
            return localVarFp.uploadImageFt(requestParameters.ftType, requestParameters.workspaceId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FineTuningsApi - interface
 * @export
 * @interface FineTuningsApi
 */
export interface FineTuningsApiInterface {
    /**
     * 
     * @summary Create Image Ft
     * @param {FineTuningsApiCreateImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    createImageFt(requestParameters: FineTuningsApiCreateImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageFTResponse>;

    /**
     * 
     * @summary Delete File Ft
     * @param {FineTuningsApiDeleteFileFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    deleteFileFt(requestParameters: FineTuningsApiDeleteFileFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Delete Image Ft
     * @param {FineTuningsApiDeleteImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    deleteImageFt(requestParameters: FineTuningsApiDeleteImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Generate Image Prompt
     * @param {FineTuningsApiGenerateImagePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    generateImagePrompt(requestParameters: FineTuningsApiGenerateImagePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImagePromptResponse>;

    /**
     * 
     * @summary Generate Images
     * @param {FineTuningsApiGenerateImagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    generateImages(requestParameters: FineTuningsApiGenerateImagesRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageInferenceScheduleResponse>;

    /**
     * 
     * @summary Get File Ft
     * @param {FineTuningsApiGetFileFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    getFileFt(requestParameters: FineTuningsApiGetFileFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Inference Results
     * @param {FineTuningsApiGetInferenceResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    getInferenceResults(requestParameters: FineTuningsApiGetInferenceResultsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageInferenceResultResponse>;

    /**
     * 
     * @summary Handle Replicate Webhook
     * @param {FineTuningsApiHandleReplicateWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    handleReplicateWebhook(requestParameters: FineTuningsApiHandleReplicateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Search Image Fts
     * @param {FineTuningsApiSearchImageFtsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    searchImageFts(requestParameters: FineTuningsApiSearchImageFtsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ImageFTResponse>>;

    /**
     * 
     * @summary Search Inference History
     * @param {FineTuningsApiSearchInferenceHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    searchInferenceHistory(requestParameters: FineTuningsApiSearchInferenceHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageInferenceScrollResponse>;

    /**
     * 
     * @summary Update Image Ft
     * @param {FineTuningsApiUpdateImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    updateImageFt(requestParameters: FineTuningsApiUpdateImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageFTResponse>;

    /**
     * 
     * @summary Upload Image Ft
     * @param {FineTuningsApiUploadImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    uploadImageFt(requestParameters: FineTuningsApiUploadImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadResponse>;

}

/**
 * Request parameters for createImageFt operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiCreateImageFtRequest
 */
export interface FineTuningsApiCreateImageFtRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiCreateImageFt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ImageFTCreateRequest}
     * @memberof FineTuningsApiCreateImageFt
     */
    readonly imageFTCreateRequest: ImageFTCreateRequest
}

/**
 * Request parameters for deleteFileFt operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiDeleteFileFtRequest
 */
export interface FineTuningsApiDeleteFileFtRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiDeleteFileFt
     */
    readonly fileKey: string

    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiDeleteFileFt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {InferenceFileType}
     * @memberof FineTuningsApiDeleteFileFt
     */
    readonly fileType: InferenceFileType
}

/**
 * Request parameters for deleteImageFt operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiDeleteImageFtRequest
 */
export interface FineTuningsApiDeleteImageFtRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiDeleteImageFt
     */
    readonly ftId: string

    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiDeleteImageFt
     */
    readonly workspaceId: string
}

/**
 * Request parameters for generateImagePrompt operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiGenerateImagePromptRequest
 */
export interface FineTuningsApiGenerateImagePromptRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiGenerateImagePrompt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ImagePromptGenerationRequest}
     * @memberof FineTuningsApiGenerateImagePrompt
     */
    readonly imagePromptGenerationRequest: ImagePromptGenerationRequest
}

/**
 * Request parameters for generateImages operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiGenerateImagesRequest
 */
export interface FineTuningsApiGenerateImagesRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiGenerateImages
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ImageInferenceRequest}
     * @memberof FineTuningsApiGenerateImages
     */
    readonly imageInferenceRequest: ImageInferenceRequest
}

/**
 * Request parameters for getFileFt operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiGetFileFtRequest
 */
export interface FineTuningsApiGetFileFtRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiGetFileFt
     */
    readonly fileKey: string

    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiGetFileFt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {InferenceFileType}
     * @memberof FineTuningsApiGetFileFt
     */
    readonly fileType: InferenceFileType
}

/**
 * Request parameters for getInferenceResults operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiGetInferenceResultsRequest
 */
export interface FineTuningsApiGetInferenceResultsRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiGetInferenceResults
     */
    readonly inferenceId: string

    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiGetInferenceResults
     */
    readonly workspaceId: string
}

/**
 * Request parameters for handleReplicateWebhook operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiHandleReplicateWebhookRequest
 */
export interface FineTuningsApiHandleReplicateWebhookRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiHandleReplicateWebhook
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiHandleReplicateWebhook
     */
    readonly ftId: string
}

/**
 * Request parameters for searchImageFts operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiSearchImageFtsRequest
 */
export interface FineTuningsApiSearchImageFtsRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiSearchImageFts
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ImageFTSearchRequest}
     * @memberof FineTuningsApiSearchImageFts
     */
    readonly imageFTSearchRequest: ImageFTSearchRequest
}

/**
 * Request parameters for searchInferenceHistory operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiSearchInferenceHistoryRequest
 */
export interface FineTuningsApiSearchInferenceHistoryRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiSearchInferenceHistory
     */
    readonly workspaceId: string

    /**
     * 
     * @type {InferenceHistorySearchRequest}
     * @memberof FineTuningsApiSearchInferenceHistory
     */
    readonly inferenceHistorySearchRequest: InferenceHistorySearchRequest
}

/**
 * Request parameters for updateImageFt operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiUpdateImageFtRequest
 */
export interface FineTuningsApiUpdateImageFtRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiUpdateImageFt
     */
    readonly ftId: string

    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiUpdateImageFt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ImageFTUpdateRequest}
     * @memberof FineTuningsApiUpdateImageFt
     */
    readonly imageFTUpdateRequest: ImageFTUpdateRequest
}

/**
 * Request parameters for uploadImageFt operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiUploadImageFtRequest
 */
export interface FineTuningsApiUploadImageFtRequest {
    /**
     * 
     * @type {FTType}
     * @memberof FineTuningsApiUploadImageFt
     */
    readonly ftType: FTType

    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiUploadImageFt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {File}
     * @memberof FineTuningsApiUploadImageFt
     */
    readonly file: File
}

/**
 * FineTuningsApi - object-oriented interface
 * @export
 * @class FineTuningsApi
 * @extends {BaseAPI}
 */
export class FineTuningsApi extends BaseAPI implements FineTuningsApiInterface {
    /**
     * 
     * @summary Create Image Ft
     * @param {FineTuningsApiCreateImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public createImageFt(requestParameters: FineTuningsApiCreateImageFtRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).createImageFt(requestParameters.workspaceId, requestParameters.imageFTCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete File Ft
     * @param {FineTuningsApiDeleteFileFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public deleteFileFt(requestParameters: FineTuningsApiDeleteFileFtRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).deleteFileFt(requestParameters.fileKey, requestParameters.workspaceId, requestParameters.fileType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Image Ft
     * @param {FineTuningsApiDeleteImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public deleteImageFt(requestParameters: FineTuningsApiDeleteImageFtRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).deleteImageFt(requestParameters.ftId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate Image Prompt
     * @param {FineTuningsApiGenerateImagePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public generateImagePrompt(requestParameters: FineTuningsApiGenerateImagePromptRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).generateImagePrompt(requestParameters.workspaceId, requestParameters.imagePromptGenerationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate Images
     * @param {FineTuningsApiGenerateImagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public generateImages(requestParameters: FineTuningsApiGenerateImagesRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).generateImages(requestParameters.workspaceId, requestParameters.imageInferenceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get File Ft
     * @param {FineTuningsApiGetFileFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public getFileFt(requestParameters: FineTuningsApiGetFileFtRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).getFileFt(requestParameters.fileKey, requestParameters.workspaceId, requestParameters.fileType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Inference Results
     * @param {FineTuningsApiGetInferenceResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public getInferenceResults(requestParameters: FineTuningsApiGetInferenceResultsRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).getInferenceResults(requestParameters.inferenceId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Handle Replicate Webhook
     * @param {FineTuningsApiHandleReplicateWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public handleReplicateWebhook(requestParameters: FineTuningsApiHandleReplicateWebhookRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).handleReplicateWebhook(requestParameters.workspaceId, requestParameters.ftId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Image Fts
     * @param {FineTuningsApiSearchImageFtsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public searchImageFts(requestParameters: FineTuningsApiSearchImageFtsRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).searchImageFts(requestParameters.workspaceId, requestParameters.imageFTSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Inference History
     * @param {FineTuningsApiSearchInferenceHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public searchInferenceHistory(requestParameters: FineTuningsApiSearchInferenceHistoryRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).searchInferenceHistory(requestParameters.workspaceId, requestParameters.inferenceHistorySearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Image Ft
     * @param {FineTuningsApiUpdateImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public updateImageFt(requestParameters: FineTuningsApiUpdateImageFtRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).updateImageFt(requestParameters.ftId, requestParameters.workspaceId, requestParameters.imageFTUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Image Ft
     * @param {FineTuningsApiUploadImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public uploadImageFt(requestParameters: FineTuningsApiUploadImageFtRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).uploadImageFt(requestParameters.ftType, requestParameters.workspaceId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FlowAssistantApi - axios parameter creator
 * @export
 */
export const FlowAssistantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply Flow Assistant Changes
         * @param {string} workspaceId 
         * @param {FlowAssistantApplyRejectChangesRequest} flowAssistantApplyRejectChangesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyFlowAssistantChanges: async (workspaceId: string, flowAssistantApplyRejectChangesRequest: FlowAssistantApplyRejectChangesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('applyFlowAssistantChanges', 'workspaceId', workspaceId)
            // verify required parameter 'flowAssistantApplyRejectChangesRequest' is not null or undefined
            assertParamExists('applyFlowAssistantChanges', 'flowAssistantApplyRejectChangesRequest', flowAssistantApplyRejectChangesRequest)
            const localVarPath = `/v2/flow_assistants/apply_changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowAssistantApplyRejectChangesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Flow Assistant Session
         * @param {string} workspaceId 
         * @param {FlowAssistantSessionCreateRequest} flowAssistantSessionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowAssistantSession: async (workspaceId: string, flowAssistantSessionCreateRequest: FlowAssistantSessionCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createFlowAssistantSession', 'workspaceId', workspaceId)
            // verify required parameter 'flowAssistantSessionCreateRequest' is not null or undefined
            assertParamExists('createFlowAssistantSession', 'flowAssistantSessionCreateRequest', flowAssistantSessionCreateRequest)
            const localVarPath = `/v2/flow_assistants/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowAssistantSessionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke Flow Assistant Response
         * @param {string} sessionId 
         * @param {FlowAssistantInvokeRequest} flowAssistantInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlowAssistantResponse: async (sessionId: string, flowAssistantInvokeRequest: FlowAssistantInvokeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('invokeFlowAssistantResponse', 'sessionId', sessionId)
            // verify required parameter 'flowAssistantInvokeRequest' is not null or undefined
            assertParamExists('invokeFlowAssistantResponse', 'flowAssistantInvokeRequest', flowAssistantInvokeRequest)
            const localVarPath = `/v2/flow_assistants/{session_id}/invoke`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowAssistantInvokeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Poll Flow Assistant Response
         * @param {string} sessionId 
         * @param {string} fromTimestamp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollFlowAssistantResponse: async (sessionId: string, fromTimestamp: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('pollFlowAssistantResponse', 'sessionId', sessionId)
            // verify required parameter 'fromTimestamp' is not null or undefined
            assertParamExists('pollFlowAssistantResponse', 'fromTimestamp', fromTimestamp)
            const localVarPath = `/v2/flow_assistants/{session_id}/invocation_response/{from_timestamp}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"from_timestamp"}}`, encodeURIComponent(String(fromTimestamp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reject Flow Assistant Changes
         * @param {string} workspaceId 
         * @param {FlowAssistantApplyRejectChangesRequest} flowAssistantApplyRejectChangesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectFlowAssistantChanges: async (workspaceId: string, flowAssistantApplyRejectChangesRequest: FlowAssistantApplyRejectChangesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('rejectFlowAssistantChanges', 'workspaceId', workspaceId)
            // verify required parameter 'flowAssistantApplyRejectChangesRequest' is not null or undefined
            assertParamExists('rejectFlowAssistantChanges', 'flowAssistantApplyRejectChangesRequest', flowAssistantApplyRejectChangesRequest)
            const localVarPath = `/v2/flow_assistants/reject_changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowAssistantApplyRejectChangesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlowAssistantApi - functional programming interface
 * @export
 */
export const FlowAssistantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlowAssistantApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Apply Flow Assistant Changes
         * @param {string} workspaceId 
         * @param {FlowAssistantApplyRejectChangesRequest} flowAssistantApplyRejectChangesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyFlowAssistantChanges(workspaceId: string, flowAssistantApplyRejectChangesRequest: FlowAssistantApplyRejectChangesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.applyFlowAssistantChanges(workspaceId, flowAssistantApplyRejectChangesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowAssistantApi.applyFlowAssistantChanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Flow Assistant Session
         * @param {string} workspaceId 
         * @param {FlowAssistantSessionCreateRequest} flowAssistantSessionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFlowAssistantSession(workspaceId: string, flowAssistantSessionCreateRequest: FlowAssistantSessionCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFlowAssistantSession(workspaceId, flowAssistantSessionCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowAssistantApi.createFlowAssistantSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke Flow Assistant Response
         * @param {string} sessionId 
         * @param {FlowAssistantInvokeRequest} flowAssistantInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invokeFlowAssistantResponse(sessionId: string, flowAssistantInvokeRequest: FlowAssistantInvokeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionInvocationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invokeFlowAssistantResponse(sessionId, flowAssistantInvokeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowAssistantApi.invokeFlowAssistantResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Poll Flow Assistant Response
         * @param {string} sessionId 
         * @param {string} fromTimestamp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pollFlowAssistantResponse(sessionId: string, fromTimestamp: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowSessionEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pollFlowAssistantResponse(sessionId, fromTimestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowAssistantApi.pollFlowAssistantResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reject Flow Assistant Changes
         * @param {string} workspaceId 
         * @param {FlowAssistantApplyRejectChangesRequest} flowAssistantApplyRejectChangesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectFlowAssistantChanges(workspaceId: string, flowAssistantApplyRejectChangesRequest: FlowAssistantApplyRejectChangesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectFlowAssistantChanges(workspaceId, flowAssistantApplyRejectChangesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowAssistantApi.rejectFlowAssistantChanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FlowAssistantApi - factory interface
 * @export
 */
export const FlowAssistantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlowAssistantApiFp(configuration)
    return {
        /**
         * 
         * @summary Apply Flow Assistant Changes
         * @param {FlowAssistantApiApplyFlowAssistantChangesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyFlowAssistantChanges(requestParameters: FlowAssistantApiApplyFlowAssistantChangesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse> {
            return localVarFp.applyFlowAssistantChanges(requestParameters.workspaceId, requestParameters.flowAssistantApplyRejectChangesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Flow Assistant Session
         * @param {FlowAssistantApiCreateFlowAssistantSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowAssistantSession(requestParameters: FlowAssistantApiCreateFlowAssistantSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionResponse> {
            return localVarFp.createFlowAssistantSession(requestParameters.workspaceId, requestParameters.flowAssistantSessionCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke Flow Assistant Response
         * @param {FlowAssistantApiInvokeFlowAssistantResponseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlowAssistantResponse(requestParameters: FlowAssistantApiInvokeFlowAssistantResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse> {
            return localVarFp.invokeFlowAssistantResponse(requestParameters.sessionId, requestParameters.flowAssistantInvokeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Poll Flow Assistant Response
         * @param {FlowAssistantApiPollFlowAssistantResponseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollFlowAssistantResponse(requestParameters: FlowAssistantApiPollFlowAssistantResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionEvent>> {
            return localVarFp.pollFlowAssistantResponse(requestParameters.sessionId, requestParameters.fromTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reject Flow Assistant Changes
         * @param {FlowAssistantApiRejectFlowAssistantChangesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectFlowAssistantChanges(requestParameters: FlowAssistantApiRejectFlowAssistantChangesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse> {
            return localVarFp.rejectFlowAssistantChanges(requestParameters.workspaceId, requestParameters.flowAssistantApplyRejectChangesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlowAssistantApi - interface
 * @export
 * @interface FlowAssistantApi
 */
export interface FlowAssistantApiInterface {
    /**
     * 
     * @summary Apply Flow Assistant Changes
     * @param {FlowAssistantApiApplyFlowAssistantChangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApiInterface
     */
    applyFlowAssistantChanges(requestParameters: FlowAssistantApiApplyFlowAssistantChangesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse>;

    /**
     * 
     * @summary Create Flow Assistant Session
     * @param {FlowAssistantApiCreateFlowAssistantSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApiInterface
     */
    createFlowAssistantSession(requestParameters: FlowAssistantApiCreateFlowAssistantSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionResponse>;

    /**
     * 
     * @summary Invoke Flow Assistant Response
     * @param {FlowAssistantApiInvokeFlowAssistantResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApiInterface
     */
    invokeFlowAssistantResponse(requestParameters: FlowAssistantApiInvokeFlowAssistantResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse>;

    /**
     * 
     * @summary Poll Flow Assistant Response
     * @param {FlowAssistantApiPollFlowAssistantResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApiInterface
     */
    pollFlowAssistantResponse(requestParameters: FlowAssistantApiPollFlowAssistantResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionEvent>>;

    /**
     * 
     * @summary Reject Flow Assistant Changes
     * @param {FlowAssistantApiRejectFlowAssistantChangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApiInterface
     */
    rejectFlowAssistantChanges(requestParameters: FlowAssistantApiRejectFlowAssistantChangesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse>;

}

/**
 * Request parameters for applyFlowAssistantChanges operation in FlowAssistantApi.
 * @export
 * @interface FlowAssistantApiApplyFlowAssistantChangesRequest
 */
export interface FlowAssistantApiApplyFlowAssistantChangesRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantApiApplyFlowAssistantChanges
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowAssistantApplyRejectChangesRequest}
     * @memberof FlowAssistantApiApplyFlowAssistantChanges
     */
    readonly flowAssistantApplyRejectChangesRequest: FlowAssistantApplyRejectChangesRequest
}

/**
 * Request parameters for createFlowAssistantSession operation in FlowAssistantApi.
 * @export
 * @interface FlowAssistantApiCreateFlowAssistantSessionRequest
 */
export interface FlowAssistantApiCreateFlowAssistantSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantApiCreateFlowAssistantSession
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowAssistantSessionCreateRequest}
     * @memberof FlowAssistantApiCreateFlowAssistantSession
     */
    readonly flowAssistantSessionCreateRequest: FlowAssistantSessionCreateRequest
}

/**
 * Request parameters for invokeFlowAssistantResponse operation in FlowAssistantApi.
 * @export
 * @interface FlowAssistantApiInvokeFlowAssistantResponseRequest
 */
export interface FlowAssistantApiInvokeFlowAssistantResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantApiInvokeFlowAssistantResponse
     */
    readonly sessionId: string

    /**
     * 
     * @type {FlowAssistantInvokeRequest}
     * @memberof FlowAssistantApiInvokeFlowAssistantResponse
     */
    readonly flowAssistantInvokeRequest: FlowAssistantInvokeRequest
}

/**
 * Request parameters for pollFlowAssistantResponse operation in FlowAssistantApi.
 * @export
 * @interface FlowAssistantApiPollFlowAssistantResponseRequest
 */
export interface FlowAssistantApiPollFlowAssistantResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantApiPollFlowAssistantResponse
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof FlowAssistantApiPollFlowAssistantResponse
     */
    readonly fromTimestamp: string
}

/**
 * Request parameters for rejectFlowAssistantChanges operation in FlowAssistantApi.
 * @export
 * @interface FlowAssistantApiRejectFlowAssistantChangesRequest
 */
export interface FlowAssistantApiRejectFlowAssistantChangesRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantApiRejectFlowAssistantChanges
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowAssistantApplyRejectChangesRequest}
     * @memberof FlowAssistantApiRejectFlowAssistantChanges
     */
    readonly flowAssistantApplyRejectChangesRequest: FlowAssistantApplyRejectChangesRequest
}

/**
 * FlowAssistantApi - object-oriented interface
 * @export
 * @class FlowAssistantApi
 * @extends {BaseAPI}
 */
export class FlowAssistantApi extends BaseAPI implements FlowAssistantApiInterface {
    /**
     * 
     * @summary Apply Flow Assistant Changes
     * @param {FlowAssistantApiApplyFlowAssistantChangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApi
     */
    public applyFlowAssistantChanges(requestParameters: FlowAssistantApiApplyFlowAssistantChangesRequest, options?: RawAxiosRequestConfig) {
        return FlowAssistantApiFp(this.configuration).applyFlowAssistantChanges(requestParameters.workspaceId, requestParameters.flowAssistantApplyRejectChangesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Flow Assistant Session
     * @param {FlowAssistantApiCreateFlowAssistantSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApi
     */
    public createFlowAssistantSession(requestParameters: FlowAssistantApiCreateFlowAssistantSessionRequest, options?: RawAxiosRequestConfig) {
        return FlowAssistantApiFp(this.configuration).createFlowAssistantSession(requestParameters.workspaceId, requestParameters.flowAssistantSessionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke Flow Assistant Response
     * @param {FlowAssistantApiInvokeFlowAssistantResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApi
     */
    public invokeFlowAssistantResponse(requestParameters: FlowAssistantApiInvokeFlowAssistantResponseRequest, options?: RawAxiosRequestConfig) {
        return FlowAssistantApiFp(this.configuration).invokeFlowAssistantResponse(requestParameters.sessionId, requestParameters.flowAssistantInvokeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Poll Flow Assistant Response
     * @param {FlowAssistantApiPollFlowAssistantResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApi
     */
    public pollFlowAssistantResponse(requestParameters: FlowAssistantApiPollFlowAssistantResponseRequest, options?: RawAxiosRequestConfig) {
        return FlowAssistantApiFp(this.configuration).pollFlowAssistantResponse(requestParameters.sessionId, requestParameters.fromTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reject Flow Assistant Changes
     * @param {FlowAssistantApiRejectFlowAssistantChangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApi
     */
    public rejectFlowAssistantChanges(requestParameters: FlowAssistantApiRejectFlowAssistantChangesRequest, options?: RawAxiosRequestConfig) {
        return FlowAssistantApiFp(this.configuration).rejectFlowAssistantChanges(requestParameters.workspaceId, requestParameters.flowAssistantApplyRejectChangesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FlowMessagesApi - axios parameter creator
 * @export
 */
export const FlowMessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Search Flow Messages
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlowMessages: async (sessionId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('searchFlowMessages', 'sessionId', sessionId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchFlowMessages', 'workspaceId', workspaceId)
            const localVarPath = `/v2/chatbots/search/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlowMessagesApi - functional programming interface
 * @export
 */
export const FlowMessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlowMessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Search Flow Messages
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchFlowMessages(sessionId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowSessionEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFlowMessages(sessionId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowMessagesApi.searchFlowMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FlowMessagesApi - factory interface
 * @export
 */
export const FlowMessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlowMessagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Search Flow Messages
         * @param {FlowMessagesApiSearchFlowMessagesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlowMessages(requestParameters: FlowMessagesApiSearchFlowMessagesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionEvent>> {
            return localVarFp.searchFlowMessages(requestParameters.sessionId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlowMessagesApi - interface
 * @export
 * @interface FlowMessagesApi
 */
export interface FlowMessagesApiInterface {
    /**
     * 
     * @summary Search Flow Messages
     * @param {FlowMessagesApiSearchFlowMessagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowMessagesApiInterface
     */
    searchFlowMessages(requestParameters: FlowMessagesApiSearchFlowMessagesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionEvent>>;

}

/**
 * Request parameters for searchFlowMessages operation in FlowMessagesApi.
 * @export
 * @interface FlowMessagesApiSearchFlowMessagesRequest
 */
export interface FlowMessagesApiSearchFlowMessagesRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowMessagesApiSearchFlowMessages
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof FlowMessagesApiSearchFlowMessages
     */
    readonly workspaceId: string
}

/**
 * FlowMessagesApi - object-oriented interface
 * @export
 * @class FlowMessagesApi
 * @extends {BaseAPI}
 */
export class FlowMessagesApi extends BaseAPI implements FlowMessagesApiInterface {
    /**
     * 
     * @summary Search Flow Messages
     * @param {FlowMessagesApiSearchFlowMessagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowMessagesApi
     */
    public searchFlowMessages(requestParameters: FlowMessagesApiSearchFlowMessagesRequest, options?: RawAxiosRequestConfig) {
        return FlowMessagesApiFp(this.configuration).searchFlowMessages(requestParameters.sessionId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FlowSessionsApi - axios parameter creator
 * @export
 */
export const FlowSessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Chatbot Session View
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChatbotSessionView: async (sessionId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deleteChatbotSessionView', 'sessionId', sessionId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteChatbotSessionView', 'workspaceId', workspaceId)
            const localVarPath = `/v2/chatbots/sessions/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Chart Feedback
         * @param {string} workspaceId 
         * @param {ChartsFeedbackRequest} chartsFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartFeedback: async (workspaceId: string, chartsFeedbackRequest: ChartsFeedbackRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getChartFeedback', 'workspaceId', workspaceId)
            // verify required parameter 'chartsFeedbackRequest' is not null or undefined
            assertParamExists('getChartFeedback', 'chartsFeedbackRequest', chartsFeedbackRequest)
            const localVarPath = `/v2/chatbots/sessions/charts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chartsFeedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Chart Session Duration
         * @param {string} workspaceId 
         * @param {ChartsFeedbackRequest} chartsFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartSessionDuration: async (workspaceId: string, chartsFeedbackRequest: ChartsFeedbackRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getChartSessionDuration', 'workspaceId', workspaceId)
            // verify required parameter 'chartsFeedbackRequest' is not null or undefined
            assertParamExists('getChartSessionDuration', 'chartsFeedbackRequest', chartsFeedbackRequest)
            const localVarPath = `/v2/chatbots/sessions/chart_session_duration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chartsFeedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Chatbot Session View
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatbotSessionView: async (sessionId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getChatbotSessionView', 'sessionId', sessionId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getChatbotSessionView', 'workspaceId', workspaceId)
            const localVarPath = `/v2/chatbots/sessions/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tool Calls Chart Feedback
         * @param {string} workspaceId 
         * @param {ChartsFeedbackRequest} chartsFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolCallsChartFeedback: async (workspaceId: string, chartsFeedbackRequest: ChartsFeedbackRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getToolCallsChartFeedback', 'workspaceId', workspaceId)
            // verify required parameter 'chartsFeedbackRequest' is not null or undefined
            assertParamExists('getToolCallsChartFeedback', 'chartsFeedbackRequest', chartsFeedbackRequest)
            const localVarPath = `/v2/chatbots/sessions/chart_tool_calls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chartsFeedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Chatbot Sessions View
         * @param {string} workspaceId 
         * @param {FlowSessionViewSearchRequest} flowSessionViewSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChatbotSessionsView: async (workspaceId: string, flowSessionViewSearchRequest: FlowSessionViewSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchChatbotSessionsView', 'workspaceId', workspaceId)
            // verify required parameter 'flowSessionViewSearchRequest' is not null or undefined
            assertParamExists('searchChatbotSessionsView', 'flowSessionViewSearchRequest', flowSessionViewSearchRequest)
            const localVarPath = `/v2/chatbots/sessions/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowSessionViewSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Flow Event
         * @param {string} workspaceId 
         * @param {FlowEventsSearchRequest} flowEventsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlowEvent: async (workspaceId: string, flowEventsSearchRequest: FlowEventsSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchFlowEvent', 'workspaceId', workspaceId)
            // verify required parameter 'flowEventsSearchRequest' is not null or undefined
            assertParamExists('searchFlowEvent', 'flowEventsSearchRequest', flowEventsSearchRequest)
            const localVarPath = `/v2/chatbots/sessions/search_event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowEventsSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Chatbot Session View
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {FlowSessionViewUpdateRequest} flowSessionViewUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatbotSessionView: async (sessionId: string, workspaceId: string, flowSessionViewUpdateRequest: FlowSessionViewUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('updateChatbotSessionView', 'sessionId', sessionId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateChatbotSessionView', 'workspaceId', workspaceId)
            // verify required parameter 'flowSessionViewUpdateRequest' is not null or undefined
            assertParamExists('updateChatbotSessionView', 'flowSessionViewUpdateRequest', flowSessionViewUpdateRequest)
            const localVarPath = `/v2/chatbots/sessions/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowSessionViewUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlowSessionsApi - functional programming interface
 * @export
 */
export const FlowSessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlowSessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Chatbot Session View
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChatbotSessionView(sessionId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChatbotSessionView(sessionId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowSessionsApi.deleteChatbotSessionView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Chart Feedback
         * @param {string} workspaceId 
         * @param {ChartsFeedbackRequest} chartsFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChartFeedback(workspaceId: string, chartsFeedbackRequest: ChartsFeedbackRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedbackChartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChartFeedback(workspaceId, chartsFeedbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowSessionsApi.getChartFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Chart Session Duration
         * @param {string} workspaceId 
         * @param {ChartsFeedbackRequest} chartsFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChartSessionDuration(workspaceId: string, chartsFeedbackRequest: ChartsFeedbackRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartSessionDurationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChartSessionDuration(workspaceId, chartsFeedbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowSessionsApi.getChartSessionDuration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Chatbot Session View
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatbotSessionView(sessionId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionViewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatbotSessionView(sessionId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowSessionsApi.getChatbotSessionView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Tool Calls Chart Feedback
         * @param {string} workspaceId 
         * @param {ChartsFeedbackRequest} chartsFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToolCallsChartFeedback(workspaceId: string, chartsFeedbackRequest: ChartsFeedbackRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ToolCallFeedbackResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToolCallsChartFeedback(workspaceId, chartsFeedbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowSessionsApi.getToolCallsChartFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Chatbot Sessions View
         * @param {string} workspaceId 
         * @param {FlowSessionViewSearchRequest} flowSessionViewSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchChatbotSessionsView(workspaceId: string, flowSessionViewSearchRequest: FlowSessionViewSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowSessionViewResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchChatbotSessionsView(workspaceId, flowSessionViewSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowSessionsApi.searchChatbotSessionsView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Flow Event
         * @param {string} workspaceId 
         * @param {FlowEventsSearchRequest} flowEventsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchFlowEvent(workspaceId: string, flowEventsSearchRequest: FlowEventsSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowEventsSearchResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFlowEvent(workspaceId, flowEventsSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowSessionsApi.searchFlowEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Chatbot Session View
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {FlowSessionViewUpdateRequest} flowSessionViewUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChatbotSessionView(sessionId: string, workspaceId: string, flowSessionViewUpdateRequest: FlowSessionViewUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionViewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChatbotSessionView(sessionId, workspaceId, flowSessionViewUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowSessionsApi.updateChatbotSessionView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FlowSessionsApi - factory interface
 * @export
 */
export const FlowSessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlowSessionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Chatbot Session View
         * @param {FlowSessionsApiDeleteChatbotSessionViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChatbotSessionView(requestParameters: FlowSessionsApiDeleteChatbotSessionViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteChatbotSessionView(requestParameters.sessionId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Chart Feedback
         * @param {FlowSessionsApiGetChartFeedbackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartFeedback(requestParameters: FlowSessionsApiGetChartFeedbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeedbackChartResponse> {
            return localVarFp.getChartFeedback(requestParameters.workspaceId, requestParameters.chartsFeedbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Chart Session Duration
         * @param {FlowSessionsApiGetChartSessionDurationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartSessionDuration(requestParameters: FlowSessionsApiGetChartSessionDurationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChartSessionDurationResponse> {
            return localVarFp.getChartSessionDuration(requestParameters.workspaceId, requestParameters.chartsFeedbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Chatbot Session View
         * @param {FlowSessionsApiGetChatbotSessionViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatbotSessionView(requestParameters: FlowSessionsApiGetChatbotSessionViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionViewResponse> {
            return localVarFp.getChatbotSessionView(requestParameters.sessionId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tool Calls Chart Feedback
         * @param {FlowSessionsApiGetToolCallsChartFeedbackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolCallsChartFeedback(requestParameters: FlowSessionsApiGetToolCallsChartFeedbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ToolCallFeedbackResponse>> {
            return localVarFp.getToolCallsChartFeedback(requestParameters.workspaceId, requestParameters.chartsFeedbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Chatbot Sessions View
         * @param {FlowSessionsApiSearchChatbotSessionsViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChatbotSessionsView(requestParameters: FlowSessionsApiSearchChatbotSessionsViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionViewResponse>> {
            return localVarFp.searchChatbotSessionsView(requestParameters.workspaceId, requestParameters.flowSessionViewSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Flow Event
         * @param {FlowSessionsApiSearchFlowEventRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlowEvent(requestParameters: FlowSessionsApiSearchFlowEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowEventsSearchResponse>> {
            return localVarFp.searchFlowEvent(requestParameters.workspaceId, requestParameters.flowEventsSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Chatbot Session View
         * @param {FlowSessionsApiUpdateChatbotSessionViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatbotSessionView(requestParameters: FlowSessionsApiUpdateChatbotSessionViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionViewResponse> {
            return localVarFp.updateChatbotSessionView(requestParameters.sessionId, requestParameters.workspaceId, requestParameters.flowSessionViewUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlowSessionsApi - interface
 * @export
 * @interface FlowSessionsApi
 */
export interface FlowSessionsApiInterface {
    /**
     * 
     * @summary Delete Chatbot Session View
     * @param {FlowSessionsApiDeleteChatbotSessionViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApiInterface
     */
    deleteChatbotSessionView(requestParameters: FlowSessionsApiDeleteChatbotSessionViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Get Chart Feedback
     * @param {FlowSessionsApiGetChartFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApiInterface
     */
    getChartFeedback(requestParameters: FlowSessionsApiGetChartFeedbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeedbackChartResponse>;

    /**
     * 
     * @summary Get Chart Session Duration
     * @param {FlowSessionsApiGetChartSessionDurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApiInterface
     */
    getChartSessionDuration(requestParameters: FlowSessionsApiGetChartSessionDurationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChartSessionDurationResponse>;

    /**
     * 
     * @summary Get Chatbot Session View
     * @param {FlowSessionsApiGetChatbotSessionViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApiInterface
     */
    getChatbotSessionView(requestParameters: FlowSessionsApiGetChatbotSessionViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionViewResponse>;

    /**
     * 
     * @summary Get Tool Calls Chart Feedback
     * @param {FlowSessionsApiGetToolCallsChartFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApiInterface
     */
    getToolCallsChartFeedback(requestParameters: FlowSessionsApiGetToolCallsChartFeedbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ToolCallFeedbackResponse>>;

    /**
     * 
     * @summary Search Chatbot Sessions View
     * @param {FlowSessionsApiSearchChatbotSessionsViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApiInterface
     */
    searchChatbotSessionsView(requestParameters: FlowSessionsApiSearchChatbotSessionsViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionViewResponse>>;

    /**
     * 
     * @summary Search Flow Event
     * @param {FlowSessionsApiSearchFlowEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApiInterface
     */
    searchFlowEvent(requestParameters: FlowSessionsApiSearchFlowEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowEventsSearchResponse>>;

    /**
     * 
     * @summary Update Chatbot Session View
     * @param {FlowSessionsApiUpdateChatbotSessionViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApiInterface
     */
    updateChatbotSessionView(requestParameters: FlowSessionsApiUpdateChatbotSessionViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionViewResponse>;

}

/**
 * Request parameters for deleteChatbotSessionView operation in FlowSessionsApi.
 * @export
 * @interface FlowSessionsApiDeleteChatbotSessionViewRequest
 */
export interface FlowSessionsApiDeleteChatbotSessionViewRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiDeleteChatbotSessionView
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiDeleteChatbotSessionView
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getChartFeedback operation in FlowSessionsApi.
 * @export
 * @interface FlowSessionsApiGetChartFeedbackRequest
 */
export interface FlowSessionsApiGetChartFeedbackRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiGetChartFeedback
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ChartsFeedbackRequest}
     * @memberof FlowSessionsApiGetChartFeedback
     */
    readonly chartsFeedbackRequest: ChartsFeedbackRequest
}

/**
 * Request parameters for getChartSessionDuration operation in FlowSessionsApi.
 * @export
 * @interface FlowSessionsApiGetChartSessionDurationRequest
 */
export interface FlowSessionsApiGetChartSessionDurationRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiGetChartSessionDuration
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ChartsFeedbackRequest}
     * @memberof FlowSessionsApiGetChartSessionDuration
     */
    readonly chartsFeedbackRequest: ChartsFeedbackRequest
}

/**
 * Request parameters for getChatbotSessionView operation in FlowSessionsApi.
 * @export
 * @interface FlowSessionsApiGetChatbotSessionViewRequest
 */
export interface FlowSessionsApiGetChatbotSessionViewRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiGetChatbotSessionView
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiGetChatbotSessionView
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getToolCallsChartFeedback operation in FlowSessionsApi.
 * @export
 * @interface FlowSessionsApiGetToolCallsChartFeedbackRequest
 */
export interface FlowSessionsApiGetToolCallsChartFeedbackRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiGetToolCallsChartFeedback
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ChartsFeedbackRequest}
     * @memberof FlowSessionsApiGetToolCallsChartFeedback
     */
    readonly chartsFeedbackRequest: ChartsFeedbackRequest
}

/**
 * Request parameters for searchChatbotSessionsView operation in FlowSessionsApi.
 * @export
 * @interface FlowSessionsApiSearchChatbotSessionsViewRequest
 */
export interface FlowSessionsApiSearchChatbotSessionsViewRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiSearchChatbotSessionsView
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowSessionViewSearchRequest}
     * @memberof FlowSessionsApiSearchChatbotSessionsView
     */
    readonly flowSessionViewSearchRequest: FlowSessionViewSearchRequest
}

/**
 * Request parameters for searchFlowEvent operation in FlowSessionsApi.
 * @export
 * @interface FlowSessionsApiSearchFlowEventRequest
 */
export interface FlowSessionsApiSearchFlowEventRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiSearchFlowEvent
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowEventsSearchRequest}
     * @memberof FlowSessionsApiSearchFlowEvent
     */
    readonly flowEventsSearchRequest: FlowEventsSearchRequest
}

/**
 * Request parameters for updateChatbotSessionView operation in FlowSessionsApi.
 * @export
 * @interface FlowSessionsApiUpdateChatbotSessionViewRequest
 */
export interface FlowSessionsApiUpdateChatbotSessionViewRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiUpdateChatbotSessionView
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiUpdateChatbotSessionView
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowSessionViewUpdateRequest}
     * @memberof FlowSessionsApiUpdateChatbotSessionView
     */
    readonly flowSessionViewUpdateRequest: FlowSessionViewUpdateRequest
}

/**
 * FlowSessionsApi - object-oriented interface
 * @export
 * @class FlowSessionsApi
 * @extends {BaseAPI}
 */
export class FlowSessionsApi extends BaseAPI implements FlowSessionsApiInterface {
    /**
     * 
     * @summary Delete Chatbot Session View
     * @param {FlowSessionsApiDeleteChatbotSessionViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApi
     */
    public deleteChatbotSessionView(requestParameters: FlowSessionsApiDeleteChatbotSessionViewRequest, options?: RawAxiosRequestConfig) {
        return FlowSessionsApiFp(this.configuration).deleteChatbotSessionView(requestParameters.sessionId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Chart Feedback
     * @param {FlowSessionsApiGetChartFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApi
     */
    public getChartFeedback(requestParameters: FlowSessionsApiGetChartFeedbackRequest, options?: RawAxiosRequestConfig) {
        return FlowSessionsApiFp(this.configuration).getChartFeedback(requestParameters.workspaceId, requestParameters.chartsFeedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Chart Session Duration
     * @param {FlowSessionsApiGetChartSessionDurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApi
     */
    public getChartSessionDuration(requestParameters: FlowSessionsApiGetChartSessionDurationRequest, options?: RawAxiosRequestConfig) {
        return FlowSessionsApiFp(this.configuration).getChartSessionDuration(requestParameters.workspaceId, requestParameters.chartsFeedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Chatbot Session View
     * @param {FlowSessionsApiGetChatbotSessionViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApi
     */
    public getChatbotSessionView(requestParameters: FlowSessionsApiGetChatbotSessionViewRequest, options?: RawAxiosRequestConfig) {
        return FlowSessionsApiFp(this.configuration).getChatbotSessionView(requestParameters.sessionId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tool Calls Chart Feedback
     * @param {FlowSessionsApiGetToolCallsChartFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApi
     */
    public getToolCallsChartFeedback(requestParameters: FlowSessionsApiGetToolCallsChartFeedbackRequest, options?: RawAxiosRequestConfig) {
        return FlowSessionsApiFp(this.configuration).getToolCallsChartFeedback(requestParameters.workspaceId, requestParameters.chartsFeedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Chatbot Sessions View
     * @param {FlowSessionsApiSearchChatbotSessionsViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApi
     */
    public searchChatbotSessionsView(requestParameters: FlowSessionsApiSearchChatbotSessionsViewRequest, options?: RawAxiosRequestConfig) {
        return FlowSessionsApiFp(this.configuration).searchChatbotSessionsView(requestParameters.workspaceId, requestParameters.flowSessionViewSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Flow Event
     * @param {FlowSessionsApiSearchFlowEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApi
     */
    public searchFlowEvent(requestParameters: FlowSessionsApiSearchFlowEventRequest, options?: RawAxiosRequestConfig) {
        return FlowSessionsApiFp(this.configuration).searchFlowEvent(requestParameters.workspaceId, requestParameters.flowEventsSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Chatbot Session View
     * @param {FlowSessionsApiUpdateChatbotSessionViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApi
     */
    public updateChatbotSessionView(requestParameters: FlowSessionsApiUpdateChatbotSessionViewRequest, options?: RawAxiosRequestConfig) {
        return FlowSessionsApiFp(this.configuration).updateChatbotSessionView(requestParameters.sessionId, requestParameters.workspaceId, requestParameters.flowSessionViewUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FlowWebhooksApi - axios parameter creator
 * @export
 */
export const FlowWebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Execute Third Party Webhook
         * @param {TriggerType} triggerType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeThirdPartyWebhook: async (triggerType: TriggerType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'triggerType' is not null or undefined
            assertParamExists('executeThirdPartyWebhook', 'triggerType', triggerType)
            const localVarPath = `/v2/flows/webhooks/third_party_integrations/{trigger_type}`
                .replace(`{${"trigger_type"}}`, encodeURIComponent(String(triggerType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute Webhook
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {TriggerType} triggerType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWebhook: async (chatbotId: string, workspaceId: string, triggerType: TriggerType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatbotId' is not null or undefined
            assertParamExists('executeWebhook', 'chatbotId', chatbotId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('executeWebhook', 'workspaceId', workspaceId)
            // verify required parameter 'triggerType' is not null or undefined
            assertParamExists('executeWebhook', 'triggerType', triggerType)
            const localVarPath = `/v2/flows/webhooks/{chatbot_id}`
                .replace(`{${"chatbot_id"}}`, encodeURIComponent(String(chatbotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (triggerType !== undefined) {
                localVarQueryParameter['trigger_type'] = triggerType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute Webhook From Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {TriggerType} triggerType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWebhookFromFlow: async (flowId: string, workspaceId: string, triggerType: TriggerType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('executeWebhookFromFlow', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('executeWebhookFromFlow', 'workspaceId', workspaceId)
            // verify required parameter 'triggerType' is not null or undefined
            assertParamExists('executeWebhookFromFlow', 'triggerType', triggerType)
            const localVarPath = `/v2/flows/webhooks/from_flow/{flow_id}`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (triggerType !== undefined) {
                localVarQueryParameter['trigger_type'] = triggerType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Installation Metadata
         * @param {string} workspaceId 
         * @param {string} flowId 
         * @param {string} appId 
         * @param {GetInstallationMetadataTriggerTypeEnum} triggerType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstallationMetadata: async (workspaceId: string, flowId: string, appId: string, triggerType: GetInstallationMetadataTriggerTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getInstallationMetadata', 'workspaceId', workspaceId)
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('getInstallationMetadata', 'flowId', flowId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getInstallationMetadata', 'appId', appId)
            // verify required parameter 'triggerType' is not null or undefined
            assertParamExists('getInstallationMetadata', 'triggerType', triggerType)
            const localVarPath = `/v2/flows/webhooks/third_party_integrations/installation_metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (flowId !== undefined) {
                localVarQueryParameter['flow_id'] = flowId;
            }

            if (appId !== undefined) {
                localVarQueryParameter['app_id'] = appId;
            }

            if (triggerType !== undefined) {
                localVarQueryParameter['trigger_type'] = triggerType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlowWebhooksApi - functional programming interface
 * @export
 */
export const FlowWebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlowWebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Execute Third Party Webhook
         * @param {TriggerType} triggerType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeThirdPartyWebhook(triggerType: TriggerType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeThirdPartyWebhook(triggerType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowWebhooksApi.executeThirdPartyWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Execute Webhook
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {TriggerType} triggerType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeWebhook(chatbotId: string, workspaceId: string, triggerType: TriggerType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionInvocationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeWebhook(chatbotId, workspaceId, triggerType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowWebhooksApi.executeWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Execute Webhook From Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {TriggerType} triggerType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeWebhookFromFlow(flowId: string, workspaceId: string, triggerType: TriggerType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionInvocationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeWebhookFromFlow(flowId, workspaceId, triggerType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowWebhooksApi.executeWebhookFromFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Installation Metadata
         * @param {string} workspaceId 
         * @param {string} flowId 
         * @param {string} appId 
         * @param {GetInstallationMetadataTriggerTypeEnum} triggerType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstallationMetadata(workspaceId: string, flowId: string, appId: string, triggerType: GetInstallationMetadataTriggerTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstallationMetadata(workspaceId, flowId, appId, triggerType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowWebhooksApi.getInstallationMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FlowWebhooksApi - factory interface
 * @export
 */
export const FlowWebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlowWebhooksApiFp(configuration)
    return {
        /**
         * 
         * @summary Execute Third Party Webhook
         * @param {FlowWebhooksApiExecuteThirdPartyWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeThirdPartyWebhook(requestParameters: FlowWebhooksApiExecuteThirdPartyWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.executeThirdPartyWebhook(requestParameters.triggerType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute Webhook
         * @param {FlowWebhooksApiExecuteWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWebhook(requestParameters: FlowWebhooksApiExecuteWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse> {
            return localVarFp.executeWebhook(requestParameters.chatbotId, requestParameters.workspaceId, requestParameters.triggerType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute Webhook From Flow
         * @param {FlowWebhooksApiExecuteWebhookFromFlowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWebhookFromFlow(requestParameters: FlowWebhooksApiExecuteWebhookFromFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse> {
            return localVarFp.executeWebhookFromFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.triggerType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Installation Metadata
         * @param {FlowWebhooksApiGetInstallationMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstallationMetadata(requestParameters: FlowWebhooksApiGetInstallationMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getInstallationMetadata(requestParameters.workspaceId, requestParameters.flowId, requestParameters.appId, requestParameters.triggerType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlowWebhooksApi - interface
 * @export
 * @interface FlowWebhooksApi
 */
export interface FlowWebhooksApiInterface {
    /**
     * 
     * @summary Execute Third Party Webhook
     * @param {FlowWebhooksApiExecuteThirdPartyWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowWebhooksApiInterface
     */
    executeThirdPartyWebhook(requestParameters: FlowWebhooksApiExecuteThirdPartyWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Execute Webhook
     * @param {FlowWebhooksApiExecuteWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowWebhooksApiInterface
     */
    executeWebhook(requestParameters: FlowWebhooksApiExecuteWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse>;

    /**
     * 
     * @summary Execute Webhook From Flow
     * @param {FlowWebhooksApiExecuteWebhookFromFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowWebhooksApiInterface
     */
    executeWebhookFromFlow(requestParameters: FlowWebhooksApiExecuteWebhookFromFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse>;

    /**
     * 
     * @summary Get Installation Metadata
     * @param {FlowWebhooksApiGetInstallationMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowWebhooksApiInterface
     */
    getInstallationMetadata(requestParameters: FlowWebhooksApiGetInstallationMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

}

/**
 * Request parameters for executeThirdPartyWebhook operation in FlowWebhooksApi.
 * @export
 * @interface FlowWebhooksApiExecuteThirdPartyWebhookRequest
 */
export interface FlowWebhooksApiExecuteThirdPartyWebhookRequest {
    /**
     * 
     * @type {TriggerType}
     * @memberof FlowWebhooksApiExecuteThirdPartyWebhook
     */
    readonly triggerType: TriggerType
}

/**
 * Request parameters for executeWebhook operation in FlowWebhooksApi.
 * @export
 * @interface FlowWebhooksApiExecuteWebhookRequest
 */
export interface FlowWebhooksApiExecuteWebhookRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowWebhooksApiExecuteWebhook
     */
    readonly chatbotId: string

    /**
     * 
     * @type {string}
     * @memberof FlowWebhooksApiExecuteWebhook
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TriggerType}
     * @memberof FlowWebhooksApiExecuteWebhook
     */
    readonly triggerType: TriggerType
}

/**
 * Request parameters for executeWebhookFromFlow operation in FlowWebhooksApi.
 * @export
 * @interface FlowWebhooksApiExecuteWebhookFromFlowRequest
 */
export interface FlowWebhooksApiExecuteWebhookFromFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowWebhooksApiExecuteWebhookFromFlow
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowWebhooksApiExecuteWebhookFromFlow
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TriggerType}
     * @memberof FlowWebhooksApiExecuteWebhookFromFlow
     */
    readonly triggerType: TriggerType
}

/**
 * Request parameters for getInstallationMetadata operation in FlowWebhooksApi.
 * @export
 * @interface FlowWebhooksApiGetInstallationMetadataRequest
 */
export interface FlowWebhooksApiGetInstallationMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowWebhooksApiGetInstallationMetadata
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof FlowWebhooksApiGetInstallationMetadata
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowWebhooksApiGetInstallationMetadata
     */
    readonly appId: string

    /**
     * 
     * @type {'on_flow_form_submission'}
     * @memberof FlowWebhooksApiGetInstallationMetadata
     */
    readonly triggerType: GetInstallationMetadataTriggerTypeEnum
}

/**
 * FlowWebhooksApi - object-oriented interface
 * @export
 * @class FlowWebhooksApi
 * @extends {BaseAPI}
 */
export class FlowWebhooksApi extends BaseAPI implements FlowWebhooksApiInterface {
    /**
     * 
     * @summary Execute Third Party Webhook
     * @param {FlowWebhooksApiExecuteThirdPartyWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowWebhooksApi
     */
    public executeThirdPartyWebhook(requestParameters: FlowWebhooksApiExecuteThirdPartyWebhookRequest, options?: RawAxiosRequestConfig) {
        return FlowWebhooksApiFp(this.configuration).executeThirdPartyWebhook(requestParameters.triggerType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute Webhook
     * @param {FlowWebhooksApiExecuteWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowWebhooksApi
     */
    public executeWebhook(requestParameters: FlowWebhooksApiExecuteWebhookRequest, options?: RawAxiosRequestConfig) {
        return FlowWebhooksApiFp(this.configuration).executeWebhook(requestParameters.chatbotId, requestParameters.workspaceId, requestParameters.triggerType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute Webhook From Flow
     * @param {FlowWebhooksApiExecuteWebhookFromFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowWebhooksApi
     */
    public executeWebhookFromFlow(requestParameters: FlowWebhooksApiExecuteWebhookFromFlowRequest, options?: RawAxiosRequestConfig) {
        return FlowWebhooksApiFp(this.configuration).executeWebhookFromFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.triggerType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Installation Metadata
     * @param {FlowWebhooksApiGetInstallationMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowWebhooksApi
     */
    public getInstallationMetadata(requestParameters: FlowWebhooksApiGetInstallationMetadataRequest, options?: RawAxiosRequestConfig) {
        return FlowWebhooksApiFp(this.configuration).getInstallationMetadata(requestParameters.workspaceId, requestParameters.flowId, requestParameters.appId, requestParameters.triggerType, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetInstallationMetadataTriggerTypeEnum = {
    OnFlowFormSubmission: 'on_flow_form_submission'
} as const;
export type GetInstallationMetadataTriggerTypeEnum = typeof GetInstallationMetadataTriggerTypeEnum[keyof typeof GetInstallationMetadataTriggerTypeEnum];


/**
 * FlowsApi - axios parameter creator
 * @export
 */
export const FlowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Chatbot Session
         * @param {string} workspaceId 
         * @param {FlowSessionCreateRequest} flowSessionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatbotSession: async (workspaceId: string, flowSessionCreateRequest: FlowSessionCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createChatbotSession', 'workspaceId', workspaceId)
            // verify required parameter 'flowSessionCreateRequest' is not null or undefined
            assertParamExists('createChatbotSession', 'flowSessionCreateRequest', flowSessionCreateRequest)
            const localVarPath = `/v2/flows/sessions/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowSessionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Flow
         * @param {string} workspaceId 
         * @param {FlowCreate} flowCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlow: async (workspaceId: string, flowCreate: FlowCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createFlow', 'workspaceId', workspaceId)
            // verify required parameter 'flowCreate' is not null or undefined
            assertParamExists('createFlow', 'flowCreate', flowCreate)
            const localVarPath = `/v2/flows/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Flow Category
         * @param {string} workspaceId 
         * @param {FlowCategoryCreateRequest} flowCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowCategory: async (workspaceId: string, flowCategoryCreateRequest: FlowCategoryCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createFlowCategory', 'workspaceId', workspaceId)
            // verify required parameter 'flowCategoryCreateRequest' is not null or undefined
            assertParamExists('createFlowCategory', 'flowCategoryCreateRequest', flowCategoryCreateRequest)
            const localVarPath = `/v2/flows/categories/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCategoryCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Flow Cron
         * @param {string} workspaceId 
         * @param {FlowCronCreateRequest} flowCronCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowCron: async (workspaceId: string, flowCronCreateRequest: FlowCronCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createFlowCron', 'workspaceId', workspaceId)
            // verify required parameter 'flowCronCreateRequest' is not null or undefined
            assertParamExists('createFlowCron', 'flowCronCreateRequest', flowCronCreateRequest)
            const localVarPath = `/v2/flows/crons/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCronCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Flow Session
         * @param {string} workspaceId 
         * @param {FlowSessionCreateFromFlowRequest} flowSessionCreateFromFlowRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowSession: async (workspaceId: string, flowSessionCreateFromFlowRequest: FlowSessionCreateFromFlowRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createFlowSession', 'workspaceId', workspaceId)
            // verify required parameter 'flowSessionCreateFromFlowRequest' is not null or undefined
            assertParamExists('createFlowSession', 'flowSessionCreateFromFlowRequest', flowSessionCreateFromFlowRequest)
            const localVarPath = `/v2/flows/sessions/from_flow/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowSessionCreateFromFlowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Message Feedback
         * @param {string} sessionId 
         * @param {FlowMessageFeedbackRequest} flowMessageFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageFeedback: async (sessionId: string, flowMessageFeedbackRequest: FlowMessageFeedbackRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('createMessageFeedback', 'sessionId', sessionId)
            // verify required parameter 'flowMessageFeedbackRequest' is not null or undefined
            assertParamExists('createMessageFeedback', 'flowMessageFeedbackRequest', flowMessageFeedbackRequest)
            const localVarPath = `/v2/flows/sessions/{session_id}/feedback`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowMessageFeedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Attachment
         * @param {string} sessionId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment: async (sessionId: string, fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deleteAttachment', 'sessionId', sessionId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('deleteAttachment', 'fileId', fileId)
            const localVarPath = `/v2/flows/sessions/{session_id}/attachments/{file_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlow: async (flowId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('deleteFlow', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteFlow', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/{flow_id}`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Flow Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlowCategory: async (catId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('deleteFlowCategory', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteFlowCategory', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/categories/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Flow Cron
         * @param {string} flowId 
         * @param {string} cronId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlowCron: async (flowId: string, cronId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('deleteFlowCron', 'flowId', flowId)
            // verify required parameter 'cronId' is not null or undefined
            assertParamExists('deleteFlowCron', 'cronId', cronId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteFlowCron', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/crons/{flow_id}/{cron_id}`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)))
                .replace(`{${"cron_id"}}`, encodeURIComponent(String(cronId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute Flow Cron
         * @param {string} cronId 
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeFlowCron: async (cronId: string, flowId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cronId' is not null or undefined
            assertParamExists('executeFlowCron', 'cronId', cronId)
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('executeFlowCron', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('executeFlowCron', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/crons/{flow_id}/{cron_id}/execute`
                .replace(`{${"cron_id"}}`, encodeURIComponent(String(cronId)))
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate Commit Message
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCommitMessage: async (flowId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('generateCommitMessage', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('generateCommitMessage', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/{flow_id}/generate-commit-msg`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {string} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (flowId: string, workspaceId: string, branch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('get', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('get', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/{flow_id}`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllComponents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/flows/components/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the content of a specific artefact file created by Deep Agent
         * @summary Get artefact content
         * @param {string} sessionId 
         * @param {string} artefactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtefactContent: async (sessionId: string, artefactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getArtefactContent', 'sessionId', sessionId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('getArtefactContent', 'artefactId', artefactId)
            const localVarPath = `/v2/flows/sessions/{session_id}/artefacts/{artefact_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"artefact_id"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Attachments
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getAttachments', 'sessionId', sessionId)
            const localVarPath = `/v2/flows/sessions/{session_id}/attachments`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Flow Versions
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlowVersions: async (flowId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('getFlowVersions', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getFlowVersions', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/{flow_id}/version_history`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Invoked Flow Results
         * @param {string} flowId 
         * @param {string} taskId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvokedFlowResults: async (flowId: string, taskId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('getInvokedFlowResults', 'flowId', flowId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getInvokedFlowResults', 'taskId', taskId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getInvokedFlowResults', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/{flow_id}/{task_id}`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Public Flow
         * @param {string} flowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicFlow: async (flowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('getPublicFlow', 'flowId', flowId)
            const localVarPath = `/v2/flows/public/{flow_id}`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Trigger Types
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerTypes: async (flowId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('getTriggerTypes', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getTriggerTypes', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/{flow_id}/triggers`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowInvokeRequest} flowInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlow: async (flowId: string, workspaceId: string, flowInvokeRequest: FlowInvokeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('invokeFlow', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('invokeFlow', 'workspaceId', workspaceId)
            // verify required parameter 'flowInvokeRequest' is not null or undefined
            assertParamExists('invokeFlow', 'flowInvokeRequest', flowInvokeRequest)
            const localVarPath = `/v2/flows/{flow_id}/invoke`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowInvokeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke Flow Response
         * @param {string} sessionId 
         * @param {FlowSessionInvokeRequest} flowSessionInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlowResponse: async (sessionId: string, flowSessionInvokeRequest: FlowSessionInvokeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('invokeFlowResponse', 'sessionId', sessionId)
            // verify required parameter 'flowSessionInvokeRequest' is not null or undefined
            assertParamExists('invokeFlowResponse', 'flowSessionInvokeRequest', flowSessionInvokeRequest)
            const localVarPath = `/v2/flows/sessions/{session_id}/invoke`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowSessionInvokeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke Flow Singleton
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowInvokeRequest} flowInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlowSingleton: async (flowId: string, workspaceId: string, flowInvokeRequest: FlowInvokeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('invokeFlowSingleton', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('invokeFlowSingleton', 'workspaceId', workspaceId)
            // verify required parameter 'flowInvokeRequest' is not null or undefined
            assertParamExists('invokeFlowSingleton', 'flowInvokeRequest', flowInvokeRequest)
            const localVarPath = `/v2/flows/{flow_id}/invoke_singleton`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowInvokeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Poll Flow Response
         * @param {string} sessionId 
         * @param {string} fromTimestamp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollFlowResponse: async (sessionId: string, fromTimestamp: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('pollFlowResponse', 'sessionId', sessionId)
            // verify required parameter 'fromTimestamp' is not null or undefined
            assertParamExists('pollFlowResponse', 'fromTimestamp', fromTimestamp)
            const localVarPath = `/v2/flows/sessions/{session_id}/invocation_response/{from_timestamp}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"from_timestamp"}}`, encodeURIComponent(String(fromTimestamp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowCommitRequest} flowCommitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishFlow: async (flowId: string, workspaceId: string, flowCommitRequest: FlowCommitRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('publishFlow', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('publishFlow', 'workspaceId', workspaceId)
            // verify required parameter 'flowCommitRequest' is not null or undefined
            assertParamExists('publishFlow', 'flowCommitRequest', flowCommitRequest)
            const localVarPath = `/v2/flows/{flow_id}/publish`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCommitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore Flow Version
         * @param {string} flowId 
         * @param {string} branch 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreFlowVersion: async (flowId: string, branch: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('restoreFlowVersion', 'flowId', flowId)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('restoreFlowVersion', 'branch', branch)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('restoreFlowVersion', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/{flow_id}/version_history/{branch}/restore`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search
         * @param {string | null} workspaceId 
         * @param {FlowSearchRequest} flowSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (workspaceId: string | null, flowSearchRequest: FlowSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('search', 'workspaceId', workspaceId)
            // verify required parameter 'flowSearchRequest' is not null or undefined
            assertParamExists('search', 'flowSearchRequest', flowSearchRequest)
            const localVarPath = `/v2/flows/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search All
         * @param {string} workspaceId 
         * @param {AllFlowsSearchRequest} allFlowsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAll: async (workspaceId: string, allFlowsSearchRequest: AllFlowsSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchAll', 'workspaceId', workspaceId)
            // verify required parameter 'allFlowsSearchRequest' is not null or undefined
            assertParamExists('searchAll', 'allFlowsSearchRequest', allFlowsSearchRequest)
            const localVarPath = `/v2/flows/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(allFlowsSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Flow Categories
         * @param {string} workspaceId 
         * @param {FlowCategorySearchRequest} flowCategorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlowCategories: async (workspaceId: string, flowCategorySearchRequest: FlowCategorySearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchFlowCategories', 'workspaceId', workspaceId)
            // verify required parameter 'flowCategorySearchRequest' is not null or undefined
            assertParamExists('searchFlowCategories', 'flowCategorySearchRequest', flowCategorySearchRequest)
            const localVarPath = `/v2/flows/categories/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCategorySearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Flow Crons
         * @param {string} workspaceId 
         * @param {FlowCronSearchRequest} flowCronSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlowCrons: async (workspaceId: string, flowCronSearchRequest: FlowCronSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchFlowCrons', 'workspaceId', workspaceId)
            // verify required parameter 'flowCronSearchRequest' is not null or undefined
            assertParamExists('searchFlowCrons', 'flowCronSearchRequest', flowCronSearchRequest)
            const localVarPath = `/v2/flows/crons/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCronSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowUpdate} flowUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlow: async (flowId: string, workspaceId: string, flowUpdate: FlowUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('updateFlow', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateFlow', 'workspaceId', workspaceId)
            // verify required parameter 'flowUpdate' is not null or undefined
            assertParamExists('updateFlow', 'flowUpdate', flowUpdate)
            const localVarPath = `/v2/flows/{flow_id}`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Flow Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {FlowCategoryCreateRequest} flowCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlowCategory: async (catId: string, workspaceId: string, flowCategoryCreateRequest: FlowCategoryCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('updateFlowCategory', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateFlowCategory', 'workspaceId', workspaceId)
            // verify required parameter 'flowCategoryCreateRequest' is not null or undefined
            assertParamExists('updateFlowCategory', 'flowCategoryCreateRequest', flowCategoryCreateRequest)
            const localVarPath = `/v2/flows/categories/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCategoryCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Flow Cron
         * @param {string} cronId 
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowCronUpdateRequest} flowCronUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlowCron: async (cronId: string, flowId: string, workspaceId: string, flowCronUpdateRequest: FlowCronUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cronId' is not null or undefined
            assertParamExists('updateFlowCron', 'cronId', cronId)
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('updateFlowCron', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateFlowCron', 'workspaceId', workspaceId)
            // verify required parameter 'flowCronUpdateRequest' is not null or undefined
            assertParamExists('updateFlowCron', 'flowCronUpdateRequest', flowCronUpdateRequest)
            const localVarPath = `/v2/flows/crons/{flow_id}/{cron_id}`
                .replace(`{${"cron_id"}}`, encodeURIComponent(String(cronId)))
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCronUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Attachments
         * @param {string} sessionId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachments: async (sessionId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('uploadAttachments', 'sessionId', sessionId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadAttachments', 'file', file)
            const localVarPath = `/v2/flows/sessions/{session_id}/attachments`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlowsApi - functional programming interface
 * @export
 */
export const FlowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlowsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Chatbot Session
         * @param {string} workspaceId 
         * @param {FlowSessionCreateRequest} flowSessionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChatbotSession(workspaceId: string, flowSessionCreateRequest: FlowSessionCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChatbotSession(workspaceId, flowSessionCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.createChatbotSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Flow
         * @param {string} workspaceId 
         * @param {FlowCreate} flowCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFlow(workspaceId: string, flowCreate: FlowCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFlow(workspaceId, flowCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.createFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Flow Category
         * @param {string} workspaceId 
         * @param {FlowCategoryCreateRequest} flowCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFlowCategory(workspaceId: string, flowCategoryCreateRequest: FlowCategoryCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFlowCategory(workspaceId, flowCategoryCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.createFlowCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Flow Cron
         * @param {string} workspaceId 
         * @param {FlowCronCreateRequest} flowCronCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFlowCron(workspaceId: string, flowCronCreateRequest: FlowCronCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowCronResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFlowCron(workspaceId, flowCronCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.createFlowCron']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Flow Session
         * @param {string} workspaceId 
         * @param {FlowSessionCreateFromFlowRequest} flowSessionCreateFromFlowRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFlowSession(workspaceId: string, flowSessionCreateFromFlowRequest: FlowSessionCreateFromFlowRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFlowSession(workspaceId, flowSessionCreateFromFlowRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.createFlowSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Message Feedback
         * @param {string} sessionId 
         * @param {FlowMessageFeedbackRequest} flowMessageFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessageFeedback(sessionId: string, flowMessageFeedbackRequest: FlowMessageFeedbackRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowMessageFeedbackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessageFeedback(sessionId, flowMessageFeedbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.createMessageFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Attachment
         * @param {string} sessionId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttachment(sessionId: string, fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttachment(sessionId, fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.deleteAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlow(flowId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlow(flowId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.deleteFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Flow Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlowCategory(catId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlowCategory(catId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.deleteFlowCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Flow Cron
         * @param {string} flowId 
         * @param {string} cronId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlowCron(flowId: string, cronId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlowCron(flowId, cronId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.deleteFlowCron']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Execute Flow Cron
         * @param {string} cronId 
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeFlowCron(cronId: string, flowId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeFlowCron(cronId, flowId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.executeFlowCron']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate Commit Message
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateCommitMessage(flowId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowCommitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateCommitMessage(flowId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.generateCommitMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {string} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(flowId: string, workspaceId: string, branch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(flowId, workspaceId, branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllComponents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllComponents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.getAllComponents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the content of a specific artefact file created by Deep Agent
         * @summary Get artefact content
         * @param {string} sessionId 
         * @param {string} artefactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtefactContent(sessionId: string, artefactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionArtefactContentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtefactContent(sessionId, artefactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.getArtefactContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Attachments
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachments(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowSessionAttachmentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachments(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.getAttachments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Flow Versions
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlowVersions(flowId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowVersionHistoryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlowVersions(flowId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.getFlowVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Invoked Flow Results
         * @param {string} flowId 
         * @param {string} taskId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvokedFlowResults(flowId: string, taskId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvokedFlowResults(flowId, taskId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.getInvokedFlowResults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Public Flow
         * @param {string} flowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicFlow(flowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicFlow(flowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.getPublicFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Trigger Types
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTriggerTypes(flowId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTriggerTypes(flowId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.getTriggerTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowInvokeRequest} flowInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invokeFlow(flowId: string, workspaceId: string, flowInvokeRequest: FlowInvokeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invokeFlow(flowId, workspaceId, flowInvokeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.invokeFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke Flow Response
         * @param {string} sessionId 
         * @param {FlowSessionInvokeRequest} flowSessionInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invokeFlowResponse(sessionId: string, flowSessionInvokeRequest: FlowSessionInvokeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionInvocationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invokeFlowResponse(sessionId, flowSessionInvokeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.invokeFlowResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke Flow Singleton
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowInvokeRequest} flowInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invokeFlowSingleton(flowId: string, workspaceId: string, flowInvokeRequest: FlowInvokeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invokeFlowSingleton(flowId, workspaceId, flowInvokeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.invokeFlowSingleton']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Poll Flow Response
         * @param {string} sessionId 
         * @param {string} fromTimestamp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pollFlowResponse(sessionId: string, fromTimestamp: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowSessionEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pollFlowResponse(sessionId, fromTimestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.pollFlowResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Publish Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowCommitRequest} flowCommitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishFlow(flowId: string, workspaceId: string, flowCommitRequest: FlowCommitRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishFlow(flowId, workspaceId, flowCommitRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.publishFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore Flow Version
         * @param {string} flowId 
         * @param {string} branch 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreFlowVersion(flowId: string, branch: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreFlowVersion(flowId, branch, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.restoreFlowVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search
         * @param {string | null} workspaceId 
         * @param {FlowSearchRequest} flowSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(workspaceId: string | null, flowSearchRequest: FlowSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(workspaceId, flowSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.search']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search All
         * @param {string} workspaceId 
         * @param {AllFlowsSearchRequest} allFlowsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAll(workspaceId: string, allFlowsSearchRequest: AllFlowsSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAll(workspaceId, allFlowsSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.searchAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Flow Categories
         * @param {string} workspaceId 
         * @param {FlowCategorySearchRequest} flowCategorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchFlowCategories(workspaceId: string, flowCategorySearchRequest: FlowCategorySearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowCategoryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFlowCategories(workspaceId, flowCategorySearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.searchFlowCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Flow Crons
         * @param {string} workspaceId 
         * @param {FlowCronSearchRequest} flowCronSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchFlowCrons(workspaceId: string, flowCronSearchRequest: FlowCronSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowCronResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFlowCrons(workspaceId, flowCronSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.searchFlowCrons']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowUpdate} flowUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFlow(flowId: string, workspaceId: string, flowUpdate: FlowUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFlow(flowId, workspaceId, flowUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.updateFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Flow Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {FlowCategoryCreateRequest} flowCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFlowCategory(catId: string, workspaceId: string, flowCategoryCreateRequest: FlowCategoryCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFlowCategory(catId, workspaceId, flowCategoryCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.updateFlowCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Flow Cron
         * @param {string} cronId 
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowCronUpdateRequest} flowCronUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFlowCron(cronId: string, flowId: string, workspaceId: string, flowCronUpdateRequest: FlowCronUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowCronResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFlowCron(cronId, flowId, workspaceId, flowCronUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.updateFlowCron']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Attachments
         * @param {string} sessionId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadAttachments(sessionId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionAttachmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadAttachments(sessionId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.uploadAttachments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FlowsApi - factory interface
 * @export
 */
export const FlowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlowsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Chatbot Session
         * @param {FlowsApiCreateChatbotSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatbotSession(requestParameters: FlowsApiCreateChatbotSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionResponse> {
            return localVarFp.createChatbotSession(requestParameters.workspaceId, requestParameters.flowSessionCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Flow
         * @param {FlowsApiCreateFlowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlow(requestParameters: FlowsApiCreateFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse> {
            return localVarFp.createFlow(requestParameters.workspaceId, requestParameters.flowCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Flow Category
         * @param {FlowsApiCreateFlowCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowCategory(requestParameters: FlowsApiCreateFlowCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCategoryResponse> {
            return localVarFp.createFlowCategory(requestParameters.workspaceId, requestParameters.flowCategoryCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Flow Cron
         * @param {FlowsApiCreateFlowCronRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowCron(requestParameters: FlowsApiCreateFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCronResponse> {
            return localVarFp.createFlowCron(requestParameters.workspaceId, requestParameters.flowCronCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Flow Session
         * @param {FlowsApiCreateFlowSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowSession(requestParameters: FlowsApiCreateFlowSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionResponse> {
            return localVarFp.createFlowSession(requestParameters.workspaceId, requestParameters.flowSessionCreateFromFlowRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Message Feedback
         * @param {FlowsApiCreateMessageFeedbackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageFeedback(requestParameters: FlowsApiCreateMessageFeedbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowMessageFeedbackResponse> {
            return localVarFp.createMessageFeedback(requestParameters.sessionId, requestParameters.flowMessageFeedbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Attachment
         * @param {FlowsApiDeleteAttachmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(requestParameters: FlowsApiDeleteAttachmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteAttachment(requestParameters.sessionId, requestParameters.fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Flow
         * @param {FlowsApiDeleteFlowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlow(requestParameters: FlowsApiDeleteFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteFlow(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Flow Category
         * @param {FlowsApiDeleteFlowCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlowCategory(requestParameters: FlowsApiDeleteFlowCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteFlowCategory(requestParameters.catId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Flow Cron
         * @param {FlowsApiDeleteFlowCronRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlowCron(requestParameters: FlowsApiDeleteFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteFlowCron(requestParameters.flowId, requestParameters.cronId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute Flow Cron
         * @param {FlowsApiExecuteFlowCronRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeFlowCron(requestParameters: FlowsApiExecuteFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.executeFlowCron(requestParameters.cronId, requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate Commit Message
         * @param {FlowsApiGenerateCommitMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCommitMessage(requestParameters: FlowsApiGenerateCommitMessageRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCommitResponse> {
            return localVarFp.generateCommitMessage(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get
         * @param {FlowsApiGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(requestParameters: FlowsApiGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse> {
            return localVarFp.get(requestParameters.flowId, requestParameters.workspaceId, requestParameters.branch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllComponents(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getAllComponents(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the content of a specific artefact file created by Deep Agent
         * @summary Get artefact content
         * @param {FlowsApiGetArtefactContentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtefactContent(requestParameters: FlowsApiGetArtefactContentRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionArtefactContentResponse> {
            return localVarFp.getArtefactContent(requestParameters.sessionId, requestParameters.artefactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Attachments
         * @param {FlowsApiGetAttachmentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(requestParameters: FlowsApiGetAttachmentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionAttachmentResponse>> {
            return localVarFp.getAttachments(requestParameters.sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Flow Versions
         * @param {FlowsApiGetFlowVersionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlowVersions(requestParameters: FlowsApiGetFlowVersionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowVersionHistoryResponse>> {
            return localVarFp.getFlowVersions(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Invoked Flow Results
         * @param {FlowsApiGetInvokedFlowResultsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvokedFlowResults(requestParameters: FlowsApiGetInvokedFlowResultsRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.getInvokedFlowResults(requestParameters.flowId, requestParameters.taskId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Public Flow
         * @param {FlowsApiGetPublicFlowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicFlow(requestParameters: FlowsApiGetPublicFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse> {
            return localVarFp.getPublicFlow(requestParameters.flowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Trigger Types
         * @param {FlowsApiGetTriggerTypesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerTypes(requestParameters: FlowsApiGetTriggerTypesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TriggerResponse> {
            return localVarFp.getTriggerTypes(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke Flow
         * @param {FlowsApiInvokeFlowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlow(requestParameters: FlowsApiInvokeFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.invokeFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowInvokeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke Flow Response
         * @param {FlowsApiInvokeFlowResponseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlowResponse(requestParameters: FlowsApiInvokeFlowResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse> {
            return localVarFp.invokeFlowResponse(requestParameters.sessionId, requestParameters.flowSessionInvokeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke Flow Singleton
         * @param {FlowsApiInvokeFlowSingletonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlowSingleton(requestParameters: FlowsApiInvokeFlowSingletonRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.invokeFlowSingleton(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowInvokeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Poll Flow Response
         * @param {FlowsApiPollFlowResponseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollFlowResponse(requestParameters: FlowsApiPollFlowResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionEvent>> {
            return localVarFp.pollFlowResponse(requestParameters.sessionId, requestParameters.fromTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publish Flow
         * @param {FlowsApiPublishFlowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishFlow(requestParameters: FlowsApiPublishFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse> {
            return localVarFp.publishFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowCommitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore Flow Version
         * @param {FlowsApiRestoreFlowVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreFlowVersion(requestParameters: FlowsApiRestoreFlowVersionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.restoreFlowVersion(requestParameters.flowId, requestParameters.branch, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search
         * @param {FlowsApiSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(requestParameters: FlowsApiSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowResponse>> {
            return localVarFp.search(requestParameters.workspaceId, requestParameters.flowSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search All
         * @param {FlowsApiSearchAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAll(requestParameters: FlowsApiSearchAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowResponse>> {
            return localVarFp.searchAll(requestParameters.workspaceId, requestParameters.allFlowsSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Flow Categories
         * @param {FlowsApiSearchFlowCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlowCategories(requestParameters: FlowsApiSearchFlowCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowCategoryResponse>> {
            return localVarFp.searchFlowCategories(requestParameters.workspaceId, requestParameters.flowCategorySearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Flow Crons
         * @param {FlowsApiSearchFlowCronsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlowCrons(requestParameters: FlowsApiSearchFlowCronsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowCronResponse>> {
            return localVarFp.searchFlowCrons(requestParameters.workspaceId, requestParameters.flowCronSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Flow
         * @param {FlowsApiUpdateFlowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlow(requestParameters: FlowsApiUpdateFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse> {
            return localVarFp.updateFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Flow Category
         * @param {FlowsApiUpdateFlowCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlowCategory(requestParameters: FlowsApiUpdateFlowCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCategoryResponse> {
            return localVarFp.updateFlowCategory(requestParameters.catId, requestParameters.workspaceId, requestParameters.flowCategoryCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Flow Cron
         * @param {FlowsApiUpdateFlowCronRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlowCron(requestParameters: FlowsApiUpdateFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCronResponse> {
            return localVarFp.updateFlowCron(requestParameters.cronId, requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowCronUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Attachments
         * @param {FlowsApiUploadAttachmentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachments(requestParameters: FlowsApiUploadAttachmentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionAttachmentResponse> {
            return localVarFp.uploadAttachments(requestParameters.sessionId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlowsApi - interface
 * @export
 * @interface FlowsApi
 */
export interface FlowsApiInterface {
    /**
     * 
     * @summary Create Chatbot Session
     * @param {FlowsApiCreateChatbotSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    createChatbotSession(requestParameters: FlowsApiCreateChatbotSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionResponse>;

    /**
     * 
     * @summary Create Flow
     * @param {FlowsApiCreateFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    createFlow(requestParameters: FlowsApiCreateFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse>;

    /**
     * 
     * @summary Create Flow Category
     * @param {FlowsApiCreateFlowCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    createFlowCategory(requestParameters: FlowsApiCreateFlowCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCategoryResponse>;

    /**
     * 
     * @summary Create Flow Cron
     * @param {FlowsApiCreateFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    createFlowCron(requestParameters: FlowsApiCreateFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCronResponse>;

    /**
     * 
     * @summary Create Flow Session
     * @param {FlowsApiCreateFlowSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    createFlowSession(requestParameters: FlowsApiCreateFlowSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionResponse>;

    /**
     * 
     * @summary Create Message Feedback
     * @param {FlowsApiCreateMessageFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    createMessageFeedback(requestParameters: FlowsApiCreateMessageFeedbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowMessageFeedbackResponse>;

    /**
     * 
     * @summary Delete Attachment
     * @param {FlowsApiDeleteAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    deleteAttachment(requestParameters: FlowsApiDeleteAttachmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Delete Flow
     * @param {FlowsApiDeleteFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    deleteFlow(requestParameters: FlowsApiDeleteFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Delete Flow Category
     * @param {FlowsApiDeleteFlowCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    deleteFlowCategory(requestParameters: FlowsApiDeleteFlowCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Delete Flow Cron
     * @param {FlowsApiDeleteFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    deleteFlowCron(requestParameters: FlowsApiDeleteFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Execute Flow Cron
     * @param {FlowsApiExecuteFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    executeFlowCron(requestParameters: FlowsApiExecuteFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

    /**
     * 
     * @summary Generate Commit Message
     * @param {FlowsApiGenerateCommitMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    generateCommitMessage(requestParameters: FlowsApiGenerateCommitMessageRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCommitResponse>;

    /**
     * 
     * @summary Get
     * @param {FlowsApiGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    get(requestParameters: FlowsApiGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse>;

    /**
     * 
     * @summary Get All Components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    getAllComponents(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Retrieve the content of a specific artefact file created by Deep Agent
     * @summary Get artefact content
     * @param {FlowsApiGetArtefactContentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    getArtefactContent(requestParameters: FlowsApiGetArtefactContentRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionArtefactContentResponse>;

    /**
     * 
     * @summary Get Attachments
     * @param {FlowsApiGetAttachmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    getAttachments(requestParameters: FlowsApiGetAttachmentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionAttachmentResponse>>;

    /**
     * 
     * @summary Get Flow Versions
     * @param {FlowsApiGetFlowVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    getFlowVersions(requestParameters: FlowsApiGetFlowVersionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowVersionHistoryResponse>>;

    /**
     * 
     * @summary Get Invoked Flow Results
     * @param {FlowsApiGetInvokedFlowResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    getInvokedFlowResults(requestParameters: FlowsApiGetInvokedFlowResultsRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

    /**
     * 
     * @summary Get Public Flow
     * @param {FlowsApiGetPublicFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    getPublicFlow(requestParameters: FlowsApiGetPublicFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse>;

    /**
     * 
     * @summary Get Trigger Types
     * @param {FlowsApiGetTriggerTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    getTriggerTypes(requestParameters: FlowsApiGetTriggerTypesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TriggerResponse>;

    /**
     * 
     * @summary Invoke Flow
     * @param {FlowsApiInvokeFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    invokeFlow(requestParameters: FlowsApiInvokeFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

    /**
     * 
     * @summary Invoke Flow Response
     * @param {FlowsApiInvokeFlowResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    invokeFlowResponse(requestParameters: FlowsApiInvokeFlowResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse>;

    /**
     * 
     * @summary Invoke Flow Singleton
     * @param {FlowsApiInvokeFlowSingletonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    invokeFlowSingleton(requestParameters: FlowsApiInvokeFlowSingletonRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

    /**
     * 
     * @summary Poll Flow Response
     * @param {FlowsApiPollFlowResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    pollFlowResponse(requestParameters: FlowsApiPollFlowResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionEvent>>;

    /**
     * 
     * @summary Publish Flow
     * @param {FlowsApiPublishFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    publishFlow(requestParameters: FlowsApiPublishFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse>;

    /**
     * 
     * @summary Restore Flow Version
     * @param {FlowsApiRestoreFlowVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    restoreFlowVersion(requestParameters: FlowsApiRestoreFlowVersionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Search
     * @param {FlowsApiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    search(requestParameters: FlowsApiSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowResponse>>;

    /**
     * 
     * @summary Search All
     * @param {FlowsApiSearchAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    searchAll(requestParameters: FlowsApiSearchAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowResponse>>;

    /**
     * 
     * @summary Search Flow Categories
     * @param {FlowsApiSearchFlowCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    searchFlowCategories(requestParameters: FlowsApiSearchFlowCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowCategoryResponse>>;

    /**
     * 
     * @summary Search Flow Crons
     * @param {FlowsApiSearchFlowCronsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    searchFlowCrons(requestParameters: FlowsApiSearchFlowCronsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowCronResponse>>;

    /**
     * 
     * @summary Update Flow
     * @param {FlowsApiUpdateFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    updateFlow(requestParameters: FlowsApiUpdateFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse>;

    /**
     * 
     * @summary Update Flow Category
     * @param {FlowsApiUpdateFlowCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    updateFlowCategory(requestParameters: FlowsApiUpdateFlowCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCategoryResponse>;

    /**
     * 
     * @summary Update Flow Cron
     * @param {FlowsApiUpdateFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    updateFlowCron(requestParameters: FlowsApiUpdateFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCronResponse>;

    /**
     * 
     * @summary Upload Attachments
     * @param {FlowsApiUploadAttachmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    uploadAttachments(requestParameters: FlowsApiUploadAttachmentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionAttachmentResponse>;

}

/**
 * Request parameters for createChatbotSession operation in FlowsApi.
 * @export
 * @interface FlowsApiCreateChatbotSessionRequest
 */
export interface FlowsApiCreateChatbotSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiCreateChatbotSession
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowSessionCreateRequest}
     * @memberof FlowsApiCreateChatbotSession
     */
    readonly flowSessionCreateRequest: FlowSessionCreateRequest
}

/**
 * Request parameters for createFlow operation in FlowsApi.
 * @export
 * @interface FlowsApiCreateFlowRequest
 */
export interface FlowsApiCreateFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiCreateFlow
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCreate}
     * @memberof FlowsApiCreateFlow
     */
    readonly flowCreate: FlowCreate
}

/**
 * Request parameters for createFlowCategory operation in FlowsApi.
 * @export
 * @interface FlowsApiCreateFlowCategoryRequest
 */
export interface FlowsApiCreateFlowCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiCreateFlowCategory
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCategoryCreateRequest}
     * @memberof FlowsApiCreateFlowCategory
     */
    readonly flowCategoryCreateRequest: FlowCategoryCreateRequest
}

/**
 * Request parameters for createFlowCron operation in FlowsApi.
 * @export
 * @interface FlowsApiCreateFlowCronRequest
 */
export interface FlowsApiCreateFlowCronRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiCreateFlowCron
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCronCreateRequest}
     * @memberof FlowsApiCreateFlowCron
     */
    readonly flowCronCreateRequest: FlowCronCreateRequest
}

/**
 * Request parameters for createFlowSession operation in FlowsApi.
 * @export
 * @interface FlowsApiCreateFlowSessionRequest
 */
export interface FlowsApiCreateFlowSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiCreateFlowSession
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowSessionCreateFromFlowRequest}
     * @memberof FlowsApiCreateFlowSession
     */
    readonly flowSessionCreateFromFlowRequest: FlowSessionCreateFromFlowRequest
}

/**
 * Request parameters for createMessageFeedback operation in FlowsApi.
 * @export
 * @interface FlowsApiCreateMessageFeedbackRequest
 */
export interface FlowsApiCreateMessageFeedbackRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiCreateMessageFeedback
     */
    readonly sessionId: string

    /**
     * 
     * @type {FlowMessageFeedbackRequest}
     * @memberof FlowsApiCreateMessageFeedback
     */
    readonly flowMessageFeedbackRequest: FlowMessageFeedbackRequest
}

/**
 * Request parameters for deleteAttachment operation in FlowsApi.
 * @export
 * @interface FlowsApiDeleteAttachmentRequest
 */
export interface FlowsApiDeleteAttachmentRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteAttachment
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteAttachment
     */
    readonly fileId: string
}

/**
 * Request parameters for deleteFlow operation in FlowsApi.
 * @export
 * @interface FlowsApiDeleteFlowRequest
 */
export interface FlowsApiDeleteFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteFlow
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteFlow
     */
    readonly workspaceId: string
}

/**
 * Request parameters for deleteFlowCategory operation in FlowsApi.
 * @export
 * @interface FlowsApiDeleteFlowCategoryRequest
 */
export interface FlowsApiDeleteFlowCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteFlowCategory
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteFlowCategory
     */
    readonly workspaceId: string
}

/**
 * Request parameters for deleteFlowCron operation in FlowsApi.
 * @export
 * @interface FlowsApiDeleteFlowCronRequest
 */
export interface FlowsApiDeleteFlowCronRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteFlowCron
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteFlowCron
     */
    readonly cronId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteFlowCron
     */
    readonly workspaceId: string
}

/**
 * Request parameters for executeFlowCron operation in FlowsApi.
 * @export
 * @interface FlowsApiExecuteFlowCronRequest
 */
export interface FlowsApiExecuteFlowCronRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiExecuteFlowCron
     */
    readonly cronId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiExecuteFlowCron
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiExecuteFlowCron
     */
    readonly workspaceId: string
}

/**
 * Request parameters for generateCommitMessage operation in FlowsApi.
 * @export
 * @interface FlowsApiGenerateCommitMessageRequest
 */
export interface FlowsApiGenerateCommitMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiGenerateCommitMessage
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiGenerateCommitMessage
     */
    readonly workspaceId: string
}

/**
 * Request parameters for get operation in FlowsApi.
 * @export
 * @interface FlowsApiGetRequest
 */
export interface FlowsApiGetRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiGet
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiGet
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiGet
     */
    readonly branch?: string
}

/**
 * Request parameters for getArtefactContent operation in FlowsApi.
 * @export
 * @interface FlowsApiGetArtefactContentRequest
 */
export interface FlowsApiGetArtefactContentRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetArtefactContent
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetArtefactContent
     */
    readonly artefactId: string
}

/**
 * Request parameters for getAttachments operation in FlowsApi.
 * @export
 * @interface FlowsApiGetAttachmentsRequest
 */
export interface FlowsApiGetAttachmentsRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetAttachments
     */
    readonly sessionId: string
}

/**
 * Request parameters for getFlowVersions operation in FlowsApi.
 * @export
 * @interface FlowsApiGetFlowVersionsRequest
 */
export interface FlowsApiGetFlowVersionsRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetFlowVersions
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetFlowVersions
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getInvokedFlowResults operation in FlowsApi.
 * @export
 * @interface FlowsApiGetInvokedFlowResultsRequest
 */
export interface FlowsApiGetInvokedFlowResultsRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetInvokedFlowResults
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetInvokedFlowResults
     */
    readonly taskId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetInvokedFlowResults
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getPublicFlow operation in FlowsApi.
 * @export
 * @interface FlowsApiGetPublicFlowRequest
 */
export interface FlowsApiGetPublicFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetPublicFlow
     */
    readonly flowId: string
}

/**
 * Request parameters for getTriggerTypes operation in FlowsApi.
 * @export
 * @interface FlowsApiGetTriggerTypesRequest
 */
export interface FlowsApiGetTriggerTypesRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetTriggerTypes
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetTriggerTypes
     */
    readonly workspaceId: string
}

/**
 * Request parameters for invokeFlow operation in FlowsApi.
 * @export
 * @interface FlowsApiInvokeFlowRequest
 */
export interface FlowsApiInvokeFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiInvokeFlow
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiInvokeFlow
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowInvokeRequest}
     * @memberof FlowsApiInvokeFlow
     */
    readonly flowInvokeRequest: FlowInvokeRequest
}

/**
 * Request parameters for invokeFlowResponse operation in FlowsApi.
 * @export
 * @interface FlowsApiInvokeFlowResponseRequest
 */
export interface FlowsApiInvokeFlowResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiInvokeFlowResponse
     */
    readonly sessionId: string

    /**
     * 
     * @type {FlowSessionInvokeRequest}
     * @memberof FlowsApiInvokeFlowResponse
     */
    readonly flowSessionInvokeRequest: FlowSessionInvokeRequest
}

/**
 * Request parameters for invokeFlowSingleton operation in FlowsApi.
 * @export
 * @interface FlowsApiInvokeFlowSingletonRequest
 */
export interface FlowsApiInvokeFlowSingletonRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiInvokeFlowSingleton
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiInvokeFlowSingleton
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowInvokeRequest}
     * @memberof FlowsApiInvokeFlowSingleton
     */
    readonly flowInvokeRequest: FlowInvokeRequest
}

/**
 * Request parameters for pollFlowResponse operation in FlowsApi.
 * @export
 * @interface FlowsApiPollFlowResponseRequest
 */
export interface FlowsApiPollFlowResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiPollFlowResponse
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiPollFlowResponse
     */
    readonly fromTimestamp: string
}

/**
 * Request parameters for publishFlow operation in FlowsApi.
 * @export
 * @interface FlowsApiPublishFlowRequest
 */
export interface FlowsApiPublishFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiPublishFlow
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiPublishFlow
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCommitRequest}
     * @memberof FlowsApiPublishFlow
     */
    readonly flowCommitRequest: FlowCommitRequest
}

/**
 * Request parameters for restoreFlowVersion operation in FlowsApi.
 * @export
 * @interface FlowsApiRestoreFlowVersionRequest
 */
export interface FlowsApiRestoreFlowVersionRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiRestoreFlowVersion
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiRestoreFlowVersion
     */
    readonly branch: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiRestoreFlowVersion
     */
    readonly workspaceId: string
}

/**
 * Request parameters for search operation in FlowsApi.
 * @export
 * @interface FlowsApiSearchRequest
 */
export interface FlowsApiSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiSearch
     */
    readonly workspaceId: string | null

    /**
     * 
     * @type {FlowSearchRequest}
     * @memberof FlowsApiSearch
     */
    readonly flowSearchRequest: FlowSearchRequest
}

/**
 * Request parameters for searchAll operation in FlowsApi.
 * @export
 * @interface FlowsApiSearchAllRequest
 */
export interface FlowsApiSearchAllRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiSearchAll
     */
    readonly workspaceId: string

    /**
     * 
     * @type {AllFlowsSearchRequest}
     * @memberof FlowsApiSearchAll
     */
    readonly allFlowsSearchRequest: AllFlowsSearchRequest
}

/**
 * Request parameters for searchFlowCategories operation in FlowsApi.
 * @export
 * @interface FlowsApiSearchFlowCategoriesRequest
 */
export interface FlowsApiSearchFlowCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiSearchFlowCategories
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCategorySearchRequest}
     * @memberof FlowsApiSearchFlowCategories
     */
    readonly flowCategorySearchRequest: FlowCategorySearchRequest
}

/**
 * Request parameters for searchFlowCrons operation in FlowsApi.
 * @export
 * @interface FlowsApiSearchFlowCronsRequest
 */
export interface FlowsApiSearchFlowCronsRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiSearchFlowCrons
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCronSearchRequest}
     * @memberof FlowsApiSearchFlowCrons
     */
    readonly flowCronSearchRequest: FlowCronSearchRequest
}

/**
 * Request parameters for updateFlow operation in FlowsApi.
 * @export
 * @interface FlowsApiUpdateFlowRequest
 */
export interface FlowsApiUpdateFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiUpdateFlow
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiUpdateFlow
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowUpdate}
     * @memberof FlowsApiUpdateFlow
     */
    readonly flowUpdate: FlowUpdate
}

/**
 * Request parameters for updateFlowCategory operation in FlowsApi.
 * @export
 * @interface FlowsApiUpdateFlowCategoryRequest
 */
export interface FlowsApiUpdateFlowCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiUpdateFlowCategory
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiUpdateFlowCategory
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCategoryCreateRequest}
     * @memberof FlowsApiUpdateFlowCategory
     */
    readonly flowCategoryCreateRequest: FlowCategoryCreateRequest
}

/**
 * Request parameters for updateFlowCron operation in FlowsApi.
 * @export
 * @interface FlowsApiUpdateFlowCronRequest
 */
export interface FlowsApiUpdateFlowCronRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiUpdateFlowCron
     */
    readonly cronId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiUpdateFlowCron
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiUpdateFlowCron
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCronUpdateRequest}
     * @memberof FlowsApiUpdateFlowCron
     */
    readonly flowCronUpdateRequest: FlowCronUpdateRequest
}

/**
 * Request parameters for uploadAttachments operation in FlowsApi.
 * @export
 * @interface FlowsApiUploadAttachmentsRequest
 */
export interface FlowsApiUploadAttachmentsRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiUploadAttachments
     */
    readonly sessionId: string

    /**
     * 
     * @type {File}
     * @memberof FlowsApiUploadAttachments
     */
    readonly file: File
}

/**
 * FlowsApi - object-oriented interface
 * @export
 * @class FlowsApi
 * @extends {BaseAPI}
 */
export class FlowsApi extends BaseAPI implements FlowsApiInterface {
    /**
     * 
     * @summary Create Chatbot Session
     * @param {FlowsApiCreateChatbotSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public createChatbotSession(requestParameters: FlowsApiCreateChatbotSessionRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).createChatbotSession(requestParameters.workspaceId, requestParameters.flowSessionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Flow
     * @param {FlowsApiCreateFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public createFlow(requestParameters: FlowsApiCreateFlowRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).createFlow(requestParameters.workspaceId, requestParameters.flowCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Flow Category
     * @param {FlowsApiCreateFlowCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public createFlowCategory(requestParameters: FlowsApiCreateFlowCategoryRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).createFlowCategory(requestParameters.workspaceId, requestParameters.flowCategoryCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Flow Cron
     * @param {FlowsApiCreateFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public createFlowCron(requestParameters: FlowsApiCreateFlowCronRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).createFlowCron(requestParameters.workspaceId, requestParameters.flowCronCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Flow Session
     * @param {FlowsApiCreateFlowSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public createFlowSession(requestParameters: FlowsApiCreateFlowSessionRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).createFlowSession(requestParameters.workspaceId, requestParameters.flowSessionCreateFromFlowRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Message Feedback
     * @param {FlowsApiCreateMessageFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public createMessageFeedback(requestParameters: FlowsApiCreateMessageFeedbackRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).createMessageFeedback(requestParameters.sessionId, requestParameters.flowMessageFeedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Attachment
     * @param {FlowsApiDeleteAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public deleteAttachment(requestParameters: FlowsApiDeleteAttachmentRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).deleteAttachment(requestParameters.sessionId, requestParameters.fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Flow
     * @param {FlowsApiDeleteFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public deleteFlow(requestParameters: FlowsApiDeleteFlowRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).deleteFlow(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Flow Category
     * @param {FlowsApiDeleteFlowCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public deleteFlowCategory(requestParameters: FlowsApiDeleteFlowCategoryRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).deleteFlowCategory(requestParameters.catId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Flow Cron
     * @param {FlowsApiDeleteFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public deleteFlowCron(requestParameters: FlowsApiDeleteFlowCronRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).deleteFlowCron(requestParameters.flowId, requestParameters.cronId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute Flow Cron
     * @param {FlowsApiExecuteFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public executeFlowCron(requestParameters: FlowsApiExecuteFlowCronRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).executeFlowCron(requestParameters.cronId, requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate Commit Message
     * @param {FlowsApiGenerateCommitMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public generateCommitMessage(requestParameters: FlowsApiGenerateCommitMessageRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).generateCommitMessage(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get
     * @param {FlowsApiGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public get(requestParameters: FlowsApiGetRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).get(requestParameters.flowId, requestParameters.workspaceId, requestParameters.branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public getAllComponents(options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).getAllComponents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the content of a specific artefact file created by Deep Agent
     * @summary Get artefact content
     * @param {FlowsApiGetArtefactContentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public getArtefactContent(requestParameters: FlowsApiGetArtefactContentRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).getArtefactContent(requestParameters.sessionId, requestParameters.artefactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Attachments
     * @param {FlowsApiGetAttachmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public getAttachments(requestParameters: FlowsApiGetAttachmentsRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).getAttachments(requestParameters.sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Flow Versions
     * @param {FlowsApiGetFlowVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public getFlowVersions(requestParameters: FlowsApiGetFlowVersionsRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).getFlowVersions(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Invoked Flow Results
     * @param {FlowsApiGetInvokedFlowResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public getInvokedFlowResults(requestParameters: FlowsApiGetInvokedFlowResultsRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).getInvokedFlowResults(requestParameters.flowId, requestParameters.taskId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Public Flow
     * @param {FlowsApiGetPublicFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public getPublicFlow(requestParameters: FlowsApiGetPublicFlowRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).getPublicFlow(requestParameters.flowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Trigger Types
     * @param {FlowsApiGetTriggerTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public getTriggerTypes(requestParameters: FlowsApiGetTriggerTypesRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).getTriggerTypes(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke Flow
     * @param {FlowsApiInvokeFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public invokeFlow(requestParameters: FlowsApiInvokeFlowRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).invokeFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowInvokeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke Flow Response
     * @param {FlowsApiInvokeFlowResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public invokeFlowResponse(requestParameters: FlowsApiInvokeFlowResponseRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).invokeFlowResponse(requestParameters.sessionId, requestParameters.flowSessionInvokeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke Flow Singleton
     * @param {FlowsApiInvokeFlowSingletonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public invokeFlowSingleton(requestParameters: FlowsApiInvokeFlowSingletonRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).invokeFlowSingleton(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowInvokeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Poll Flow Response
     * @param {FlowsApiPollFlowResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public pollFlowResponse(requestParameters: FlowsApiPollFlowResponseRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).pollFlowResponse(requestParameters.sessionId, requestParameters.fromTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publish Flow
     * @param {FlowsApiPublishFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public publishFlow(requestParameters: FlowsApiPublishFlowRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).publishFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowCommitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore Flow Version
     * @param {FlowsApiRestoreFlowVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public restoreFlowVersion(requestParameters: FlowsApiRestoreFlowVersionRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).restoreFlowVersion(requestParameters.flowId, requestParameters.branch, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search
     * @param {FlowsApiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public search(requestParameters: FlowsApiSearchRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).search(requestParameters.workspaceId, requestParameters.flowSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search All
     * @param {FlowsApiSearchAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public searchAll(requestParameters: FlowsApiSearchAllRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).searchAll(requestParameters.workspaceId, requestParameters.allFlowsSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Flow Categories
     * @param {FlowsApiSearchFlowCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public searchFlowCategories(requestParameters: FlowsApiSearchFlowCategoriesRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).searchFlowCategories(requestParameters.workspaceId, requestParameters.flowCategorySearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Flow Crons
     * @param {FlowsApiSearchFlowCronsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public searchFlowCrons(requestParameters: FlowsApiSearchFlowCronsRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).searchFlowCrons(requestParameters.workspaceId, requestParameters.flowCronSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Flow
     * @param {FlowsApiUpdateFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public updateFlow(requestParameters: FlowsApiUpdateFlowRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).updateFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Flow Category
     * @param {FlowsApiUpdateFlowCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public updateFlowCategory(requestParameters: FlowsApiUpdateFlowCategoryRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).updateFlowCategory(requestParameters.catId, requestParameters.workspaceId, requestParameters.flowCategoryCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Flow Cron
     * @param {FlowsApiUpdateFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public updateFlowCron(requestParameters: FlowsApiUpdateFlowCronRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).updateFlowCron(requestParameters.cronId, requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowCronUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Attachments
     * @param {FlowsApiUploadAttachmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public uploadAttachments(requestParameters: FlowsApiUploadAttachmentsRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).uploadAttachments(requestParameters.sessionId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GitHubApi - axios parameter creator
 * @export
 */
export const GitHubApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Repos
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepos: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRepos', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/github/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GitHubApi - functional programming interface
 * @export
 */
export const GitHubApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GitHubApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Repos
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepos(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitHubReposResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepos(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GitHubApi.getRepos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GitHubApi - factory interface
 * @export
 */
export const GitHubApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GitHubApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Repos
         * @param {GitHubApiGetReposRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepos(requestParameters: GitHubApiGetReposRequest, options?: RawAxiosRequestConfig): AxiosPromise<GitHubReposResponse> {
            return localVarFp.getRepos(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GitHubApi - interface
 * @export
 * @interface GitHubApi
 */
export interface GitHubApiInterface {
    /**
     * 
     * @summary Get Repos
     * @param {GitHubApiGetReposRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitHubApiInterface
     */
    getRepos(requestParameters: GitHubApiGetReposRequest, options?: RawAxiosRequestConfig): AxiosPromise<GitHubReposResponse>;

}

/**
 * Request parameters for getRepos operation in GitHubApi.
 * @export
 * @interface GitHubApiGetReposRequest
 */
export interface GitHubApiGetReposRequest {
    /**
     * 
     * @type {string}
     * @memberof GitHubApiGetRepos
     */
    readonly workspaceId: string
}

/**
 * GitHubApi - object-oriented interface
 * @export
 * @class GitHubApi
 * @extends {BaseAPI}
 */
export class GitHubApi extends BaseAPI implements GitHubApiInterface {
    /**
     * 
     * @summary Get Repos
     * @param {GitHubApiGetReposRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitHubApi
     */
    public getRepos(requestParameters: GitHubApiGetReposRequest, options?: RawAxiosRequestConfig) {
        return GitHubApiFp(this.configuration).getRepos(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoogleApi - axios parameter creator
 * @export
 */
export const GoogleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Calendars
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendars: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getCalendars', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/google/calendar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Picker Token
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPickerToken: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getPickerToken', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/google/picker_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Sheets
         * @param {string} documentId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSheets: async (documentId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getSheets', 'documentId', documentId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSheets', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/google/sheets/{document_id}`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleApi - functional programming interface
 * @export
 */
export const GoogleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoogleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Calendars
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalendars(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleCalendarsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalendars(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleApi.getCalendars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Picker Token
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPickerToken(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GooglePickerTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPickerToken(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleApi.getPickerToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Sheets
         * @param {string} documentId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSheets(documentId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleSheetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSheets(documentId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleApi.getSheets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GoogleApi - factory interface
 * @export
 */
export const GoogleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoogleApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Calendars
         * @param {GoogleApiGetCalendarsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendars(requestParameters: GoogleApiGetCalendarsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleCalendarsResponse> {
            return localVarFp.getCalendars(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Picker Token
         * @param {GoogleApiGetPickerTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPickerToken(requestParameters: GoogleApiGetPickerTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<GooglePickerTokenResponse> {
            return localVarFp.getPickerToken(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Sheets
         * @param {GoogleApiGetSheetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSheets(requestParameters: GoogleApiGetSheetsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleSheetsResponse> {
            return localVarFp.getSheets(requestParameters.documentId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoogleApi - interface
 * @export
 * @interface GoogleApi
 */
export interface GoogleApiInterface {
    /**
     * 
     * @summary Get Calendars
     * @param {GoogleApiGetCalendarsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleApiInterface
     */
    getCalendars(requestParameters: GoogleApiGetCalendarsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleCalendarsResponse>;

    /**
     * 
     * @summary Get Picker Token
     * @param {GoogleApiGetPickerTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleApiInterface
     */
    getPickerToken(requestParameters: GoogleApiGetPickerTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<GooglePickerTokenResponse>;

    /**
     * 
     * @summary Get Sheets
     * @param {GoogleApiGetSheetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleApiInterface
     */
    getSheets(requestParameters: GoogleApiGetSheetsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleSheetsResponse>;

}

/**
 * Request parameters for getCalendars operation in GoogleApi.
 * @export
 * @interface GoogleApiGetCalendarsRequest
 */
export interface GoogleApiGetCalendarsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleApiGetCalendars
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getPickerToken operation in GoogleApi.
 * @export
 * @interface GoogleApiGetPickerTokenRequest
 */
export interface GoogleApiGetPickerTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleApiGetPickerToken
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getSheets operation in GoogleApi.
 * @export
 * @interface GoogleApiGetSheetsRequest
 */
export interface GoogleApiGetSheetsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleApiGetSheets
     */
    readonly documentId: string

    /**
     * 
     * @type {string}
     * @memberof GoogleApiGetSheets
     */
    readonly workspaceId: string
}

/**
 * GoogleApi - object-oriented interface
 * @export
 * @class GoogleApi
 * @extends {BaseAPI}
 */
export class GoogleApi extends BaseAPI implements GoogleApiInterface {
    /**
     * 
     * @summary Get Calendars
     * @param {GoogleApiGetCalendarsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleApi
     */
    public getCalendars(requestParameters: GoogleApiGetCalendarsRequest, options?: RawAxiosRequestConfig) {
        return GoogleApiFp(this.configuration).getCalendars(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Picker Token
     * @param {GoogleApiGetPickerTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleApi
     */
    public getPickerToken(requestParameters: GoogleApiGetPickerTokenRequest, options?: RawAxiosRequestConfig) {
        return GoogleApiFp(this.configuration).getPickerToken(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Sheets
     * @param {GoogleApiGetSheetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleApi
     */
    public getSheets(requestParameters: GoogleApiGetSheetsRequest, options?: RawAxiosRequestConfig) {
        return GoogleApiFp(this.configuration).getSheets(requestParameters.documentId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoogleAdsApi - axios parameter creator
 * @export
 */
export const GoogleAdsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Keyword To Group
         * @param {string} workspaceId 
         * @param {GoogleAdsKeywordAddRequest} googleAdsKeywordAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addKeywordToGroup: async (workspaceId: string, googleAdsKeywordAddRequest: GoogleAdsKeywordAddRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addKeywordToGroup', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsKeywordAddRequest' is not null or undefined
            assertParamExists('addKeywordToGroup', 'googleAdsKeywordAddRequest', googleAdsKeywordAddRequest)
            const localVarPath = `/v2/integrations/google_ads/keyword/add_to_group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsKeywordAddRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Analyze Not Assigned Keywords
         * @param {string} workspaceId 
         * @param {GoogleAdsAnalyzeKeywordsRequest} googleAdsAnalyzeKeywordsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeNotAssignedKeywords: async (workspaceId: string, googleAdsAnalyzeKeywordsRequest: GoogleAdsAnalyzeKeywordsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('analyzeNotAssignedKeywords', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsAnalyzeKeywordsRequest' is not null or undefined
            assertParamExists('analyzeNotAssignedKeywords', 'googleAdsAnalyzeKeywordsRequest', googleAdsAnalyzeKeywordsRequest)
            const localVarPath = `/v2/integrations/google_ads/analyze_not_assigned_keywords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsAnalyzeKeywordsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Google Ads Campaigns
         * @param {string} workspaceId 
         * @param {GoogleAdsCampaignsSearchRequest} googleAdsCampaignsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoogleAdsCampaigns: async (workspaceId: string, googleAdsCampaignsSearchRequest: GoogleAdsCampaignsSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getGoogleAdsCampaigns', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsCampaignsSearchRequest' is not null or undefined
            assertParamExists('getGoogleAdsCampaigns', 'googleAdsCampaignsSearchRequest', googleAdsCampaignsSearchRequest)
            const localVarPath = `/v2/integrations/google_ads/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsCampaignsSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Google Ads Customers
         * @param {string} workspaceId 
         * @param {GoogleAdsCustomersSearchRequest} googleAdsCustomersSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoogleAdsCustomers: async (workspaceId: string, googleAdsCustomersSearchRequest: GoogleAdsCustomersSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getGoogleAdsCustomers', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsCustomersSearchRequest' is not null or undefined
            assertParamExists('getGoogleAdsCustomers', 'googleAdsCustomersSearchRequest', googleAdsCustomersSearchRequest)
            const localVarPath = `/v2/integrations/google_ads/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsCustomersSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Google Ads Groups
         * @param {string} workspaceId 
         * @param {GoogleAdsGroupsSearchRequest} googleAdsGroupsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoogleAdsGroups: async (workspaceId: string, googleAdsGroupsSearchRequest: GoogleAdsGroupsSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getGoogleAdsGroups', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsGroupsSearchRequest' is not null or undefined
            assertParamExists('getGoogleAdsGroups', 'googleAdsGroupsSearchRequest', googleAdsGroupsSearchRequest)
            const localVarPath = `/v2/integrations/google_ads/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsGroupsSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Recommendations
         * @param {string} workspaceId 
         * @param {GoogleAdsRecommendationsRequest} googleAdsRecommendationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendations: async (workspaceId: string, googleAdsRecommendationsRequest: GoogleAdsRecommendationsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRecommendations', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsRecommendationsRequest' is not null or undefined
            assertParamExists('getRecommendations', 'googleAdsRecommendationsRequest', googleAdsRecommendationsRequest)
            const localVarPath = `/v2/integrations/google_ads/recommendations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsRecommendationsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Google Ads Campaigns
         * @param {string} workspaceId 
         * @param {GoogleAdsCampaignsSearchRequest} googleAdsCampaignsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGoogleAdsCampaigns: async (workspaceId: string, googleAdsCampaignsSearchRequest: GoogleAdsCampaignsSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('importGoogleAdsCampaigns', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsCampaignsSearchRequest' is not null or undefined
            assertParamExists('importGoogleAdsCampaigns', 'googleAdsCampaignsSearchRequest', googleAdsCampaignsSearchRequest)
            const localVarPath = `/v2/integrations/google_ads/campaigns/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsCampaignsSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Google Ads Customers
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGoogleAdsCustomers: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('importGoogleAdsCustomers', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/google_ads/customers/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Google Ads Groups
         * @param {string} workspaceId 
         * @param {GoogleAdsGroupsSearchRequest} googleAdsGroupsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGoogleAdsGroups: async (workspaceId: string, googleAdsGroupsSearchRequest: GoogleAdsGroupsSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('importGoogleAdsGroups', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsGroupsSearchRequest' is not null or undefined
            assertParamExists('importGoogleAdsGroups', 'googleAdsGroupsSearchRequest', googleAdsGroupsSearchRequest)
            const localVarPath = `/v2/integrations/google_ads/groups/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsGroupsSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Keyword From Group
         * @param {string} workspaceId 
         * @param {GoogleAdsKeywordRemoveRequest} googleAdsKeywordRemoveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeKeywordFromGroup: async (workspaceId: string, googleAdsKeywordRemoveRequest: GoogleAdsKeywordRemoveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeKeywordFromGroup', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsKeywordRemoveRequest' is not null or undefined
            assertParamExists('removeKeywordFromGroup', 'googleAdsKeywordRemoveRequest', googleAdsKeywordRemoveRequest)
            const localVarPath = `/v2/integrations/google_ads/keyword/remove_from_group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsKeywordRemoveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Google Ads Campaign
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} workspaceId 
         * @param {GoogleAdsCampaignUpdateRequest} googleAdsCampaignUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoogleAdsCampaign: async (customerId: string, campaignId: string, workspaceId: string, googleAdsCampaignUpdateRequest: GoogleAdsCampaignUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateGoogleAdsCampaign', 'customerId', customerId)
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('updateGoogleAdsCampaign', 'campaignId', campaignId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateGoogleAdsCampaign', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsCampaignUpdateRequest' is not null or undefined
            assertParamExists('updateGoogleAdsCampaign', 'googleAdsCampaignUpdateRequest', googleAdsCampaignUpdateRequest)
            const localVarPath = `/v2/integrations/google_ads/campaigns/{customer_id}/{campaign_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsCampaignUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Google Ads Customer Update
         * @param {string} customerId 
         * @param {string} workspaceId 
         * @param {GoogleAdsCustomerUpdateRequest} googleAdsCustomerUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoogleAdsCustomerUpdate: async (customerId: string, workspaceId: string, googleAdsCustomerUpdateRequest: GoogleAdsCustomerUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateGoogleAdsCustomerUpdate', 'customerId', customerId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateGoogleAdsCustomerUpdate', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsCustomerUpdateRequest' is not null or undefined
            assertParamExists('updateGoogleAdsCustomerUpdate', 'googleAdsCustomerUpdateRequest', googleAdsCustomerUpdateRequest)
            const localVarPath = `/v2/integrations/google_ads/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsCustomerUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Google Ads Group
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {GoogleAdsGroupUpdateRequest} googleAdsGroupUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoogleAdsGroup: async (customerId: string, campaignId: string, groupId: string, workspaceId: string, googleAdsGroupUpdateRequest: GoogleAdsGroupUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateGoogleAdsGroup', 'customerId', customerId)
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('updateGoogleAdsGroup', 'campaignId', campaignId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGoogleAdsGroup', 'groupId', groupId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateGoogleAdsGroup', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsGroupUpdateRequest' is not null or undefined
            assertParamExists('updateGoogleAdsGroup', 'googleAdsGroupUpdateRequest', googleAdsGroupUpdateRequest)
            const localVarPath = `/v2/integrations/google_ads/groups/{customer_id}/{campaign_id}/{group_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsGroupUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleAdsApi - functional programming interface
 * @export
 */
export const GoogleAdsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoogleAdsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Keyword To Group
         * @param {string} workspaceId 
         * @param {GoogleAdsKeywordAddRequest} googleAdsKeywordAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addKeywordToGroup(workspaceId: string, googleAdsKeywordAddRequest: GoogleAdsKeywordAddRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addKeywordToGroup(workspaceId, googleAdsKeywordAddRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.addKeywordToGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Analyze Not Assigned Keywords
         * @param {string} workspaceId 
         * @param {GoogleAdsAnalyzeKeywordsRequest} googleAdsAnalyzeKeywordsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzeNotAssignedKeywords(workspaceId: string, googleAdsAnalyzeKeywordsRequest: GoogleAdsAnalyzeKeywordsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeNotAssignedKeywords(workspaceId, googleAdsAnalyzeKeywordsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.analyzeNotAssignedKeywords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Google Ads Campaigns
         * @param {string} workspaceId 
         * @param {GoogleAdsCampaignsSearchRequest} googleAdsCampaignsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoogleAdsCampaigns(workspaceId: string, googleAdsCampaignsSearchRequest: GoogleAdsCampaignsSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GoogleAdsCampaignResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoogleAdsCampaigns(workspaceId, googleAdsCampaignsSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.getGoogleAdsCampaigns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Google Ads Customers
         * @param {string} workspaceId 
         * @param {GoogleAdsCustomersSearchRequest} googleAdsCustomersSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoogleAdsCustomers(workspaceId: string, googleAdsCustomersSearchRequest: GoogleAdsCustomersSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleAdsCustomersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoogleAdsCustomers(workspaceId, googleAdsCustomersSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.getGoogleAdsCustomers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Google Ads Groups
         * @param {string} workspaceId 
         * @param {GoogleAdsGroupsSearchRequest} googleAdsGroupsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoogleAdsGroups(workspaceId: string, googleAdsGroupsSearchRequest: GoogleAdsGroupsSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GoogleAdsGroupResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoogleAdsGroups(workspaceId, googleAdsGroupsSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.getGoogleAdsGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Recommendations
         * @param {string} workspaceId 
         * @param {GoogleAdsRecommendationsRequest} googleAdsRecommendationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendations(workspaceId: string, googleAdsRecommendationsRequest: GoogleAdsRecommendationsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GoogleAdsKeywordRecommendation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendations(workspaceId, googleAdsRecommendationsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.getRecommendations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Import Google Ads Campaigns
         * @param {string} workspaceId 
         * @param {GoogleAdsCampaignsSearchRequest} googleAdsCampaignsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importGoogleAdsCampaigns(workspaceId: string, googleAdsCampaignsSearchRequest: GoogleAdsCampaignsSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleAdsCampaignsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importGoogleAdsCampaigns(workspaceId, googleAdsCampaignsSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.importGoogleAdsCampaigns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Import Google Ads Customers
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importGoogleAdsCustomers(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleAdsCustomersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importGoogleAdsCustomers(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.importGoogleAdsCustomers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Import Google Ads Groups
         * @param {string} workspaceId 
         * @param {GoogleAdsGroupsSearchRequest} googleAdsGroupsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importGoogleAdsGroups(workspaceId: string, googleAdsGroupsSearchRequest: GoogleAdsGroupsSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleAdsGroupsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importGoogleAdsGroups(workspaceId, googleAdsGroupsSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.importGoogleAdsGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove Keyword From Group
         * @param {string} workspaceId 
         * @param {GoogleAdsKeywordRemoveRequest} googleAdsKeywordRemoveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeKeywordFromGroup(workspaceId: string, googleAdsKeywordRemoveRequest: GoogleAdsKeywordRemoveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeKeywordFromGroup(workspaceId, googleAdsKeywordRemoveRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.removeKeywordFromGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Google Ads Campaign
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} workspaceId 
         * @param {GoogleAdsCampaignUpdateRequest} googleAdsCampaignUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGoogleAdsCampaign(customerId: string, campaignId: string, workspaceId: string, googleAdsCampaignUpdateRequest: GoogleAdsCampaignUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleAdsCampaignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGoogleAdsCampaign(customerId, campaignId, workspaceId, googleAdsCampaignUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.updateGoogleAdsCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Google Ads Customer Update
         * @param {string} customerId 
         * @param {string} workspaceId 
         * @param {GoogleAdsCustomerUpdateRequest} googleAdsCustomerUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGoogleAdsCustomerUpdate(customerId: string, workspaceId: string, googleAdsCustomerUpdateRequest: GoogleAdsCustomerUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleAdsCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGoogleAdsCustomerUpdate(customerId, workspaceId, googleAdsCustomerUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.updateGoogleAdsCustomerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Google Ads Group
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {GoogleAdsGroupUpdateRequest} googleAdsGroupUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGoogleAdsGroup(customerId: string, campaignId: string, groupId: string, workspaceId: string, googleAdsGroupUpdateRequest: GoogleAdsGroupUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleAdsGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGoogleAdsGroup(customerId, campaignId, groupId, workspaceId, googleAdsGroupUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.updateGoogleAdsGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GoogleAdsApi - factory interface
 * @export
 */
export const GoogleAdsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoogleAdsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Keyword To Group
         * @param {GoogleAdsApiAddKeywordToGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addKeywordToGroup(requestParameters: GoogleAdsApiAddKeywordToGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.addKeywordToGroup(requestParameters.workspaceId, requestParameters.googleAdsKeywordAddRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Analyze Not Assigned Keywords
         * @param {GoogleAdsApiAnalyzeNotAssignedKeywordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeNotAssignedKeywords(requestParameters: GoogleAdsApiAnalyzeNotAssignedKeywordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.analyzeNotAssignedKeywords(requestParameters.workspaceId, requestParameters.googleAdsAnalyzeKeywordsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Google Ads Campaigns
         * @param {GoogleAdsApiGetGoogleAdsCampaignsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoogleAdsCampaigns(requestParameters: GoogleAdsApiGetGoogleAdsCampaignsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GoogleAdsCampaignResponse>> {
            return localVarFp.getGoogleAdsCampaigns(requestParameters.workspaceId, requestParameters.googleAdsCampaignsSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Google Ads Customers
         * @param {GoogleAdsApiGetGoogleAdsCustomersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoogleAdsCustomers(requestParameters: GoogleAdsApiGetGoogleAdsCustomersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCustomersResponse> {
            return localVarFp.getGoogleAdsCustomers(requestParameters.workspaceId, requestParameters.googleAdsCustomersSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Google Ads Groups
         * @param {GoogleAdsApiGetGoogleAdsGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoogleAdsGroups(requestParameters: GoogleAdsApiGetGoogleAdsGroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GoogleAdsGroupResponse>> {
            return localVarFp.getGoogleAdsGroups(requestParameters.workspaceId, requestParameters.googleAdsGroupsSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Recommendations
         * @param {GoogleAdsApiGetRecommendationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendations(requestParameters: GoogleAdsApiGetRecommendationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GoogleAdsKeywordRecommendation>> {
            return localVarFp.getRecommendations(requestParameters.workspaceId, requestParameters.googleAdsRecommendationsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import Google Ads Campaigns
         * @param {GoogleAdsApiImportGoogleAdsCampaignsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGoogleAdsCampaigns(requestParameters: GoogleAdsApiImportGoogleAdsCampaignsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCampaignsResponse> {
            return localVarFp.importGoogleAdsCampaigns(requestParameters.workspaceId, requestParameters.googleAdsCampaignsSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import Google Ads Customers
         * @param {GoogleAdsApiImportGoogleAdsCustomersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGoogleAdsCustomers(requestParameters: GoogleAdsApiImportGoogleAdsCustomersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCustomersResponse> {
            return localVarFp.importGoogleAdsCustomers(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import Google Ads Groups
         * @param {GoogleAdsApiImportGoogleAdsGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGoogleAdsGroups(requestParameters: GoogleAdsApiImportGoogleAdsGroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsGroupsResponse> {
            return localVarFp.importGoogleAdsGroups(requestParameters.workspaceId, requestParameters.googleAdsGroupsSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Keyword From Group
         * @param {GoogleAdsApiRemoveKeywordFromGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeKeywordFromGroup(requestParameters: GoogleAdsApiRemoveKeywordFromGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.removeKeywordFromGroup(requestParameters.workspaceId, requestParameters.googleAdsKeywordRemoveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Google Ads Campaign
         * @param {GoogleAdsApiUpdateGoogleAdsCampaignRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoogleAdsCampaign(requestParameters: GoogleAdsApiUpdateGoogleAdsCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCampaignResponse> {
            return localVarFp.updateGoogleAdsCampaign(requestParameters.customerId, requestParameters.campaignId, requestParameters.workspaceId, requestParameters.googleAdsCampaignUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Google Ads Customer Update
         * @param {GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoogleAdsCustomerUpdate(requestParameters: GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCustomerResponse> {
            return localVarFp.updateGoogleAdsCustomerUpdate(requestParameters.customerId, requestParameters.workspaceId, requestParameters.googleAdsCustomerUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Google Ads Group
         * @param {GoogleAdsApiUpdateGoogleAdsGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoogleAdsGroup(requestParameters: GoogleAdsApiUpdateGoogleAdsGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsGroupResponse> {
            return localVarFp.updateGoogleAdsGroup(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, requestParameters.googleAdsGroupUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoogleAdsApi - interface
 * @export
 * @interface GoogleAdsApi
 */
export interface GoogleAdsApiInterface {
    /**
     * 
     * @summary Add Keyword To Group
     * @param {GoogleAdsApiAddKeywordToGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    addKeywordToGroup(requestParameters: GoogleAdsApiAddKeywordToGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Analyze Not Assigned Keywords
     * @param {GoogleAdsApiAnalyzeNotAssignedKeywordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    analyzeNotAssignedKeywords(requestParameters: GoogleAdsApiAnalyzeNotAssignedKeywordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Get Google Ads Campaigns
     * @param {GoogleAdsApiGetGoogleAdsCampaignsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    getGoogleAdsCampaigns(requestParameters: GoogleAdsApiGetGoogleAdsCampaignsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GoogleAdsCampaignResponse>>;

    /**
     * 
     * @summary Get Google Ads Customers
     * @param {GoogleAdsApiGetGoogleAdsCustomersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    getGoogleAdsCustomers(requestParameters: GoogleAdsApiGetGoogleAdsCustomersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCustomersResponse>;

    /**
     * 
     * @summary Get Google Ads Groups
     * @param {GoogleAdsApiGetGoogleAdsGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    getGoogleAdsGroups(requestParameters: GoogleAdsApiGetGoogleAdsGroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GoogleAdsGroupResponse>>;

    /**
     * 
     * @summary Get Recommendations
     * @param {GoogleAdsApiGetRecommendationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    getRecommendations(requestParameters: GoogleAdsApiGetRecommendationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GoogleAdsKeywordRecommendation>>;

    /**
     * 
     * @summary Import Google Ads Campaigns
     * @param {GoogleAdsApiImportGoogleAdsCampaignsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    importGoogleAdsCampaigns(requestParameters: GoogleAdsApiImportGoogleAdsCampaignsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCampaignsResponse>;

    /**
     * 
     * @summary Import Google Ads Customers
     * @param {GoogleAdsApiImportGoogleAdsCustomersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    importGoogleAdsCustomers(requestParameters: GoogleAdsApiImportGoogleAdsCustomersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCustomersResponse>;

    /**
     * 
     * @summary Import Google Ads Groups
     * @param {GoogleAdsApiImportGoogleAdsGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    importGoogleAdsGroups(requestParameters: GoogleAdsApiImportGoogleAdsGroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsGroupsResponse>;

    /**
     * 
     * @summary Remove Keyword From Group
     * @param {GoogleAdsApiRemoveKeywordFromGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    removeKeywordFromGroup(requestParameters: GoogleAdsApiRemoveKeywordFromGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Update Google Ads Campaign
     * @param {GoogleAdsApiUpdateGoogleAdsCampaignRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    updateGoogleAdsCampaign(requestParameters: GoogleAdsApiUpdateGoogleAdsCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCampaignResponse>;

    /**
     * 
     * @summary Update Google Ads Customer Update
     * @param {GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    updateGoogleAdsCustomerUpdate(requestParameters: GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCustomerResponse>;

    /**
     * 
     * @summary Update Google Ads Group
     * @param {GoogleAdsApiUpdateGoogleAdsGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    updateGoogleAdsGroup(requestParameters: GoogleAdsApiUpdateGoogleAdsGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsGroupResponse>;

}

/**
 * Request parameters for addKeywordToGroup operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiAddKeywordToGroupRequest
 */
export interface GoogleAdsApiAddKeywordToGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiAddKeywordToGroup
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsKeywordAddRequest}
     * @memberof GoogleAdsApiAddKeywordToGroup
     */
    readonly googleAdsKeywordAddRequest: GoogleAdsKeywordAddRequest
}

/**
 * Request parameters for analyzeNotAssignedKeywords operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiAnalyzeNotAssignedKeywordsRequest
 */
export interface GoogleAdsApiAnalyzeNotAssignedKeywordsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiAnalyzeNotAssignedKeywords
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsAnalyzeKeywordsRequest}
     * @memberof GoogleAdsApiAnalyzeNotAssignedKeywords
     */
    readonly googleAdsAnalyzeKeywordsRequest: GoogleAdsAnalyzeKeywordsRequest
}

/**
 * Request parameters for getGoogleAdsCampaigns operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiGetGoogleAdsCampaignsRequest
 */
export interface GoogleAdsApiGetGoogleAdsCampaignsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiGetGoogleAdsCampaigns
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsCampaignsSearchRequest}
     * @memberof GoogleAdsApiGetGoogleAdsCampaigns
     */
    readonly googleAdsCampaignsSearchRequest: GoogleAdsCampaignsSearchRequest
}

/**
 * Request parameters for getGoogleAdsCustomers operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiGetGoogleAdsCustomersRequest
 */
export interface GoogleAdsApiGetGoogleAdsCustomersRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiGetGoogleAdsCustomers
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsCustomersSearchRequest}
     * @memberof GoogleAdsApiGetGoogleAdsCustomers
     */
    readonly googleAdsCustomersSearchRequest: GoogleAdsCustomersSearchRequest
}

/**
 * Request parameters for getGoogleAdsGroups operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiGetGoogleAdsGroupsRequest
 */
export interface GoogleAdsApiGetGoogleAdsGroupsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiGetGoogleAdsGroups
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsGroupsSearchRequest}
     * @memberof GoogleAdsApiGetGoogleAdsGroups
     */
    readonly googleAdsGroupsSearchRequest: GoogleAdsGroupsSearchRequest
}

/**
 * Request parameters for getRecommendations operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiGetRecommendationsRequest
 */
export interface GoogleAdsApiGetRecommendationsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiGetRecommendations
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsRecommendationsRequest}
     * @memberof GoogleAdsApiGetRecommendations
     */
    readonly googleAdsRecommendationsRequest: GoogleAdsRecommendationsRequest
}

/**
 * Request parameters for importGoogleAdsCampaigns operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiImportGoogleAdsCampaignsRequest
 */
export interface GoogleAdsApiImportGoogleAdsCampaignsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiImportGoogleAdsCampaigns
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsCampaignsSearchRequest}
     * @memberof GoogleAdsApiImportGoogleAdsCampaigns
     */
    readonly googleAdsCampaignsSearchRequest: GoogleAdsCampaignsSearchRequest
}

/**
 * Request parameters for importGoogleAdsCustomers operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiImportGoogleAdsCustomersRequest
 */
export interface GoogleAdsApiImportGoogleAdsCustomersRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiImportGoogleAdsCustomers
     */
    readonly workspaceId: string
}

/**
 * Request parameters for importGoogleAdsGroups operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiImportGoogleAdsGroupsRequest
 */
export interface GoogleAdsApiImportGoogleAdsGroupsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiImportGoogleAdsGroups
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsGroupsSearchRequest}
     * @memberof GoogleAdsApiImportGoogleAdsGroups
     */
    readonly googleAdsGroupsSearchRequest: GoogleAdsGroupsSearchRequest
}

/**
 * Request parameters for removeKeywordFromGroup operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiRemoveKeywordFromGroupRequest
 */
export interface GoogleAdsApiRemoveKeywordFromGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiRemoveKeywordFromGroup
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsKeywordRemoveRequest}
     * @memberof GoogleAdsApiRemoveKeywordFromGroup
     */
    readonly googleAdsKeywordRemoveRequest: GoogleAdsKeywordRemoveRequest
}

/**
 * Request parameters for updateGoogleAdsCampaign operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiUpdateGoogleAdsCampaignRequest
 */
export interface GoogleAdsApiUpdateGoogleAdsCampaignRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsCampaign
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsCampaign
     */
    readonly campaignId: string

    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsCampaign
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsCampaignUpdateRequest}
     * @memberof GoogleAdsApiUpdateGoogleAdsCampaign
     */
    readonly googleAdsCampaignUpdateRequest: GoogleAdsCampaignUpdateRequest
}

/**
 * Request parameters for updateGoogleAdsCustomerUpdate operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest
 */
export interface GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsCustomerUpdate
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsCustomerUpdate
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsCustomerUpdateRequest}
     * @memberof GoogleAdsApiUpdateGoogleAdsCustomerUpdate
     */
    readonly googleAdsCustomerUpdateRequest: GoogleAdsCustomerUpdateRequest
}

/**
 * Request parameters for updateGoogleAdsGroup operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiUpdateGoogleAdsGroupRequest
 */
export interface GoogleAdsApiUpdateGoogleAdsGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsGroup
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsGroup
     */
    readonly campaignId: string

    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsGroup
     */
    readonly groupId: string

    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsGroup
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsGroupUpdateRequest}
     * @memberof GoogleAdsApiUpdateGoogleAdsGroup
     */
    readonly googleAdsGroupUpdateRequest: GoogleAdsGroupUpdateRequest
}

/**
 * GoogleAdsApi - object-oriented interface
 * @export
 * @class GoogleAdsApi
 * @extends {BaseAPI}
 */
export class GoogleAdsApi extends BaseAPI implements GoogleAdsApiInterface {
    /**
     * 
     * @summary Add Keyword To Group
     * @param {GoogleAdsApiAddKeywordToGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public addKeywordToGroup(requestParameters: GoogleAdsApiAddKeywordToGroupRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).addKeywordToGroup(requestParameters.workspaceId, requestParameters.googleAdsKeywordAddRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Analyze Not Assigned Keywords
     * @param {GoogleAdsApiAnalyzeNotAssignedKeywordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public analyzeNotAssignedKeywords(requestParameters: GoogleAdsApiAnalyzeNotAssignedKeywordsRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).analyzeNotAssignedKeywords(requestParameters.workspaceId, requestParameters.googleAdsAnalyzeKeywordsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Google Ads Campaigns
     * @param {GoogleAdsApiGetGoogleAdsCampaignsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public getGoogleAdsCampaigns(requestParameters: GoogleAdsApiGetGoogleAdsCampaignsRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).getGoogleAdsCampaigns(requestParameters.workspaceId, requestParameters.googleAdsCampaignsSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Google Ads Customers
     * @param {GoogleAdsApiGetGoogleAdsCustomersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public getGoogleAdsCustomers(requestParameters: GoogleAdsApiGetGoogleAdsCustomersRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).getGoogleAdsCustomers(requestParameters.workspaceId, requestParameters.googleAdsCustomersSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Google Ads Groups
     * @param {GoogleAdsApiGetGoogleAdsGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public getGoogleAdsGroups(requestParameters: GoogleAdsApiGetGoogleAdsGroupsRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).getGoogleAdsGroups(requestParameters.workspaceId, requestParameters.googleAdsGroupsSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Recommendations
     * @param {GoogleAdsApiGetRecommendationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public getRecommendations(requestParameters: GoogleAdsApiGetRecommendationsRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).getRecommendations(requestParameters.workspaceId, requestParameters.googleAdsRecommendationsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import Google Ads Campaigns
     * @param {GoogleAdsApiImportGoogleAdsCampaignsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public importGoogleAdsCampaigns(requestParameters: GoogleAdsApiImportGoogleAdsCampaignsRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).importGoogleAdsCampaigns(requestParameters.workspaceId, requestParameters.googleAdsCampaignsSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import Google Ads Customers
     * @param {GoogleAdsApiImportGoogleAdsCustomersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public importGoogleAdsCustomers(requestParameters: GoogleAdsApiImportGoogleAdsCustomersRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).importGoogleAdsCustomers(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import Google Ads Groups
     * @param {GoogleAdsApiImportGoogleAdsGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public importGoogleAdsGroups(requestParameters: GoogleAdsApiImportGoogleAdsGroupsRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).importGoogleAdsGroups(requestParameters.workspaceId, requestParameters.googleAdsGroupsSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Keyword From Group
     * @param {GoogleAdsApiRemoveKeywordFromGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public removeKeywordFromGroup(requestParameters: GoogleAdsApiRemoveKeywordFromGroupRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).removeKeywordFromGroup(requestParameters.workspaceId, requestParameters.googleAdsKeywordRemoveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Google Ads Campaign
     * @param {GoogleAdsApiUpdateGoogleAdsCampaignRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public updateGoogleAdsCampaign(requestParameters: GoogleAdsApiUpdateGoogleAdsCampaignRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).updateGoogleAdsCampaign(requestParameters.customerId, requestParameters.campaignId, requestParameters.workspaceId, requestParameters.googleAdsCampaignUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Google Ads Customer Update
     * @param {GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public updateGoogleAdsCustomerUpdate(requestParameters: GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).updateGoogleAdsCustomerUpdate(requestParameters.customerId, requestParameters.workspaceId, requestParameters.googleAdsCustomerUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Google Ads Group
     * @param {GoogleAdsApiUpdateGoogleAdsGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public updateGoogleAdsGroup(requestParameters: GoogleAdsApiUpdateGoogleAdsGroupRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).updateGoogleAdsGroup(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, requestParameters.googleAdsGroupUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HubSpotApi - axios parameter creator
 * @export
 */
export const HubSpotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Actors
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActors: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getActors', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/hubspot/actors/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HubSpotApi - functional programming interface
 * @export
 */
export const HubSpotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HubSpotApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Actors
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActors(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HubSpotActorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActors(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HubSpotApi.getActors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HubSpotApi - factory interface
 * @export
 */
export const HubSpotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HubSpotApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Actors
         * @param {HubSpotApiGetActorsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActors(requestParameters: HubSpotApiGetActorsRequest, options?: RawAxiosRequestConfig): AxiosPromise<HubSpotActorsResponse> {
            return localVarFp.getActors(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HubSpotApi - interface
 * @export
 * @interface HubSpotApi
 */
export interface HubSpotApiInterface {
    /**
     * 
     * @summary Get Actors
     * @param {HubSpotApiGetActorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubSpotApiInterface
     */
    getActors(requestParameters: HubSpotApiGetActorsRequest, options?: RawAxiosRequestConfig): AxiosPromise<HubSpotActorsResponse>;

}

/**
 * Request parameters for getActors operation in HubSpotApi.
 * @export
 * @interface HubSpotApiGetActorsRequest
 */
export interface HubSpotApiGetActorsRequest {
    /**
     * 
     * @type {string}
     * @memberof HubSpotApiGetActors
     */
    readonly workspaceId: string
}

/**
 * HubSpotApi - object-oriented interface
 * @export
 * @class HubSpotApi
 * @extends {BaseAPI}
 */
export class HubSpotApi extends BaseAPI implements HubSpotApiInterface {
    /**
     * 
     * @summary Get Actors
     * @param {HubSpotApiGetActorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubSpotApi
     */
    public getActors(requestParameters: HubSpotApiGetActorsRequest, options?: RawAxiosRequestConfig) {
        return HubSpotApiFp(this.configuration).getActors(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Convert Image
         * @param {string} workspaceId 
         * @param {ImageConvertRequest} imageConvertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertImage: async (workspaceId: string, imageConvertRequest: ImageConvertRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('convertImage', 'workspaceId', workspaceId)
            // verify required parameter 'imageConvertRequest' is not null or undefined
            assertParamExists('convertImage', 'imageConvertRequest', imageConvertRequest)
            const localVarPath = `/v2/images/convert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageConvertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Screenshot
         * @param {string} workspaceId 
         * @param {ScreenshotRequest} screenshotRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenshot: async (workspaceId: string, screenshotRequest: ScreenshotRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScreenshot', 'workspaceId', workspaceId)
            // verify required parameter 'screenshotRequest' is not null or undefined
            assertParamExists('getScreenshot', 'screenshotRequest', screenshotRequest)
            const localVarPath = `/v2/images/screenshot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(screenshotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optimize Image
         * @param {string} workspaceId 
         * @param {ImageOptimizeRequest} imageOptimizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optimizeImage: async (workspaceId: string, imageOptimizeRequest: ImageOptimizeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('optimizeImage', 'workspaceId', workspaceId)
            // verify required parameter 'imageOptimizeRequest' is not null or undefined
            assertParamExists('optimizeImage', 'imageOptimizeRequest', imageOptimizeRequest)
            const localVarPath = `/v2/images/optimize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageOptimizeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Convert Image
         * @param {string} workspaceId 
         * @param {ImageConvertRequest} imageConvertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async convertImage(workspaceId: string, imageConvertRequest: ImageConvertRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.convertImage(workspaceId, imageConvertRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.convertImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Screenshot
         * @param {string} workspaceId 
         * @param {ScreenshotRequest} screenshotRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreenshot(workspaceId: string, screenshotRequest: ScreenshotRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScreenshotResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreenshot(workspaceId, screenshotRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.getScreenshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optimize Image
         * @param {string} workspaceId 
         * @param {ImageOptimizeRequest} imageOptimizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optimizeImage(workspaceId: string, imageOptimizeRequest: ImageOptimizeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optimizeImage(workspaceId, imageOptimizeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.optimizeImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Convert Image
         * @param {ImagesApiConvertImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertImage(requestParameters: ImagesApiConvertImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.convertImage(requestParameters.workspaceId, requestParameters.imageConvertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Screenshot
         * @param {ImagesApiGetScreenshotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenshot(requestParameters: ImagesApiGetScreenshotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScreenshotResponse> {
            return localVarFp.getScreenshot(requestParameters.workspaceId, requestParameters.screenshotRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optimize Image
         * @param {ImagesApiOptimizeImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optimizeImage(requestParameters: ImagesApiOptimizeImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.optimizeImage(requestParameters.workspaceId, requestParameters.imageOptimizeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - interface
 * @export
 * @interface ImagesApi
 */
export interface ImagesApiInterface {
    /**
     * 
     * @summary Convert Image
     * @param {ImagesApiConvertImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApiInterface
     */
    convertImage(requestParameters: ImagesApiConvertImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

    /**
     * 
     * @summary Get Screenshot
     * @param {ImagesApiGetScreenshotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApiInterface
     */
    getScreenshot(requestParameters: ImagesApiGetScreenshotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScreenshotResponse>;

    /**
     * 
     * @summary Optimize Image
     * @param {ImagesApiOptimizeImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApiInterface
     */
    optimizeImage(requestParameters: ImagesApiOptimizeImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

}

/**
 * Request parameters for convertImage operation in ImagesApi.
 * @export
 * @interface ImagesApiConvertImageRequest
 */
export interface ImagesApiConvertImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImagesApiConvertImage
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ImageConvertRequest}
     * @memberof ImagesApiConvertImage
     */
    readonly imageConvertRequest: ImageConvertRequest
}

/**
 * Request parameters for getScreenshot operation in ImagesApi.
 * @export
 * @interface ImagesApiGetScreenshotRequest
 */
export interface ImagesApiGetScreenshotRequest {
    /**
     * 
     * @type {string}
     * @memberof ImagesApiGetScreenshot
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ScreenshotRequest}
     * @memberof ImagesApiGetScreenshot
     */
    readonly screenshotRequest: ScreenshotRequest
}

/**
 * Request parameters for optimizeImage operation in ImagesApi.
 * @export
 * @interface ImagesApiOptimizeImageRequest
 */
export interface ImagesApiOptimizeImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImagesApiOptimizeImage
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ImageOptimizeRequest}
     * @memberof ImagesApiOptimizeImage
     */
    readonly imageOptimizeRequest: ImageOptimizeRequest
}

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI implements ImagesApiInterface {
    /**
     * 
     * @summary Convert Image
     * @param {ImagesApiConvertImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public convertImage(requestParameters: ImagesApiConvertImageRequest, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).convertImage(requestParameters.workspaceId, requestParameters.imageConvertRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Screenshot
     * @param {ImagesApiGetScreenshotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public getScreenshot(requestParameters: ImagesApiGetScreenshotRequest, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).getScreenshot(requestParameters.workspaceId, requestParameters.screenshotRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optimize Image
     * @param {ImagesApiOptimizeImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public optimizeImage(requestParameters: ImagesApiOptimizeImageRequest, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).optimizeImage(requestParameters.workspaceId, requestParameters.imageOptimizeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InstagramApi - axios parameter creator
 * @export
 */
export const InstagramApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Profile Information
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInformation: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getProfileInformation', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/instagram/profile_information`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstagramApi - functional programming interface
 * @export
 */
export const InstagramApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InstagramApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Profile Information
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileInformation(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstagramProfileInformationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileInformation(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstagramApi.getProfileInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InstagramApi - factory interface
 * @export
 */
export const InstagramApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InstagramApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Profile Information
         * @param {InstagramApiGetProfileInformationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInformation(requestParameters: InstagramApiGetProfileInformationRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstagramProfileInformationResponse> {
            return localVarFp.getProfileInformation(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InstagramApi - interface
 * @export
 * @interface InstagramApi
 */
export interface InstagramApiInterface {
    /**
     * 
     * @summary Get Profile Information
     * @param {InstagramApiGetProfileInformationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstagramApiInterface
     */
    getProfileInformation(requestParameters: InstagramApiGetProfileInformationRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstagramProfileInformationResponse>;

}

/**
 * Request parameters for getProfileInformation operation in InstagramApi.
 * @export
 * @interface InstagramApiGetProfileInformationRequest
 */
export interface InstagramApiGetProfileInformationRequest {
    /**
     * 
     * @type {string}
     * @memberof InstagramApiGetProfileInformation
     */
    readonly workspaceId: string
}

/**
 * InstagramApi - object-oriented interface
 * @export
 * @class InstagramApi
 * @extends {BaseAPI}
 */
export class InstagramApi extends BaseAPI implements InstagramApiInterface {
    /**
     * 
     * @summary Get Profile Information
     * @param {InstagramApiGetProfileInformationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstagramApi
     */
    public getProfileInformation(requestParameters: InstagramApiGetProfileInformationRequest, options?: RawAxiosRequestConfig) {
        return InstagramApiFp(this.configuration).getProfileInformation(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IntegrationsApi - axios parameter creator
 * @export
 */
export const IntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Integration
         * @param {IntegrationSlug} slug 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration: async (slug: IntegrationSlug, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('createIntegration', 'slug', slug)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createIntegration', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/{slug}/integrate`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Data Request
         * @param {CustomerDataRequestPayload} customerDataRequestPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDataRequest: async (customerDataRequestPayload: CustomerDataRequestPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerDataRequestPayload' is not null or undefined
            assertParamExists('customerDataRequest', 'customerDataRequestPayload', customerDataRequestPayload)
            const localVarPath = `/v2/integrations/shopify/webhooks/customers/data_request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerDataRequestPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Redact
         * @param {CustomerRedactPayload} customerRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerRedact: async (customerRedactPayload: CustomerRedactPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerRedactPayload' is not null or undefined
            assertParamExists('customerRedact', 'customerRedactPayload', customerRedactPayload)
            const localVarPath = `/v2/integrations/shopify/webhooks/customers/redact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerRedactPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Integration
         * @param {IntegrationSlug} slug 
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration: async (slug: IntegrationSlug, integrationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('deleteIntegration', 'slug', slug)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('deleteIntegration', 'integrationId', integrationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteIntegration', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/{slug}/{integration_id}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)))
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Actors
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActors: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getActors', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/hubspot/actors/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Integrations
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllIntegrations: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getAllIntegrations', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Calendars
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendars: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getCalendars', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/google/calendar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Hubspot Custom Channel Connect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHubspotCustomChannelConnect: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/integrations/hubspot_custom_channel_connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Integration
         * @param {IntegrationSlug} slug 
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration: async (slug: IntegrationSlug, integrationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getIntegration', 'slug', slug)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('getIntegration', 'integrationId', integrationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getIntegration', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/{slug}/{integration_id}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)))
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Members
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getMembers', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/wix/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Picker Token
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPickerToken: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getPickerToken', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/google/picker_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Profile Information
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInformation: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getProfileInformation', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/instagram/profile_information`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Repos
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepos: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRepos', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/github/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Sheets
         * @param {string} documentId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSheets: async (documentId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getSheets', 'documentId', documentId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSheets', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/google/sheets/{document_id}`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Shopify
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopify: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getShopify', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/shopify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Slack Channels
         * @param {string} slackTeamId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackChannels: async (slackTeamId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slackTeamId' is not null or undefined
            assertParamExists('getSlackChannels', 'slackTeamId', slackTeamId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSlackChannels', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/slack/{slack_team_id}/channels`
                .replace(`{${"slack_team_id"}}`, encodeURIComponent(String(slackTeamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Slack Workspaces
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackWorkspaces: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSlackWorkspaces', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/slack/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Wordpress Post Categories
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostCategories: async (integrationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('getWordpressPostCategories', 'integrationId', integrationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWordpressPostCategories', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/wordpress/{integration_id}/categories`
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Wordpress Post Tags
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostTags: async (integrationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('getWordpressPostTags', 'integrationId', integrationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWordpressPostTags', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/wordpress/{integration_id}/tags`
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Wordpress Sites
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressSites: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWordpressSites', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/wordpress/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Integration Callback
         * @param {IntegrationSlug} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationCallback: async (slug: IntegrationSlug, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('integrationCallback', 'slug', slug)
            const localVarPath = `/v2/integrations/{slug}/callback`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Integrations
         * @param {IntegrationSlug} slug 
         * @param {string} workspaceId 
         * @param {IntegrationSearchRequest} integrationSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchIntegrations: async (slug: IntegrationSlug, workspaceId: string, integrationSearchRequest: IntegrationSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('searchIntegrations', 'slug', slug)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchIntegrations', 'workspaceId', workspaceId)
            // verify required parameter 'integrationSearchRequest' is not null or undefined
            assertParamExists('searchIntegrations', 'integrationSearchRequest', integrationSearchRequest)
            const localVarPath = `/v2/integrations/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(integrationSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Shop Redact
         * @param {ShopRedactPayload} shopRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopRedact: async (shopRedactPayload: ShopRedactPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shopRedactPayload' is not null or undefined
            assertParamExists('shopRedact', 'shopRedactPayload', shopRedactPayload)
            const localVarPath = `/v2/integrations/shopify/webhooks/shop/redact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopRedactPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle subscription cancellation webhooks from Shopify.
         * @summary Subscription Cancel
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionCancel: async (xShopifyHmacSha256?: string, xShopifyTopic?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/integrations/shopify/webhooks/billing/subscription_cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xShopifyHmacSha256 != null) {
                localVarHeaderParameter['x-shopify-hmac-sha256'] = String(xShopifyHmacSha256);
            }
            if (xShopifyTopic != null) {
                localVarHeaderParameter['x-shopify-topic'] = String(xShopifyTopic);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
         * @summary Subscription Update
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionUpdate: async (xShopifyHmacSha256?: string, xShopifyTopic?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/integrations/shopify/webhooks/billing/subscription_update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xShopifyHmacSha256 != null) {
                localVarHeaderParameter['x-shopify-hmac-sha256'] = String(xShopifyHmacSha256);
            }
            if (xShopifyTopic != null) {
                localVarHeaderParameter['x-shopify-topic'] = String(xShopifyTopic);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Admin Consent
         * @param {string} workspaceId 
         * @param {string} integrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdminConsent: async (workspaceId: string, integrationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateAdminConsent', 'workspaceId', workspaceId)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('updateAdminConsent', 'integrationId', integrationId)
            const localVarPath = `/v2/integrations/microsoft_entra_id/admin_consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (integrationId !== undefined) {
                localVarQueryParameter['integration_id'] = integrationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Integration
         * @param {IntegrationSlug} slug 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIntegration(slug: IntegrationSlug, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationFlowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIntegration(slug, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.createIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Data Request
         * @param {CustomerDataRequestPayload} customerDataRequestPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerDataRequest(customerDataRequestPayload: CustomerDataRequestPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerDataRequest(customerDataRequestPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.customerDataRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Redact
         * @param {CustomerRedactPayload} customerRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerRedact(customerRedactPayload: CustomerRedactPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerRedact(customerRedactPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.customerRedact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Integration
         * @param {IntegrationSlug} slug 
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIntegration(slug: IntegrationSlug, integrationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIntegration(slug, integrationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.deleteIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Actors
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActors(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HubSpotActorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActors(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getActors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Integrations
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllIntegrations(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IntegrationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllIntegrations(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getAllIntegrations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Calendars
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalendars(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleCalendarsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalendars(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getCalendars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Hubspot Custom Channel Connect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHubspotCustomChannelConnect(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHubspotCustomChannelConnect(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getHubspotCustomChannelConnect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Integration
         * @param {IntegrationSlug} slug 
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegration(slug: IntegrationSlug, integrationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegration(slug, integrationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Members
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMembers(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WixMembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMembers(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Picker Token
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPickerToken(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GooglePickerTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPickerToken(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getPickerToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Profile Information
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileInformation(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstagramProfileInformationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileInformation(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getProfileInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Repos
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepos(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitHubReposResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRepos(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getRepos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Sheets
         * @param {string} documentId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSheets(documentId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleSheetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSheets(documentId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getSheets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Shopify
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShopify(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopifyIntegrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShopify(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getShopify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Slack Channels
         * @param {string} slackTeamId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlackChannels(slackTeamId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SlackChannelResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlackChannels(slackTeamId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getSlackChannels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Slack Workspaces
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlackWorkspaces(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SlackWorkspaceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlackWorkspaces(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getSlackWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Wordpress Post Categories
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWordpressPostCategories(integrationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WordPressCategoryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWordpressPostCategories(integrationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getWordpressPostCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Wordpress Post Tags
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWordpressPostTags(integrationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WordPressTagsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWordpressPostTags(integrationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getWordpressPostTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Wordpress Sites
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWordpressSites(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WordPressSiteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWordpressSites(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getWordpressSites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Integration Callback
         * @param {IntegrationSlug} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationCallback(slug: IntegrationSlug, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationCallback(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Integrations
         * @param {IntegrationSlug} slug 
         * @param {string} workspaceId 
         * @param {IntegrationSearchRequest} integrationSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchIntegrations(slug: IntegrationSlug, workspaceId: string, integrationSearchRequest: IntegrationSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IntegrationDetailResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchIntegrations(slug, workspaceId, integrationSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.searchIntegrations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Shop Redact
         * @param {ShopRedactPayload} shopRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopRedact(shopRedactPayload: ShopRedactPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopRedact(shopRedactPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.shopRedact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle subscription cancellation webhooks from Shopify.
         * @summary Subscription Cancel
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionCancel(xShopifyHmacSha256?: string, xShopifyTopic?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionCancel(xShopifyHmacSha256, xShopifyTopic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.subscriptionCancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
         * @summary Subscription Update
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionUpdate(xShopifyHmacSha256?: string, xShopifyTopic?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionUpdate(xShopifyHmacSha256, xShopifyTopic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.subscriptionUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Admin Consent
         * @param {string} workspaceId 
         * @param {string} integrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAdminConsent(workspaceId: string, integrationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAdminConsent(workspaceId, integrationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.updateAdminConsent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Integration
         * @param {IntegrationsApiCreateIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration(requestParameters: IntegrationsApiCreateIntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationFlowResponse> {
            return localVarFp.createIntegration(requestParameters.slug, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Data Request
         * @param {IntegrationsApiCustomerDataRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDataRequest(requestParameters: IntegrationsApiCustomerDataRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.customerDataRequest(requestParameters.customerDataRequestPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Redact
         * @param {IntegrationsApiCustomerRedactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerRedact(requestParameters: IntegrationsApiCustomerRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.customerRedact(requestParameters.customerRedactPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Integration
         * @param {IntegrationsApiDeleteIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration(requestParameters: IntegrationsApiDeleteIntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteIntegration(requestParameters.slug, requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Actors
         * @param {IntegrationsApiGetActorsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActors(requestParameters: IntegrationsApiGetActorsRequest, options?: RawAxiosRequestConfig): AxiosPromise<HubSpotActorsResponse> {
            return localVarFp.getActors(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Integrations
         * @param {IntegrationsApiGetAllIntegrationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllIntegrations(requestParameters: IntegrationsApiGetAllIntegrationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<IntegrationResponse>> {
            return localVarFp.getAllIntegrations(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Calendars
         * @param {IntegrationsApiGetCalendarsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendars(requestParameters: IntegrationsApiGetCalendarsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleCalendarsResponse> {
            return localVarFp.getCalendars(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Hubspot Custom Channel Connect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHubspotCustomChannelConnect(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getHubspotCustomChannelConnect(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Integration
         * @param {IntegrationsApiGetIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration(requestParameters: IntegrationsApiGetIntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationDetailResponse> {
            return localVarFp.getIntegration(requestParameters.slug, requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Members
         * @param {IntegrationsApiGetMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers(requestParameters: IntegrationsApiGetMembersRequest, options?: RawAxiosRequestConfig): AxiosPromise<WixMembersResponse> {
            return localVarFp.getMembers(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Picker Token
         * @param {IntegrationsApiGetPickerTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPickerToken(requestParameters: IntegrationsApiGetPickerTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<GooglePickerTokenResponse> {
            return localVarFp.getPickerToken(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Profile Information
         * @param {IntegrationsApiGetProfileInformationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInformation(requestParameters: IntegrationsApiGetProfileInformationRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstagramProfileInformationResponse> {
            return localVarFp.getProfileInformation(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Repos
         * @param {IntegrationsApiGetReposRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepos(requestParameters: IntegrationsApiGetReposRequest, options?: RawAxiosRequestConfig): AxiosPromise<GitHubReposResponse> {
            return localVarFp.getRepos(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Sheets
         * @param {IntegrationsApiGetSheetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSheets(requestParameters: IntegrationsApiGetSheetsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleSheetsResponse> {
            return localVarFp.getSheets(requestParameters.documentId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Shopify
         * @param {IntegrationsApiGetShopifyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopify(requestParameters: IntegrationsApiGetShopifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ShopifyIntegrationResponse> {
            return localVarFp.getShopify(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Slack Channels
         * @param {IntegrationsApiGetSlackChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackChannels(requestParameters: IntegrationsApiGetSlackChannelsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackChannelResponse>> {
            return localVarFp.getSlackChannels(requestParameters.slackTeamId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Slack Workspaces
         * @param {IntegrationsApiGetSlackWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackWorkspaces(requestParameters: IntegrationsApiGetSlackWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackWorkspaceResponse>> {
            return localVarFp.getSlackWorkspaces(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Wordpress Post Categories
         * @param {IntegrationsApiGetWordpressPostCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostCategories(requestParameters: IntegrationsApiGetWordpressPostCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressCategoryResponse>> {
            return localVarFp.getWordpressPostCategories(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Wordpress Post Tags
         * @param {IntegrationsApiGetWordpressPostTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostTags(requestParameters: IntegrationsApiGetWordpressPostTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressTagsResponse>> {
            return localVarFp.getWordpressPostTags(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Wordpress Sites
         * @param {IntegrationsApiGetWordpressSitesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressSites(requestParameters: IntegrationsApiGetWordpressSitesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressSiteResponse>> {
            return localVarFp.getWordpressSites(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Integration Callback
         * @param {IntegrationsApiIntegrationCallbackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationCallback(requestParameters: IntegrationsApiIntegrationCallbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.integrationCallback(requestParameters.slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Integrations
         * @param {IntegrationsApiSearchIntegrationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchIntegrations(requestParameters: IntegrationsApiSearchIntegrationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<IntegrationDetailResponse>> {
            return localVarFp.searchIntegrations(requestParameters.slug, requestParameters.workspaceId, requestParameters.integrationSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Shop Redact
         * @param {IntegrationsApiShopRedactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopRedact(requestParameters: IntegrationsApiShopRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.shopRedact(requestParameters.shopRedactPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle subscription cancellation webhooks from Shopify.
         * @summary Subscription Cancel
         * @param {IntegrationsApiSubscriptionCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionCancel(requestParameters: IntegrationsApiSubscriptionCancelRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.subscriptionCancel(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
         * @summary Subscription Update
         * @param {IntegrationsApiSubscriptionUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionUpdate(requestParameters: IntegrationsApiSubscriptionUpdateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.subscriptionUpdate(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Admin Consent
         * @param {IntegrationsApiUpdateAdminConsentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdminConsent(requestParameters: IntegrationsApiUpdateAdminConsentRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationDetailResponse> {
            return localVarFp.updateAdminConsent(requestParameters.workspaceId, requestParameters.integrationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntegrationsApi - interface
 * @export
 * @interface IntegrationsApi
 */
export interface IntegrationsApiInterface {
    /**
     * 
     * @summary Create Integration
     * @param {IntegrationsApiCreateIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    createIntegration(requestParameters: IntegrationsApiCreateIntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationFlowResponse>;

    /**
     * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Data Request
     * @param {IntegrationsApiCustomerDataRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    customerDataRequest(requestParameters: IntegrationsApiCustomerDataRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Redact
     * @param {IntegrationsApiCustomerRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    customerRedact(requestParameters: IntegrationsApiCustomerRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Delete Integration
     * @param {IntegrationsApiDeleteIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    deleteIntegration(requestParameters: IntegrationsApiDeleteIntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Get Actors
     * @param {IntegrationsApiGetActorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getActors(requestParameters: IntegrationsApiGetActorsRequest, options?: RawAxiosRequestConfig): AxiosPromise<HubSpotActorsResponse>;

    /**
     * 
     * @summary Get All Integrations
     * @param {IntegrationsApiGetAllIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getAllIntegrations(requestParameters: IntegrationsApiGetAllIntegrationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<IntegrationResponse>>;

    /**
     * 
     * @summary Get Calendars
     * @param {IntegrationsApiGetCalendarsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getCalendars(requestParameters: IntegrationsApiGetCalendarsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleCalendarsResponse>;

    /**
     * 
     * @summary Get Hubspot Custom Channel Connect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getHubspotCustomChannelConnect(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Integration
     * @param {IntegrationsApiGetIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getIntegration(requestParameters: IntegrationsApiGetIntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationDetailResponse>;

    /**
     * 
     * @summary Get Members
     * @param {IntegrationsApiGetMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getMembers(requestParameters: IntegrationsApiGetMembersRequest, options?: RawAxiosRequestConfig): AxiosPromise<WixMembersResponse>;

    /**
     * 
     * @summary Get Picker Token
     * @param {IntegrationsApiGetPickerTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getPickerToken(requestParameters: IntegrationsApiGetPickerTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<GooglePickerTokenResponse>;

    /**
     * 
     * @summary Get Profile Information
     * @param {IntegrationsApiGetProfileInformationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getProfileInformation(requestParameters: IntegrationsApiGetProfileInformationRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstagramProfileInformationResponse>;

    /**
     * 
     * @summary Get Repos
     * @param {IntegrationsApiGetReposRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getRepos(requestParameters: IntegrationsApiGetReposRequest, options?: RawAxiosRequestConfig): AxiosPromise<GitHubReposResponse>;

    /**
     * 
     * @summary Get Sheets
     * @param {IntegrationsApiGetSheetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getSheets(requestParameters: IntegrationsApiGetSheetsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleSheetsResponse>;

    /**
     * 
     * @summary Get Shopify
     * @param {IntegrationsApiGetShopifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getShopify(requestParameters: IntegrationsApiGetShopifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ShopifyIntegrationResponse>;

    /**
     * 
     * @summary Get Slack Channels
     * @param {IntegrationsApiGetSlackChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getSlackChannels(requestParameters: IntegrationsApiGetSlackChannelsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackChannelResponse>>;

    /**
     * 
     * @summary Get Slack Workspaces
     * @param {IntegrationsApiGetSlackWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getSlackWorkspaces(requestParameters: IntegrationsApiGetSlackWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackWorkspaceResponse>>;

    /**
     * 
     * @summary Get Wordpress Post Categories
     * @param {IntegrationsApiGetWordpressPostCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getWordpressPostCategories(requestParameters: IntegrationsApiGetWordpressPostCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressCategoryResponse>>;

    /**
     * 
     * @summary Get Wordpress Post Tags
     * @param {IntegrationsApiGetWordpressPostTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getWordpressPostTags(requestParameters: IntegrationsApiGetWordpressPostTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressTagsResponse>>;

    /**
     * 
     * @summary Get Wordpress Sites
     * @param {IntegrationsApiGetWordpressSitesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getWordpressSites(requestParameters: IntegrationsApiGetWordpressSitesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressSiteResponse>>;

    /**
     * 
     * @summary Integration Callback
     * @param {IntegrationsApiIntegrationCallbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    integrationCallback(requestParameters: IntegrationsApiIntegrationCallbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Search Integrations
     * @param {IntegrationsApiSearchIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    searchIntegrations(requestParameters: IntegrationsApiSearchIntegrationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<IntegrationDetailResponse>>;

    /**
     * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Shop Redact
     * @param {IntegrationsApiShopRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    shopRedact(requestParameters: IntegrationsApiShopRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle subscription cancellation webhooks from Shopify.
     * @summary Subscription Cancel
     * @param {IntegrationsApiSubscriptionCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    subscriptionCancel(requestParameters?: IntegrationsApiSubscriptionCancelRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
     * @summary Subscription Update
     * @param {IntegrationsApiSubscriptionUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    subscriptionUpdate(requestParameters?: IntegrationsApiSubscriptionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Update Admin Consent
     * @param {IntegrationsApiUpdateAdminConsentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    updateAdminConsent(requestParameters: IntegrationsApiUpdateAdminConsentRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationDetailResponse>;

}

/**
 * Request parameters for createIntegration operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiCreateIntegrationRequest
 */
export interface IntegrationsApiCreateIntegrationRequest {
    /**
     * 
     * @type {IntegrationSlug}
     * @memberof IntegrationsApiCreateIntegration
     */
    readonly slug: IntegrationSlug

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiCreateIntegration
     */
    readonly workspaceId: string
}

/**
 * Request parameters for customerDataRequest operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiCustomerDataRequestRequest
 */
export interface IntegrationsApiCustomerDataRequestRequest {
    /**
     * 
     * @type {CustomerDataRequestPayload}
     * @memberof IntegrationsApiCustomerDataRequest
     */
    readonly customerDataRequestPayload: CustomerDataRequestPayload
}

/**
 * Request parameters for customerRedact operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiCustomerRedactRequest
 */
export interface IntegrationsApiCustomerRedactRequest {
    /**
     * 
     * @type {CustomerRedactPayload}
     * @memberof IntegrationsApiCustomerRedact
     */
    readonly customerRedactPayload: CustomerRedactPayload
}

/**
 * Request parameters for deleteIntegration operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiDeleteIntegrationRequest
 */
export interface IntegrationsApiDeleteIntegrationRequest {
    /**
     * 
     * @type {IntegrationSlug}
     * @memberof IntegrationsApiDeleteIntegration
     */
    readonly slug: IntegrationSlug

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiDeleteIntegration
     */
    readonly integrationId: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiDeleteIntegration
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getActors operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetActorsRequest
 */
export interface IntegrationsApiGetActorsRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetActors
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getAllIntegrations operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetAllIntegrationsRequest
 */
export interface IntegrationsApiGetAllIntegrationsRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetAllIntegrations
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getCalendars operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetCalendarsRequest
 */
export interface IntegrationsApiGetCalendarsRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetCalendars
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getIntegration operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetIntegrationRequest
 */
export interface IntegrationsApiGetIntegrationRequest {
    /**
     * 
     * @type {IntegrationSlug}
     * @memberof IntegrationsApiGetIntegration
     */
    readonly slug: IntegrationSlug

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetIntegration
     */
    readonly integrationId: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetIntegration
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getMembers operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetMembersRequest
 */
export interface IntegrationsApiGetMembersRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetMembers
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getPickerToken operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetPickerTokenRequest
 */
export interface IntegrationsApiGetPickerTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetPickerToken
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getProfileInformation operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetProfileInformationRequest
 */
export interface IntegrationsApiGetProfileInformationRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetProfileInformation
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getRepos operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetReposRequest
 */
export interface IntegrationsApiGetReposRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetRepos
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getSheets operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetSheetsRequest
 */
export interface IntegrationsApiGetSheetsRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetSheets
     */
    readonly documentId: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetSheets
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getShopify operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetShopifyRequest
 */
export interface IntegrationsApiGetShopifyRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetShopify
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getSlackChannels operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetSlackChannelsRequest
 */
export interface IntegrationsApiGetSlackChannelsRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetSlackChannels
     */
    readonly slackTeamId: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetSlackChannels
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getSlackWorkspaces operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetSlackWorkspacesRequest
 */
export interface IntegrationsApiGetSlackWorkspacesRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetSlackWorkspaces
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getWordpressPostCategories operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetWordpressPostCategoriesRequest
 */
export interface IntegrationsApiGetWordpressPostCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetWordpressPostCategories
     */
    readonly integrationId: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetWordpressPostCategories
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getWordpressPostTags operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetWordpressPostTagsRequest
 */
export interface IntegrationsApiGetWordpressPostTagsRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetWordpressPostTags
     */
    readonly integrationId: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetWordpressPostTags
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getWordpressSites operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetWordpressSitesRequest
 */
export interface IntegrationsApiGetWordpressSitesRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetWordpressSites
     */
    readonly workspaceId: string
}

/**
 * Request parameters for integrationCallback operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiIntegrationCallbackRequest
 */
export interface IntegrationsApiIntegrationCallbackRequest {
    /**
     * 
     * @type {IntegrationSlug}
     * @memberof IntegrationsApiIntegrationCallback
     */
    readonly slug: IntegrationSlug
}

/**
 * Request parameters for searchIntegrations operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSearchIntegrationsRequest
 */
export interface IntegrationsApiSearchIntegrationsRequest {
    /**
     * 
     * @type {IntegrationSlug}
     * @memberof IntegrationsApiSearchIntegrations
     */
    readonly slug: IntegrationSlug

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiSearchIntegrations
     */
    readonly workspaceId: string

    /**
     * 
     * @type {IntegrationSearchRequest}
     * @memberof IntegrationsApiSearchIntegrations
     */
    readonly integrationSearchRequest: IntegrationSearchRequest
}

/**
 * Request parameters for shopRedact operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiShopRedactRequest
 */
export interface IntegrationsApiShopRedactRequest {
    /**
     * 
     * @type {ShopRedactPayload}
     * @memberof IntegrationsApiShopRedact
     */
    readonly shopRedactPayload: ShopRedactPayload
}

/**
 * Request parameters for subscriptionCancel operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSubscriptionCancelRequest
 */
export interface IntegrationsApiSubscriptionCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiSubscriptionCancel
     */
    readonly xShopifyHmacSha256?: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiSubscriptionCancel
     */
    readonly xShopifyTopic?: string
}

/**
 * Request parameters for subscriptionUpdate operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSubscriptionUpdateRequest
 */
export interface IntegrationsApiSubscriptionUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiSubscriptionUpdate
     */
    readonly xShopifyHmacSha256?: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiSubscriptionUpdate
     */
    readonly xShopifyTopic?: string
}

/**
 * Request parameters for updateAdminConsent operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiUpdateAdminConsentRequest
 */
export interface IntegrationsApiUpdateAdminConsentRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiUpdateAdminConsent
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiUpdateAdminConsent
     */
    readonly integrationId: string
}

/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export class IntegrationsApi extends BaseAPI implements IntegrationsApiInterface {
    /**
     * 
     * @summary Create Integration
     * @param {IntegrationsApiCreateIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public createIntegration(requestParameters: IntegrationsApiCreateIntegrationRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).createIntegration(requestParameters.slug, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Data Request
     * @param {IntegrationsApiCustomerDataRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public customerDataRequest(requestParameters: IntegrationsApiCustomerDataRequestRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).customerDataRequest(requestParameters.customerDataRequestPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Redact
     * @param {IntegrationsApiCustomerRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public customerRedact(requestParameters: IntegrationsApiCustomerRedactRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).customerRedact(requestParameters.customerRedactPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Integration
     * @param {IntegrationsApiDeleteIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public deleteIntegration(requestParameters: IntegrationsApiDeleteIntegrationRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).deleteIntegration(requestParameters.slug, requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Actors
     * @param {IntegrationsApiGetActorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getActors(requestParameters: IntegrationsApiGetActorsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getActors(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Integrations
     * @param {IntegrationsApiGetAllIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getAllIntegrations(requestParameters: IntegrationsApiGetAllIntegrationsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getAllIntegrations(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Calendars
     * @param {IntegrationsApiGetCalendarsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getCalendars(requestParameters: IntegrationsApiGetCalendarsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getCalendars(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Hubspot Custom Channel Connect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getHubspotCustomChannelConnect(options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getHubspotCustomChannelConnect(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Integration
     * @param {IntegrationsApiGetIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getIntegration(requestParameters: IntegrationsApiGetIntegrationRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getIntegration(requestParameters.slug, requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Members
     * @param {IntegrationsApiGetMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getMembers(requestParameters: IntegrationsApiGetMembersRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getMembers(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Picker Token
     * @param {IntegrationsApiGetPickerTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getPickerToken(requestParameters: IntegrationsApiGetPickerTokenRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getPickerToken(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Profile Information
     * @param {IntegrationsApiGetProfileInformationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getProfileInformation(requestParameters: IntegrationsApiGetProfileInformationRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getProfileInformation(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Repos
     * @param {IntegrationsApiGetReposRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getRepos(requestParameters: IntegrationsApiGetReposRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getRepos(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Sheets
     * @param {IntegrationsApiGetSheetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getSheets(requestParameters: IntegrationsApiGetSheetsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getSheets(requestParameters.documentId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Shopify
     * @param {IntegrationsApiGetShopifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getShopify(requestParameters: IntegrationsApiGetShopifyRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getShopify(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Slack Channels
     * @param {IntegrationsApiGetSlackChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getSlackChannels(requestParameters: IntegrationsApiGetSlackChannelsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getSlackChannels(requestParameters.slackTeamId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Slack Workspaces
     * @param {IntegrationsApiGetSlackWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getSlackWorkspaces(requestParameters: IntegrationsApiGetSlackWorkspacesRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getSlackWorkspaces(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Wordpress Post Categories
     * @param {IntegrationsApiGetWordpressPostCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getWordpressPostCategories(requestParameters: IntegrationsApiGetWordpressPostCategoriesRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getWordpressPostCategories(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Wordpress Post Tags
     * @param {IntegrationsApiGetWordpressPostTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getWordpressPostTags(requestParameters: IntegrationsApiGetWordpressPostTagsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getWordpressPostTags(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Wordpress Sites
     * @param {IntegrationsApiGetWordpressSitesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getWordpressSites(requestParameters: IntegrationsApiGetWordpressSitesRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getWordpressSites(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Integration Callback
     * @param {IntegrationsApiIntegrationCallbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public integrationCallback(requestParameters: IntegrationsApiIntegrationCallbackRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationCallback(requestParameters.slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Integrations
     * @param {IntegrationsApiSearchIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public searchIntegrations(requestParameters: IntegrationsApiSearchIntegrationsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).searchIntegrations(requestParameters.slug, requestParameters.workspaceId, requestParameters.integrationSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Shop Redact
     * @param {IntegrationsApiShopRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public shopRedact(requestParameters: IntegrationsApiShopRedactRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).shopRedact(requestParameters.shopRedactPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle subscription cancellation webhooks from Shopify.
     * @summary Subscription Cancel
     * @param {IntegrationsApiSubscriptionCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public subscriptionCancel(requestParameters: IntegrationsApiSubscriptionCancelRequest = {}, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).subscriptionCancel(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
     * @summary Subscription Update
     * @param {IntegrationsApiSubscriptionUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public subscriptionUpdate(requestParameters: IntegrationsApiSubscriptionUpdateRequest = {}, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).subscriptionUpdate(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Admin Consent
     * @param {IntegrationsApiUpdateAdminConsentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public updateAdminConsent(requestParameters: IntegrationsApiUpdateAdminConsentRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).updateAdminConsent(requestParameters.workspaceId, requestParameters.integrationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LogsApi - axios parameter creator
 * @export
 */
export const LogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search for logs based on various criteria
         * @summary Search logs
         * @param {string} workspaceId 
         * @param {LogsSearchRequest} logsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLogs: async (workspaceId: string, logsSearchRequest: LogsSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchLogs', 'workspaceId', workspaceId)
            // verify required parameter 'logsSearchRequest' is not null or undefined
            assertParamExists('searchLogs', 'logsSearchRequest', logsSearchRequest)
            const localVarPath = `/v2/logs/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logsSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration)
    return {
        /**
         * Search for logs based on various criteria
         * @summary Search logs
         * @param {string} workspaceId 
         * @param {LogsSearchRequest} logsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchLogs(workspaceId: string, logsSearchRequest: LogsSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchLogs(workspaceId, logsSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogsApi.searchLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LogsApi - factory interface
 * @export
 */
export const LogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogsApiFp(configuration)
    return {
        /**
         * Search for logs based on various criteria
         * @summary Search logs
         * @param {LogsApiSearchLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLogs(requestParameters: LogsApiSearchLogsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<LogResponse>> {
            return localVarFp.searchLogs(requestParameters.workspaceId, requestParameters.logsSearchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogsApi - interface
 * @export
 * @interface LogsApi
 */
export interface LogsApiInterface {
    /**
     * Search for logs based on various criteria
     * @summary Search logs
     * @param {LogsApiSearchLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApiInterface
     */
    searchLogs(requestParameters: LogsApiSearchLogsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<LogResponse>>;

}

/**
 * Request parameters for searchLogs operation in LogsApi.
 * @export
 * @interface LogsApiSearchLogsRequest
 */
export interface LogsApiSearchLogsRequest {
    /**
     * 
     * @type {string}
     * @memberof LogsApiSearchLogs
     */
    readonly workspaceId: string

    /**
     * 
     * @type {LogsSearchRequest}
     * @memberof LogsApiSearchLogs
     */
    readonly logsSearchRequest: LogsSearchRequest
}

/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
export class LogsApi extends BaseAPI implements LogsApiInterface {
    /**
     * Search for logs based on various criteria
     * @summary Search logs
     * @param {LogsApiSearchLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public searchLogs(requestParameters: LogsApiSearchLogsRequest, options?: RawAxiosRequestConfig) {
        return LogsApiFp(this.configuration).searchLogs(requestParameters.workspaceId, requestParameters.logsSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MCPServersApi - axios parameter creator
 * @export
 */
export const MCPServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new MCP server.  Args:     main_request: The main request object for rate limiting.     workspace_id: The workspace ID.     request: The MCP server creation request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerCreateResponse: The created MCP server with the raw API key.
         * @summary Create Mcp Server
         * @param {string} workspaceId 
         * @param {MCPServerCreateRequest} mCPServerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMcpServer: async (workspaceId: string, mCPServerCreateRequest: MCPServerCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createMcpServer', 'workspaceId', workspaceId)
            // verify required parameter 'mCPServerCreateRequest' is not null or undefined
            assertParamExists('createMcpServer', 'mCPServerCreateRequest', mCPServerCreateRequest)
            const localVarPath = `/v2/mcp_servers/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mCPServerCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an MCP server.  Args:     main_request: The main request object for rate limiting.     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.
         * @summary Delete Mcp Server
         * @param {string} mcpServerId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMcpServer: async (mcpServerId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mcpServerId' is not null or undefined
            assertParamExists('deleteMcpServer', 'mcpServerId', mcpServerId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteMcpServer', 'workspaceId', workspaceId)
            const localVarPath = `/v2/mcp_servers/{mcp_server_id}`
                .replace(`{${"mcp_server_id"}}`, encodeURIComponent(String(mcpServerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all MCP subservers available in the system.  Args:     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPSubServerBinding]: List of all MCP subservers.
         * @summary Get All Mcp Subservers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMcpSubservers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/mcp_servers/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an MCP server by ID.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The MCP server.
         * @summary Get Mcp Server
         * @param {string} mcpServerId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMcpServer: async (mcpServerId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mcpServerId' is not null or undefined
            assertParamExists('getMcpServer', 'mcpServerId', mcpServerId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getMcpServer', 'workspaceId', workspaceId)
            const localVarPath = `/v2/mcp_servers/{mcp_server_id}`
                .replace(`{${"mcp_server_id"}}`, encodeURIComponent(String(mcpServerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List MCP servers in a workspace.  Args:     workspace_id: The workspace ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPServerResponse]: List of MCP servers.
         * @summary Search Mcp Servers
         * @param {string} workspaceId 
         * @param {MCPServerSearchRequest} mCPServerSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMcpServers: async (workspaceId: string, mCPServerSearchRequest: MCPServerSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchMcpServers', 'workspaceId', workspaceId)
            // verify required parameter 'mCPServerSearchRequest' is not null or undefined
            assertParamExists('searchMcpServers', 'mCPServerSearchRequest', mCPServerSearchRequest)
            const localVarPath = `/v2/mcp_servers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mCPServerSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an MCP server.  Args:     main_request: The main request object for rate limiting.     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     request: The update request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The updated MCP server.
         * @summary Update Mcp Server
         * @param {string} mcpServerId 
         * @param {string} workspaceId 
         * @param {MCPServerCreateRequest} mCPServerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMcpServer: async (mcpServerId: string, workspaceId: string, mCPServerCreateRequest: MCPServerCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mcpServerId' is not null or undefined
            assertParamExists('updateMcpServer', 'mcpServerId', mcpServerId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateMcpServer', 'workspaceId', workspaceId)
            // verify required parameter 'mCPServerCreateRequest' is not null or undefined
            assertParamExists('updateMcpServer', 'mCPServerCreateRequest', mCPServerCreateRequest)
            const localVarPath = `/v2/mcp_servers/{mcp_server_id}`
                .replace(`{${"mcp_server_id"}}`, encodeURIComponent(String(mcpServerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mCPServerCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MCPServersApi - functional programming interface
 * @export
 */
export const MCPServersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MCPServersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new MCP server.  Args:     main_request: The main request object for rate limiting.     workspace_id: The workspace ID.     request: The MCP server creation request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerCreateResponse: The created MCP server with the raw API key.
         * @summary Create Mcp Server
         * @param {string} workspaceId 
         * @param {MCPServerCreateRequest} mCPServerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMcpServer(workspaceId: string, mCPServerCreateRequest: MCPServerCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MCPServerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMcpServer(workspaceId, mCPServerCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MCPServersApi.createMcpServer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an MCP server.  Args:     main_request: The main request object for rate limiting.     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.
         * @summary Delete Mcp Server
         * @param {string} mcpServerId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMcpServer(mcpServerId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMcpServer(mcpServerId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MCPServersApi.deleteMcpServer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all MCP subservers available in the system.  Args:     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPSubServerBinding]: List of all MCP subservers.
         * @summary Get All Mcp Subservers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMcpSubservers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneralMCPSubserverResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMcpSubservers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MCPServersApi.getAllMcpSubservers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an MCP server by ID.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The MCP server.
         * @summary Get Mcp Server
         * @param {string} mcpServerId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMcpServer(mcpServerId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MCPServerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMcpServer(mcpServerId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MCPServersApi.getMcpServer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List MCP servers in a workspace.  Args:     workspace_id: The workspace ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPServerResponse]: List of MCP servers.
         * @summary Search Mcp Servers
         * @param {string} workspaceId 
         * @param {MCPServerSearchRequest} mCPServerSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMcpServers(workspaceId: string, mCPServerSearchRequest: MCPServerSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MCPServerResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMcpServers(workspaceId, mCPServerSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MCPServersApi.searchMcpServers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an MCP server.  Args:     main_request: The main request object for rate limiting.     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     request: The update request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The updated MCP server.
         * @summary Update Mcp Server
         * @param {string} mcpServerId 
         * @param {string} workspaceId 
         * @param {MCPServerCreateRequest} mCPServerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMcpServer(mcpServerId: string, workspaceId: string, mCPServerCreateRequest: MCPServerCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MCPServerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMcpServer(mcpServerId, workspaceId, mCPServerCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MCPServersApi.updateMcpServer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MCPServersApi - factory interface
 * @export
 */
export const MCPServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MCPServersApiFp(configuration)
    return {
        /**
         * Create a new MCP server.  Args:     main_request: The main request object for rate limiting.     workspace_id: The workspace ID.     request: The MCP server creation request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerCreateResponse: The created MCP server with the raw API key.
         * @summary Create Mcp Server
         * @param {MCPServersApiCreateMcpServerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMcpServer(requestParameters: MCPServersApiCreateMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<MCPServerResponse> {
            return localVarFp.createMcpServer(requestParameters.workspaceId, requestParameters.mCPServerCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an MCP server.  Args:     main_request: The main request object for rate limiting.     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.
         * @summary Delete Mcp Server
         * @param {MCPServersApiDeleteMcpServerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMcpServer(requestParameters: MCPServersApiDeleteMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteMcpServer(requestParameters.mcpServerId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all MCP subservers available in the system.  Args:     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPSubServerBinding]: List of all MCP subservers.
         * @summary Get All Mcp Subservers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMcpSubservers(options?: RawAxiosRequestConfig): AxiosPromise<Array<GeneralMCPSubserverResponse>> {
            return localVarFp.getAllMcpSubservers(options).then((request) => request(axios, basePath));
        },
        /**
         * Get an MCP server by ID.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The MCP server.
         * @summary Get Mcp Server
         * @param {MCPServersApiGetMcpServerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMcpServer(requestParameters: MCPServersApiGetMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<MCPServerResponse> {
            return localVarFp.getMcpServer(requestParameters.mcpServerId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List MCP servers in a workspace.  Args:     workspace_id: The workspace ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPServerResponse]: List of MCP servers.
         * @summary Search Mcp Servers
         * @param {MCPServersApiSearchMcpServersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMcpServers(requestParameters: MCPServersApiSearchMcpServersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MCPServerResponse>> {
            return localVarFp.searchMcpServers(requestParameters.workspaceId, requestParameters.mCPServerSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an MCP server.  Args:     main_request: The main request object for rate limiting.     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     request: The update request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The updated MCP server.
         * @summary Update Mcp Server
         * @param {MCPServersApiUpdateMcpServerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMcpServer(requestParameters: MCPServersApiUpdateMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<MCPServerResponse> {
            return localVarFp.updateMcpServer(requestParameters.mcpServerId, requestParameters.workspaceId, requestParameters.mCPServerCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MCPServersApi - interface
 * @export
 * @interface MCPServersApi
 */
export interface MCPServersApiInterface {
    /**
     * Create a new MCP server.  Args:     main_request: The main request object for rate limiting.     workspace_id: The workspace ID.     request: The MCP server creation request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerCreateResponse: The created MCP server with the raw API key.
     * @summary Create Mcp Server
     * @param {MCPServersApiCreateMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApiInterface
     */
    createMcpServer(requestParameters: MCPServersApiCreateMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<MCPServerResponse>;

    /**
     * Delete an MCP server.  Args:     main_request: The main request object for rate limiting.     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.
     * @summary Delete Mcp Server
     * @param {MCPServersApiDeleteMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApiInterface
     */
    deleteMcpServer(requestParameters: MCPServersApiDeleteMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * Get all MCP subservers available in the system.  Args:     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPSubServerBinding]: List of all MCP subservers.
     * @summary Get All Mcp Subservers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApiInterface
     */
    getAllMcpSubservers(options?: RawAxiosRequestConfig): AxiosPromise<Array<GeneralMCPSubserverResponse>>;

    /**
     * Get an MCP server by ID.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The MCP server.
     * @summary Get Mcp Server
     * @param {MCPServersApiGetMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApiInterface
     */
    getMcpServer(requestParameters: MCPServersApiGetMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<MCPServerResponse>;

    /**
     * List MCP servers in a workspace.  Args:     workspace_id: The workspace ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPServerResponse]: List of MCP servers.
     * @summary Search Mcp Servers
     * @param {MCPServersApiSearchMcpServersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApiInterface
     */
    searchMcpServers(requestParameters: MCPServersApiSearchMcpServersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MCPServerResponse>>;

    /**
     * Update an MCP server.  Args:     main_request: The main request object for rate limiting.     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     request: The update request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The updated MCP server.
     * @summary Update Mcp Server
     * @param {MCPServersApiUpdateMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApiInterface
     */
    updateMcpServer(requestParameters: MCPServersApiUpdateMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<MCPServerResponse>;

}

/**
 * Request parameters for createMcpServer operation in MCPServersApi.
 * @export
 * @interface MCPServersApiCreateMcpServerRequest
 */
export interface MCPServersApiCreateMcpServerRequest {
    /**
     * 
     * @type {string}
     * @memberof MCPServersApiCreateMcpServer
     */
    readonly workspaceId: string

    /**
     * 
     * @type {MCPServerCreateRequest}
     * @memberof MCPServersApiCreateMcpServer
     */
    readonly mCPServerCreateRequest: MCPServerCreateRequest
}

/**
 * Request parameters for deleteMcpServer operation in MCPServersApi.
 * @export
 * @interface MCPServersApiDeleteMcpServerRequest
 */
export interface MCPServersApiDeleteMcpServerRequest {
    /**
     * 
     * @type {string}
     * @memberof MCPServersApiDeleteMcpServer
     */
    readonly mcpServerId: string

    /**
     * 
     * @type {string}
     * @memberof MCPServersApiDeleteMcpServer
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getMcpServer operation in MCPServersApi.
 * @export
 * @interface MCPServersApiGetMcpServerRequest
 */
export interface MCPServersApiGetMcpServerRequest {
    /**
     * 
     * @type {string}
     * @memberof MCPServersApiGetMcpServer
     */
    readonly mcpServerId: string

    /**
     * 
     * @type {string}
     * @memberof MCPServersApiGetMcpServer
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchMcpServers operation in MCPServersApi.
 * @export
 * @interface MCPServersApiSearchMcpServersRequest
 */
export interface MCPServersApiSearchMcpServersRequest {
    /**
     * 
     * @type {string}
     * @memberof MCPServersApiSearchMcpServers
     */
    readonly workspaceId: string

    /**
     * 
     * @type {MCPServerSearchRequest}
     * @memberof MCPServersApiSearchMcpServers
     */
    readonly mCPServerSearchRequest: MCPServerSearchRequest
}

/**
 * Request parameters for updateMcpServer operation in MCPServersApi.
 * @export
 * @interface MCPServersApiUpdateMcpServerRequest
 */
export interface MCPServersApiUpdateMcpServerRequest {
    /**
     * 
     * @type {string}
     * @memberof MCPServersApiUpdateMcpServer
     */
    readonly mcpServerId: string

    /**
     * 
     * @type {string}
     * @memberof MCPServersApiUpdateMcpServer
     */
    readonly workspaceId: string

    /**
     * 
     * @type {MCPServerCreateRequest}
     * @memberof MCPServersApiUpdateMcpServer
     */
    readonly mCPServerCreateRequest: MCPServerCreateRequest
}

/**
 * MCPServersApi - object-oriented interface
 * @export
 * @class MCPServersApi
 * @extends {BaseAPI}
 */
export class MCPServersApi extends BaseAPI implements MCPServersApiInterface {
    /**
     * Create a new MCP server.  Args:     main_request: The main request object for rate limiting.     workspace_id: The workspace ID.     request: The MCP server creation request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerCreateResponse: The created MCP server with the raw API key.
     * @summary Create Mcp Server
     * @param {MCPServersApiCreateMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApi
     */
    public createMcpServer(requestParameters: MCPServersApiCreateMcpServerRequest, options?: RawAxiosRequestConfig) {
        return MCPServersApiFp(this.configuration).createMcpServer(requestParameters.workspaceId, requestParameters.mCPServerCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an MCP server.  Args:     main_request: The main request object for rate limiting.     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.
     * @summary Delete Mcp Server
     * @param {MCPServersApiDeleteMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApi
     */
    public deleteMcpServer(requestParameters: MCPServersApiDeleteMcpServerRequest, options?: RawAxiosRequestConfig) {
        return MCPServersApiFp(this.configuration).deleteMcpServer(requestParameters.mcpServerId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all MCP subservers available in the system.  Args:     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPSubServerBinding]: List of all MCP subservers.
     * @summary Get All Mcp Subservers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApi
     */
    public getAllMcpSubservers(options?: RawAxiosRequestConfig) {
        return MCPServersApiFp(this.configuration).getAllMcpSubservers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an MCP server by ID.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The MCP server.
     * @summary Get Mcp Server
     * @param {MCPServersApiGetMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApi
     */
    public getMcpServer(requestParameters: MCPServersApiGetMcpServerRequest, options?: RawAxiosRequestConfig) {
        return MCPServersApiFp(this.configuration).getMcpServer(requestParameters.mcpServerId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List MCP servers in a workspace.  Args:     workspace_id: The workspace ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPServerResponse]: List of MCP servers.
     * @summary Search Mcp Servers
     * @param {MCPServersApiSearchMcpServersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApi
     */
    public searchMcpServers(requestParameters: MCPServersApiSearchMcpServersRequest, options?: RawAxiosRequestConfig) {
        return MCPServersApiFp(this.configuration).searchMcpServers(requestParameters.workspaceId, requestParameters.mCPServerSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an MCP server.  Args:     main_request: The main request object for rate limiting.     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     request: The update request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The updated MCP server.
     * @summary Update Mcp Server
     * @param {MCPServersApiUpdateMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApi
     */
    public updateMcpServer(requestParameters: MCPServersApiUpdateMcpServerRequest, options?: RawAxiosRequestConfig) {
        return MCPServersApiFp(this.configuration).updateMcpServer(requestParameters.mcpServerId, requestParameters.workspaceId, requestParameters.mCPServerCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Transcript
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {string} [postbackUrl] The post back URL where to send the response in body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranscript: async (workspaceId: string, file: File, postbackUrl?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getTranscript', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('getTranscript', 'file', file)
            const localVarPath = `/v2/media/transcript`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (postbackUrl !== undefined) { 
                localVarFormParams.append('postback_url', postbackUrl as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Transcript Result
         * @param {string} workspaceId 
         * @param {TranscriptTaskRequest} transcriptTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranscriptResult: async (workspaceId: string, transcriptTaskRequest: TranscriptTaskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getTranscriptResult', 'workspaceId', workspaceId)
            // verify required parameter 'transcriptTaskRequest' is not null or undefined
            assertParamExists('getTranscriptResult', 'transcriptTaskRequest', transcriptTaskRequest)
            const localVarPath = `/v2/media/transcript_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transcriptTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Youtube Transcript
         * @param {string} workspaceId 
         * @param {YoutubeTranscriptRequest} youtubeTranscriptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYoutubeTranscript: async (workspaceId: string, youtubeTranscriptRequest: YoutubeTranscriptRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getYoutubeTranscript', 'workspaceId', workspaceId)
            // verify required parameter 'youtubeTranscriptRequest' is not null or undefined
            assertParamExists('getYoutubeTranscript', 'youtubeTranscriptRequest', youtubeTranscriptRequest)
            const localVarPath = `/v2/media/youtube/transcript`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(youtubeTranscriptRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Transcript
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {string} [postbackUrl] The post back URL where to send the response in body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTranscript(workspaceId: string, file: File, postbackUrl?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentContentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTranscript(workspaceId, file, postbackUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getTranscript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Transcript Result
         * @param {string} workspaceId 
         * @param {TranscriptTaskRequest} transcriptTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTranscriptResult(workspaceId: string, transcriptTaskRequest: TranscriptTaskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentContentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTranscriptResult(workspaceId, transcriptTaskRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getTranscriptResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Youtube Transcript
         * @param {string} workspaceId 
         * @param {YoutubeTranscriptRequest} youtubeTranscriptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getYoutubeTranscript(workspaceId: string, youtubeTranscriptRequest: YoutubeTranscriptRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<YoutubeTranscriptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getYoutubeTranscript(workspaceId, youtubeTranscriptRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getYoutubeTranscript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Transcript
         * @param {MediaApiGetTranscriptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranscript(requestParameters: MediaApiGetTranscriptRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentContentResponse> {
            return localVarFp.getTranscript(requestParameters.workspaceId, requestParameters.file, requestParameters.postbackUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Transcript Result
         * @param {MediaApiGetTranscriptResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranscriptResult(requestParameters: MediaApiGetTranscriptResultRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentContentResponse> {
            return localVarFp.getTranscriptResult(requestParameters.workspaceId, requestParameters.transcriptTaskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Youtube Transcript
         * @param {MediaApiGetYoutubeTranscriptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYoutubeTranscript(requestParameters: MediaApiGetYoutubeTranscriptRequest, options?: RawAxiosRequestConfig): AxiosPromise<YoutubeTranscriptResponse> {
            return localVarFp.getYoutubeTranscript(requestParameters.workspaceId, requestParameters.youtubeTranscriptRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - interface
 * @export
 * @interface MediaApi
 */
export interface MediaApiInterface {
    /**
     * 
     * @summary Get Transcript
     * @param {MediaApiGetTranscriptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApiInterface
     */
    getTranscript(requestParameters: MediaApiGetTranscriptRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentContentResponse>;

    /**
     * 
     * @summary Get Transcript Result
     * @param {MediaApiGetTranscriptResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApiInterface
     */
    getTranscriptResult(requestParameters: MediaApiGetTranscriptResultRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentContentResponse>;

    /**
     * 
     * @summary Get Youtube Transcript
     * @param {MediaApiGetYoutubeTranscriptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApiInterface
     */
    getYoutubeTranscript(requestParameters: MediaApiGetYoutubeTranscriptRequest, options?: RawAxiosRequestConfig): AxiosPromise<YoutubeTranscriptResponse>;

}

/**
 * Request parameters for getTranscript operation in MediaApi.
 * @export
 * @interface MediaApiGetTranscriptRequest
 */
export interface MediaApiGetTranscriptRequest {
    /**
     * 
     * @type {string}
     * @memberof MediaApiGetTranscript
     */
    readonly workspaceId: string

    /**
     * 
     * @type {File}
     * @memberof MediaApiGetTranscript
     */
    readonly file: File

    /**
     * The post back URL where to send the response in body
     * @type {string}
     * @memberof MediaApiGetTranscript
     */
    readonly postbackUrl?: string
}

/**
 * Request parameters for getTranscriptResult operation in MediaApi.
 * @export
 * @interface MediaApiGetTranscriptResultRequest
 */
export interface MediaApiGetTranscriptResultRequest {
    /**
     * 
     * @type {string}
     * @memberof MediaApiGetTranscriptResult
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TranscriptTaskRequest}
     * @memberof MediaApiGetTranscriptResult
     */
    readonly transcriptTaskRequest: TranscriptTaskRequest
}

/**
 * Request parameters for getYoutubeTranscript operation in MediaApi.
 * @export
 * @interface MediaApiGetYoutubeTranscriptRequest
 */
export interface MediaApiGetYoutubeTranscriptRequest {
    /**
     * 
     * @type {string}
     * @memberof MediaApiGetYoutubeTranscript
     */
    readonly workspaceId: string

    /**
     * 
     * @type {YoutubeTranscriptRequest}
     * @memberof MediaApiGetYoutubeTranscript
     */
    readonly youtubeTranscriptRequest: YoutubeTranscriptRequest
}

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI implements MediaApiInterface {
    /**
     * 
     * @summary Get Transcript
     * @param {MediaApiGetTranscriptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getTranscript(requestParameters: MediaApiGetTranscriptRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getTranscript(requestParameters.workspaceId, requestParameters.file, requestParameters.postbackUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Transcript Result
     * @param {MediaApiGetTranscriptResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getTranscriptResult(requestParameters: MediaApiGetTranscriptResultRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getTranscriptResult(requestParameters.workspaceId, requestParameters.transcriptTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Youtube Transcript
     * @param {MediaApiGetYoutubeTranscriptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getYoutubeTranscript(requestParameters: MediaApiGetYoutubeTranscriptRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getYoutubeTranscript(requestParameters.workspaceId, requestParameters.youtubeTranscriptRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MemoryApi - axios parameter creator
 * @export
 */
export const MemoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Node
         * @param {string} workspaceId 
         * @param {NodeDetailRequest} nodeDetailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode: async (workspaceId: string, nodeDetailRequest: NodeDetailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createNode', 'workspaceId', workspaceId)
            // verify required parameter 'nodeDetailRequest' is not null or undefined
            assertParamExists('createNode', 'nodeDetailRequest', nodeDetailRequest)
            const localVarPath = `/v2/memory/node/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeDetailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Node
         * @param {string} nodeId 
         * @param {string} workspaceId 
         * @param {DeleteNodeRequest} deleteNodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNode: async (nodeId: string, workspaceId: string, deleteNodeRequest: DeleteNodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('deleteNode', 'nodeId', nodeId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteNode', 'workspaceId', workspaceId)
            // verify required parameter 'deleteNodeRequest' is not null or undefined
            assertParamExists('deleteNode', 'deleteNodeRequest', deleteNodeRequest)
            const localVarPath = `/v2/memory/node/{node_id}`
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteNodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Node
         * @param {string} nodeId 
         * @param {string} workspaceId 
         * @param {GetNodeRequest} getNodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode: async (nodeId: string, workspaceId: string, getNodeRequest: GetNodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('getNode', 'nodeId', nodeId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getNode', 'workspaceId', workspaceId)
            // verify required parameter 'getNodeRequest' is not null or undefined
            assertParamExists('getNode', 'getNodeRequest', getNodeRequest)
            const localVarPath = `/v2/memory/node/{node_id}`
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getNodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get offloaded content for a memory node.  Args:     workspace_id: The workspace ID     node_id: The node ID     offload_id: The offload ID to retrieve     node_request: Request containing cat_id     memory_controller: Memory controller dependency     user: Current user  Returns:     The offloaded content as plain text
         * @summary Get Offloaded Content
         * @param {string} nodeId 
         * @param {string} offloadId 
         * @param {string} workspaceId 
         * @param {GetNodeRequest} getNodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadedContent: async (nodeId: string, offloadId: string, workspaceId: string, getNodeRequest: GetNodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('getOffloadedContent', 'nodeId', nodeId)
            // verify required parameter 'offloadId' is not null or undefined
            assertParamExists('getOffloadedContent', 'offloadId', offloadId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getOffloadedContent', 'workspaceId', workspaceId)
            // verify required parameter 'getNodeRequest' is not null or undefined
            assertParamExists('getOffloadedContent', 'getNodeRequest', getNodeRequest)
            const localVarPath = `/v2/memory/node/{node_id}/offload/{offload_id}`
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)))
                .replace(`{${"offload_id"}}`, encodeURIComponent(String(offloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getNodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Process Documents
         * @param {string} workspaceId 
         * @param {MemoryDocumentProcessRequest} memoryDocumentProcessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processDocuments: async (workspaceId: string, memoryDocumentProcessRequest: MemoryDocumentProcessRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('processDocuments', 'workspaceId', workspaceId)
            // verify required parameter 'memoryDocumentProcessRequest' is not null or undefined
            assertParamExists('processDocuments', 'memoryDocumentProcessRequest', memoryDocumentProcessRequest)
            const localVarPath = `/v2/memory/process-documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memoryDocumentProcessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Memory Categories
         * @param {string} workspaceId 
         * @param {MemorySearchRequest} memorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMemoryCategories: async (workspaceId: string, memorySearchRequest: MemorySearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchMemoryCategories', 'workspaceId', workspaceId)
            // verify required parameter 'memorySearchRequest' is not null or undefined
            assertParamExists('searchMemoryCategories', 'memorySearchRequest', memorySearchRequest)
            const localVarPath = `/v2/memory/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memorySearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Memory Node Name
         * @param {string} workspaceId 
         * @param {MemoryNodeNameSearchRequest} memoryNodeNameSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMemoryNodeName: async (workspaceId: string, memoryNodeNameSearchRequest: MemoryNodeNameSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchMemoryNodeName', 'workspaceId', workspaceId)
            // verify required parameter 'memoryNodeNameSearchRequest' is not null or undefined
            assertParamExists('searchMemoryNodeName', 'memoryNodeNameSearchRequest', memoryNodeNameSearchRequest)
            const localVarPath = `/v2/memory/search_node_name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memoryNodeNameSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Memory Node Path
         * @param {string} workspaceId 
         * @param {MemoryNodePathSearchRequest} memoryNodePathSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMemoryNodePath: async (workspaceId: string, memoryNodePathSearchRequest: MemoryNodePathSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchMemoryNodePath', 'workspaceId', workspaceId)
            // verify required parameter 'memoryNodePathSearchRequest' is not null or undefined
            assertParamExists('searchMemoryNodePath', 'memoryNodePathSearchRequest', memoryNodePathSearchRequest)
            const localVarPath = `/v2/memory/search_node_path`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memoryNodePathSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Node
         * @param {string} nodeId 
         * @param {string} workspaceId 
         * @param {NodeUpdateRequest} nodeUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNode: async (nodeId: string, workspaceId: string, nodeUpdateRequest: NodeUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('updateNode', 'nodeId', nodeId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateNode', 'workspaceId', workspaceId)
            // verify required parameter 'nodeUpdateRequest' is not null or undefined
            assertParamExists('updateNode', 'nodeUpdateRequest', nodeUpdateRequest)
            const localVarPath = `/v2/memory/node/{node_id}`
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Memory Node Document
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMemoryNodeDocument: async (catId: string, workspaceId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('uploadMemoryNodeDocument', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('uploadMemoryNodeDocument', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadMemoryNodeDocument', 'file', file)
            const localVarPath = `/v2/memory/upload/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MemoryApi - functional programming interface
 * @export
 */
export const MemoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MemoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Node
         * @param {string} workspaceId 
         * @param {NodeDetailRequest} nodeDetailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNode(workspaceId: string, nodeDetailRequest: NodeDetailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryNodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNode(workspaceId, nodeDetailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.createNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Node
         * @param {string} nodeId 
         * @param {string} workspaceId 
         * @param {DeleteNodeRequest} deleteNodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNode(nodeId: string, workspaceId: string, deleteNodeRequest: DeleteNodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNode(nodeId, workspaceId, deleteNodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.deleteNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Node
         * @param {string} nodeId 
         * @param {string} workspaceId 
         * @param {GetNodeRequest} getNodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNode(nodeId: string, workspaceId: string, getNodeRequest: GetNodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryNodeDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNode(nodeId, workspaceId, getNodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.getNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get offloaded content for a memory node.  Args:     workspace_id: The workspace ID     node_id: The node ID     offload_id: The offload ID to retrieve     node_request: Request containing cat_id     memory_controller: Memory controller dependency     user: Current user  Returns:     The offloaded content as plain text
         * @summary Get Offloaded Content
         * @param {string} nodeId 
         * @param {string} offloadId 
         * @param {string} workspaceId 
         * @param {GetNodeRequest} getNodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOffloadedContent(nodeId: string, offloadId: string, workspaceId: string, getNodeRequest: GetNodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOffloadedContent(nodeId, offloadId, workspaceId, getNodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.getOffloadedContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Process Documents
         * @param {string} workspaceId 
         * @param {MemoryDocumentProcessRequest} memoryDocumentProcessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processDocuments(workspaceId: string, memoryDocumentProcessRequest: MemoryDocumentProcessRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processDocuments(workspaceId, memoryDocumentProcessRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.processDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Memory Categories
         * @param {string} workspaceId 
         * @param {MemorySearchRequest} memorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMemoryCategories(workspaceId: string, memorySearchRequest: MemorySearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemorySearchResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMemoryCategories(workspaceId, memorySearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.searchMemoryCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Memory Node Name
         * @param {string} workspaceId 
         * @param {MemoryNodeNameSearchRequest} memoryNodeNameSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMemoryNodeName(workspaceId: string, memoryNodeNameSearchRequest: MemoryNodeNameSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemorySearchResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMemoryNodeName(workspaceId, memoryNodeNameSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.searchMemoryNodeName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Memory Node Path
         * @param {string} workspaceId 
         * @param {MemoryNodePathSearchRequest} memoryNodePathSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMemoryNodePath(workspaceId: string, memoryNodePathSearchRequest: MemoryNodePathSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemorySearchResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMemoryNodePath(workspaceId, memoryNodePathSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.searchMemoryNodePath']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Node
         * @param {string} nodeId 
         * @param {string} workspaceId 
         * @param {NodeUpdateRequest} nodeUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNode(nodeId: string, workspaceId: string, nodeUpdateRequest: NodeUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryNodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNode(nodeId, workspaceId, nodeUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.updateNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Memory Node Document
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadMemoryNodeDocument(catId: string, workspaceId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryDocumentUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadMemoryNodeDocument(catId, workspaceId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.uploadMemoryNodeDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MemoryApi - factory interface
 * @export
 */
export const MemoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MemoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Node
         * @param {MemoryApiCreateNodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode(requestParameters: MemoryApiCreateNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryNodeResponse> {
            return localVarFp.createNode(requestParameters.workspaceId, requestParameters.nodeDetailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Node
         * @param {MemoryApiDeleteNodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNode(requestParameters: MemoryApiDeleteNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryMessageResponse> {
            return localVarFp.deleteNode(requestParameters.nodeId, requestParameters.workspaceId, requestParameters.deleteNodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Node
         * @param {MemoryApiGetNodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode(requestParameters: MemoryApiGetNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryNodeDetailResponse> {
            return localVarFp.getNode(requestParameters.nodeId, requestParameters.workspaceId, requestParameters.getNodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get offloaded content for a memory node.  Args:     workspace_id: The workspace ID     node_id: The node ID     offload_id: The offload ID to retrieve     node_request: Request containing cat_id     memory_controller: Memory controller dependency     user: Current user  Returns:     The offloaded content as plain text
         * @summary Get Offloaded Content
         * @param {MemoryApiGetOffloadedContentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadedContent(requestParameters: MemoryApiGetOffloadedContentRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getOffloadedContent(requestParameters.nodeId, requestParameters.offloadId, requestParameters.workspaceId, requestParameters.getNodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Process Documents
         * @param {MemoryApiProcessDocumentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processDocuments(requestParameters: MemoryApiProcessDocumentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryMessageResponse> {
            return localVarFp.processDocuments(requestParameters.workspaceId, requestParameters.memoryDocumentProcessRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Memory Categories
         * @param {MemoryApiSearchMemoryCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMemoryCategories(requestParameters: MemoryApiSearchMemoryCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MemorySearchResponse>> {
            return localVarFp.searchMemoryCategories(requestParameters.workspaceId, requestParameters.memorySearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Memory Node Name
         * @param {MemoryApiSearchMemoryNodeNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMemoryNodeName(requestParameters: MemoryApiSearchMemoryNodeNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MemorySearchResponse>> {
            return localVarFp.searchMemoryNodeName(requestParameters.workspaceId, requestParameters.memoryNodeNameSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Memory Node Path
         * @param {MemoryApiSearchMemoryNodePathRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMemoryNodePath(requestParameters: MemoryApiSearchMemoryNodePathRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MemorySearchResponse>> {
            return localVarFp.searchMemoryNodePath(requestParameters.workspaceId, requestParameters.memoryNodePathSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Node
         * @param {MemoryApiUpdateNodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNode(requestParameters: MemoryApiUpdateNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryNodeResponse> {
            return localVarFp.updateNode(requestParameters.nodeId, requestParameters.workspaceId, requestParameters.nodeUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Memory Node Document
         * @param {MemoryApiUploadMemoryNodeDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMemoryNodeDocument(requestParameters: MemoryApiUploadMemoryNodeDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryDocumentUploadResponse> {
            return localVarFp.uploadMemoryNodeDocument(requestParameters.catId, requestParameters.workspaceId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MemoryApi - interface
 * @export
 * @interface MemoryApi
 */
export interface MemoryApiInterface {
    /**
     * 
     * @summary Create Node
     * @param {MemoryApiCreateNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    createNode(requestParameters: MemoryApiCreateNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryNodeResponse>;

    /**
     * 
     * @summary Delete Node
     * @param {MemoryApiDeleteNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    deleteNode(requestParameters: MemoryApiDeleteNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryMessageResponse>;

    /**
     * 
     * @summary Get Node
     * @param {MemoryApiGetNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    getNode(requestParameters: MemoryApiGetNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryNodeDetailResponse>;

    /**
     * Get offloaded content for a memory node.  Args:     workspace_id: The workspace ID     node_id: The node ID     offload_id: The offload ID to retrieve     node_request: Request containing cat_id     memory_controller: Memory controller dependency     user: Current user  Returns:     The offloaded content as plain text
     * @summary Get Offloaded Content
     * @param {MemoryApiGetOffloadedContentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    getOffloadedContent(requestParameters: MemoryApiGetOffloadedContentRequest, options?: RawAxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Process Documents
     * @param {MemoryApiProcessDocumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    processDocuments(requestParameters: MemoryApiProcessDocumentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryMessageResponse>;

    /**
     * 
     * @summary Search Memory Categories
     * @param {MemoryApiSearchMemoryCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    searchMemoryCategories(requestParameters: MemoryApiSearchMemoryCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MemorySearchResponse>>;

    /**
     * 
     * @summary Search Memory Node Name
     * @param {MemoryApiSearchMemoryNodeNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    searchMemoryNodeName(requestParameters: MemoryApiSearchMemoryNodeNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MemorySearchResponse>>;

    /**
     * 
     * @summary Search Memory Node Path
     * @param {MemoryApiSearchMemoryNodePathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    searchMemoryNodePath(requestParameters: MemoryApiSearchMemoryNodePathRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MemorySearchResponse>>;

    /**
     * 
     * @summary Update Node
     * @param {MemoryApiUpdateNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    updateNode(requestParameters: MemoryApiUpdateNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryNodeResponse>;

    /**
     * 
     * @summary Upload Memory Node Document
     * @param {MemoryApiUploadMemoryNodeDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    uploadMemoryNodeDocument(requestParameters: MemoryApiUploadMemoryNodeDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryDocumentUploadResponse>;

}

/**
 * Request parameters for createNode operation in MemoryApi.
 * @export
 * @interface MemoryApiCreateNodeRequest
 */
export interface MemoryApiCreateNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiCreateNode
     */
    readonly workspaceId: string

    /**
     * 
     * @type {NodeDetailRequest}
     * @memberof MemoryApiCreateNode
     */
    readonly nodeDetailRequest: NodeDetailRequest
}

/**
 * Request parameters for deleteNode operation in MemoryApi.
 * @export
 * @interface MemoryApiDeleteNodeRequest
 */
export interface MemoryApiDeleteNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiDeleteNode
     */
    readonly nodeId: string

    /**
     * 
     * @type {string}
     * @memberof MemoryApiDeleteNode
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DeleteNodeRequest}
     * @memberof MemoryApiDeleteNode
     */
    readonly deleteNodeRequest: DeleteNodeRequest
}

/**
 * Request parameters for getNode operation in MemoryApi.
 * @export
 * @interface MemoryApiGetNodeRequest
 */
export interface MemoryApiGetNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiGetNode
     */
    readonly nodeId: string

    /**
     * 
     * @type {string}
     * @memberof MemoryApiGetNode
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GetNodeRequest}
     * @memberof MemoryApiGetNode
     */
    readonly getNodeRequest: GetNodeRequest
}

/**
 * Request parameters for getOffloadedContent operation in MemoryApi.
 * @export
 * @interface MemoryApiGetOffloadedContentRequest
 */
export interface MemoryApiGetOffloadedContentRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiGetOffloadedContent
     */
    readonly nodeId: string

    /**
     * 
     * @type {string}
     * @memberof MemoryApiGetOffloadedContent
     */
    readonly offloadId: string

    /**
     * 
     * @type {string}
     * @memberof MemoryApiGetOffloadedContent
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GetNodeRequest}
     * @memberof MemoryApiGetOffloadedContent
     */
    readonly getNodeRequest: GetNodeRequest
}

/**
 * Request parameters for processDocuments operation in MemoryApi.
 * @export
 * @interface MemoryApiProcessDocumentsRequest
 */
export interface MemoryApiProcessDocumentsRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiProcessDocuments
     */
    readonly workspaceId: string

    /**
     * 
     * @type {MemoryDocumentProcessRequest}
     * @memberof MemoryApiProcessDocuments
     */
    readonly memoryDocumentProcessRequest: MemoryDocumentProcessRequest
}

/**
 * Request parameters for searchMemoryCategories operation in MemoryApi.
 * @export
 * @interface MemoryApiSearchMemoryCategoriesRequest
 */
export interface MemoryApiSearchMemoryCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiSearchMemoryCategories
     */
    readonly workspaceId: string

    /**
     * 
     * @type {MemorySearchRequest}
     * @memberof MemoryApiSearchMemoryCategories
     */
    readonly memorySearchRequest: MemorySearchRequest
}

/**
 * Request parameters for searchMemoryNodeName operation in MemoryApi.
 * @export
 * @interface MemoryApiSearchMemoryNodeNameRequest
 */
export interface MemoryApiSearchMemoryNodeNameRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiSearchMemoryNodeName
     */
    readonly workspaceId: string

    /**
     * 
     * @type {MemoryNodeNameSearchRequest}
     * @memberof MemoryApiSearchMemoryNodeName
     */
    readonly memoryNodeNameSearchRequest: MemoryNodeNameSearchRequest
}

/**
 * Request parameters for searchMemoryNodePath operation in MemoryApi.
 * @export
 * @interface MemoryApiSearchMemoryNodePathRequest
 */
export interface MemoryApiSearchMemoryNodePathRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiSearchMemoryNodePath
     */
    readonly workspaceId: string

    /**
     * 
     * @type {MemoryNodePathSearchRequest}
     * @memberof MemoryApiSearchMemoryNodePath
     */
    readonly memoryNodePathSearchRequest: MemoryNodePathSearchRequest
}

/**
 * Request parameters for updateNode operation in MemoryApi.
 * @export
 * @interface MemoryApiUpdateNodeRequest
 */
export interface MemoryApiUpdateNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiUpdateNode
     */
    readonly nodeId: string

    /**
     * 
     * @type {string}
     * @memberof MemoryApiUpdateNode
     */
    readonly workspaceId: string

    /**
     * 
     * @type {NodeUpdateRequest}
     * @memberof MemoryApiUpdateNode
     */
    readonly nodeUpdateRequest: NodeUpdateRequest
}

/**
 * Request parameters for uploadMemoryNodeDocument operation in MemoryApi.
 * @export
 * @interface MemoryApiUploadMemoryNodeDocumentRequest
 */
export interface MemoryApiUploadMemoryNodeDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiUploadMemoryNodeDocument
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof MemoryApiUploadMemoryNodeDocument
     */
    readonly workspaceId: string

    /**
     * 
     * @type {File}
     * @memberof MemoryApiUploadMemoryNodeDocument
     */
    readonly file: File
}

/**
 * MemoryApi - object-oriented interface
 * @export
 * @class MemoryApi
 * @extends {BaseAPI}
 */
export class MemoryApi extends BaseAPI implements MemoryApiInterface {
    /**
     * 
     * @summary Create Node
     * @param {MemoryApiCreateNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public createNode(requestParameters: MemoryApiCreateNodeRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).createNode(requestParameters.workspaceId, requestParameters.nodeDetailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Node
     * @param {MemoryApiDeleteNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public deleteNode(requestParameters: MemoryApiDeleteNodeRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).deleteNode(requestParameters.nodeId, requestParameters.workspaceId, requestParameters.deleteNodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Node
     * @param {MemoryApiGetNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public getNode(requestParameters: MemoryApiGetNodeRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).getNode(requestParameters.nodeId, requestParameters.workspaceId, requestParameters.getNodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get offloaded content for a memory node.  Args:     workspace_id: The workspace ID     node_id: The node ID     offload_id: The offload ID to retrieve     node_request: Request containing cat_id     memory_controller: Memory controller dependency     user: Current user  Returns:     The offloaded content as plain text
     * @summary Get Offloaded Content
     * @param {MemoryApiGetOffloadedContentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public getOffloadedContent(requestParameters: MemoryApiGetOffloadedContentRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).getOffloadedContent(requestParameters.nodeId, requestParameters.offloadId, requestParameters.workspaceId, requestParameters.getNodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Process Documents
     * @param {MemoryApiProcessDocumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public processDocuments(requestParameters: MemoryApiProcessDocumentsRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).processDocuments(requestParameters.workspaceId, requestParameters.memoryDocumentProcessRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Memory Categories
     * @param {MemoryApiSearchMemoryCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public searchMemoryCategories(requestParameters: MemoryApiSearchMemoryCategoriesRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).searchMemoryCategories(requestParameters.workspaceId, requestParameters.memorySearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Memory Node Name
     * @param {MemoryApiSearchMemoryNodeNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public searchMemoryNodeName(requestParameters: MemoryApiSearchMemoryNodeNameRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).searchMemoryNodeName(requestParameters.workspaceId, requestParameters.memoryNodeNameSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Memory Node Path
     * @param {MemoryApiSearchMemoryNodePathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public searchMemoryNodePath(requestParameters: MemoryApiSearchMemoryNodePathRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).searchMemoryNodePath(requestParameters.workspaceId, requestParameters.memoryNodePathSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Node
     * @param {MemoryApiUpdateNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public updateNode(requestParameters: MemoryApiUpdateNodeRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).updateNode(requestParameters.nodeId, requestParameters.workspaceId, requestParameters.nodeUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Memory Node Document
     * @param {MemoryApiUploadMemoryNodeDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public uploadMemoryNodeDocument(requestParameters: MemoryApiUploadMemoryNodeDocumentRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).uploadMemoryNodeDocument(requestParameters.catId, requestParameters.workspaceId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MicrosoftOutlookApi - axios parameter creator
 * @export
 */
export const MicrosoftOutlookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update Admin Consent
         * @param {string} workspaceId 
         * @param {string} integrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdminConsent: async (workspaceId: string, integrationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateAdminConsent', 'workspaceId', workspaceId)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('updateAdminConsent', 'integrationId', integrationId)
            const localVarPath = `/v2/integrations/microsoft_entra_id/admin_consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (integrationId !== undefined) {
                localVarQueryParameter['integration_id'] = integrationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MicrosoftOutlookApi - functional programming interface
 * @export
 */
export const MicrosoftOutlookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MicrosoftOutlookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update Admin Consent
         * @param {string} workspaceId 
         * @param {string} integrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAdminConsent(workspaceId: string, integrationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAdminConsent(workspaceId, integrationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MicrosoftOutlookApi.updateAdminConsent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MicrosoftOutlookApi - factory interface
 * @export
 */
export const MicrosoftOutlookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MicrosoftOutlookApiFp(configuration)
    return {
        /**
         * 
         * @summary Update Admin Consent
         * @param {MicrosoftOutlookApiUpdateAdminConsentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdminConsent(requestParameters: MicrosoftOutlookApiUpdateAdminConsentRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationDetailResponse> {
            return localVarFp.updateAdminConsent(requestParameters.workspaceId, requestParameters.integrationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MicrosoftOutlookApi - interface
 * @export
 * @interface MicrosoftOutlookApi
 */
export interface MicrosoftOutlookApiInterface {
    /**
     * 
     * @summary Update Admin Consent
     * @param {MicrosoftOutlookApiUpdateAdminConsentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrosoftOutlookApiInterface
     */
    updateAdminConsent(requestParameters: MicrosoftOutlookApiUpdateAdminConsentRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationDetailResponse>;

}

/**
 * Request parameters for updateAdminConsent operation in MicrosoftOutlookApi.
 * @export
 * @interface MicrosoftOutlookApiUpdateAdminConsentRequest
 */
export interface MicrosoftOutlookApiUpdateAdminConsentRequest {
    /**
     * 
     * @type {string}
     * @memberof MicrosoftOutlookApiUpdateAdminConsent
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof MicrosoftOutlookApiUpdateAdminConsent
     */
    readonly integrationId: string
}

/**
 * MicrosoftOutlookApi - object-oriented interface
 * @export
 * @class MicrosoftOutlookApi
 * @extends {BaseAPI}
 */
export class MicrosoftOutlookApi extends BaseAPI implements MicrosoftOutlookApiInterface {
    /**
     * 
     * @summary Update Admin Consent
     * @param {MicrosoftOutlookApiUpdateAdminConsentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrosoftOutlookApi
     */
    public updateAdminConsent(requestParameters: MicrosoftOutlookApiUpdateAdminConsentRequest, options?: RawAxiosRequestConfig) {
        return MicrosoftOutlookApiFp(this.configuration).updateAdminConsent(requestParameters.workspaceId, requestParameters.integrationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ObservabilityDriverApi - axios parameter creator
 * @export
 */
export const ObservabilityDriverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Activate Langfuse Observability Driver
         * @param {string} workspaceId 
         * @param {LangfuseRequest} langfuseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateLangfuseObservabilityDriver: async (workspaceId: string, langfuseRequest: LangfuseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('activateLangfuseObservabilityDriver', 'workspaceId', workspaceId)
            // verify required parameter 'langfuseRequest' is not null or undefined
            assertParamExists('activateLangfuseObservabilityDriver', 'langfuseRequest', langfuseRequest)
            const localVarPath = `/v2/observability_driver/langfuse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(langfuseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Activate Power Bi Observability Driver
         * @param {string} workspaceId 
         * @param {PowerBiRequest} powerBiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePowerBiObservabilityDriver: async (workspaceId: string, powerBiRequest: PowerBiRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('activatePowerBiObservabilityDriver', 'workspaceId', workspaceId)
            // verify required parameter 'powerBiRequest' is not null or undefined
            assertParamExists('activatePowerBiObservabilityDriver', 'powerBiRequest', powerBiRequest)
            const localVarPath = `/v2/observability_driver/power_bi`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(powerBiRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Power Bi Push Dataset
         * @param {string} workspaceId 
         * @param {PowerBiPushDatasetRequest} powerBiPushDatasetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPowerBiPushDataset: async (workspaceId: string, powerBiPushDatasetRequest: PowerBiPushDatasetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createPowerBiPushDataset', 'workspaceId', workspaceId)
            // verify required parameter 'powerBiPushDatasetRequest' is not null or undefined
            assertParamExists('createPowerBiPushDataset', 'powerBiPushDatasetRequest', powerBiPushDatasetRequest)
            const localVarPath = `/v2/observability_driver/power_bi/push_dataset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(powerBiPushDatasetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Observability Driver
         * @param {DriverType} driverType 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObservabilityDriver: async (driverType: DriverType, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driverType' is not null or undefined
            assertParamExists('deleteObservabilityDriver', 'driverType', driverType)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteObservabilityDriver', 'workspaceId', workspaceId)
            const localVarPath = `/v2/observability_driver/{driver_type}`
                .replace(`{${"driver_type"}}`, encodeURIComponent(String(driverType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Observability Driver
         * @param {DriverType} driverType 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObservabilityDriver: async (driverType: DriverType, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driverType' is not null or undefined
            assertParamExists('getObservabilityDriver', 'driverType', driverType)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getObservabilityDriver', 'workspaceId', workspaceId)
            const localVarPath = `/v2/observability_driver/{driver_type}`
                .replace(`{${"driver_type"}}`, encodeURIComponent(String(driverType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Observability Driver Workspace
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObservabilityDriverWorkspace: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getObservabilityDriverWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/v2/observability_driver/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Power Bi Datasets
         * @param {string} workspaceId 
         * @param {PowerBiDatasetRequest} powerBiDatasetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPowerBiDatasets: async (workspaceId: string, powerBiDatasetRequest: PowerBiDatasetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listPowerBiDatasets', 'workspaceId', workspaceId)
            // verify required parameter 'powerBiDatasetRequest' is not null or undefined
            assertParamExists('listPowerBiDatasets', 'powerBiDatasetRequest', powerBiDatasetRequest)
            const localVarPath = `/v2/observability_driver/power_bi/datasets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(powerBiDatasetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Power Bi Tables
         * @param {string} workspaceId 
         * @param {PowerBiTableRequest} powerBiTableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPowerBiTables: async (workspaceId: string, powerBiTableRequest: PowerBiTableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listPowerBiTables', 'workspaceId', workspaceId)
            // verify required parameter 'powerBiTableRequest' is not null or undefined
            assertParamExists('listPowerBiTables', 'powerBiTableRequest', powerBiTableRequest)
            const localVarPath = `/v2/observability_driver/power_bi/tables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(powerBiTableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Power Bi Workspaces
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPowerBiWorkspaces: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listPowerBiWorkspaces', 'workspaceId', workspaceId)
            const localVarPath = `/v2/observability_driver/power_bi/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Langfuse Observability Driver
         * @param {string} workspaceId 
         * @param {LangfuseRequest} langfuseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLangfuseObservabilityDriver: async (workspaceId: string, langfuseRequest: LangfuseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateLangfuseObservabilityDriver', 'workspaceId', workspaceId)
            // verify required parameter 'langfuseRequest' is not null or undefined
            assertParamExists('updateLangfuseObservabilityDriver', 'langfuseRequest', langfuseRequest)
            const localVarPath = `/v2/observability_driver/langfuse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(langfuseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Power Bi Observability Driver
         * @param {string} workspaceId 
         * @param {PowerBiRequest} powerBiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePowerBiObservabilityDriver: async (workspaceId: string, powerBiRequest: PowerBiRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updatePowerBiObservabilityDriver', 'workspaceId', workspaceId)
            // verify required parameter 'powerBiRequest' is not null or undefined
            assertParamExists('updatePowerBiObservabilityDriver', 'powerBiRequest', powerBiRequest)
            const localVarPath = `/v2/observability_driver/power_bi`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(powerBiRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate Push Dataset Table
         * @param {string} workspaceId 
         * @param {PowerBiRequest} powerBiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePushDatasetTable: async (workspaceId: string, powerBiRequest: PowerBiRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('validatePushDatasetTable', 'workspaceId', workspaceId)
            // verify required parameter 'powerBiRequest' is not null or undefined
            assertParamExists('validatePushDatasetTable', 'powerBiRequest', powerBiRequest)
            const localVarPath = `/v2/observability_driver/power_bi/validate_push_dataset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(powerBiRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObservabilityDriverApi - functional programming interface
 * @export
 */
export const ObservabilityDriverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ObservabilityDriverApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Activate Langfuse Observability Driver
         * @param {string} workspaceId 
         * @param {LangfuseRequest} langfuseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateLangfuseObservabilityDriver(workspaceId: string, langfuseRequest: LangfuseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservabilityDriverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateLangfuseObservabilityDriver(workspaceId, langfuseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.activateLangfuseObservabilityDriver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Activate Power Bi Observability Driver
         * @param {string} workspaceId 
         * @param {PowerBiRequest} powerBiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activatePowerBiObservabilityDriver(workspaceId: string, powerBiRequest: PowerBiRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservabilityDriverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activatePowerBiObservabilityDriver(workspaceId, powerBiRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.activatePowerBiObservabilityDriver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Power Bi Push Dataset
         * @param {string} workspaceId 
         * @param {PowerBiPushDatasetRequest} powerBiPushDatasetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPowerBiPushDataset(workspaceId: string, powerBiPushDatasetRequest: PowerBiPushDatasetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MicrosoftPowerBiPushDatasetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPowerBiPushDataset(workspaceId, powerBiPushDatasetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.createPowerBiPushDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Observability Driver
         * @param {DriverType} driverType 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteObservabilityDriver(driverType: DriverType, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteObservabilityDriver(driverType, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.deleteObservabilityDriver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Observability Driver
         * @param {DriverType} driverType 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getObservabilityDriver(driverType: DriverType, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservabilityDriverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getObservabilityDriver(driverType, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.getObservabilityDriver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Observability Driver Workspace
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getObservabilityDriverWorkspace(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ObservabilityDriverResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getObservabilityDriverWorkspace(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.getObservabilityDriverWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Power Bi Datasets
         * @param {string} workspaceId 
         * @param {PowerBiDatasetRequest} powerBiDatasetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPowerBiDatasets(workspaceId: string, powerBiDatasetRequest: PowerBiDatasetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MicrosoftPowerBiDatasetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPowerBiDatasets(workspaceId, powerBiDatasetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.listPowerBiDatasets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Power Bi Tables
         * @param {string} workspaceId 
         * @param {PowerBiTableRequest} powerBiTableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPowerBiTables(workspaceId: string, powerBiTableRequest: PowerBiTableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MicrosoftPowerBiTablesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPowerBiTables(workspaceId, powerBiTableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.listPowerBiTables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Power Bi Workspaces
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPowerBiWorkspaces(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MicrosoftPowerBiWorkspacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPowerBiWorkspaces(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.listPowerBiWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Langfuse Observability Driver
         * @param {string} workspaceId 
         * @param {LangfuseRequest} langfuseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLangfuseObservabilityDriver(workspaceId: string, langfuseRequest: LangfuseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservabilityDriverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLangfuseObservabilityDriver(workspaceId, langfuseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.updateLangfuseObservabilityDriver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Power Bi Observability Driver
         * @param {string} workspaceId 
         * @param {PowerBiRequest} powerBiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePowerBiObservabilityDriver(workspaceId: string, powerBiRequest: PowerBiRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservabilityDriverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePowerBiObservabilityDriver(workspaceId, powerBiRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.updatePowerBiObservabilityDriver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Validate Push Dataset Table
         * @param {string} workspaceId 
         * @param {PowerBiRequest} powerBiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatePushDatasetTable(workspaceId: string, powerBiRequest: PowerBiRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MicrosoftPowerBiTableValidateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatePushDatasetTable(workspaceId, powerBiRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.validatePushDatasetTable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ObservabilityDriverApi - factory interface
 * @export
 */
export const ObservabilityDriverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ObservabilityDriverApiFp(configuration)
    return {
        /**
         * 
         * @summary Activate Langfuse Observability Driver
         * @param {ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateLangfuseObservabilityDriver(requestParameters: ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse> {
            return localVarFp.activateLangfuseObservabilityDriver(requestParameters.workspaceId, requestParameters.langfuseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Activate Power Bi Observability Driver
         * @param {ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePowerBiObservabilityDriver(requestParameters: ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse> {
            return localVarFp.activatePowerBiObservabilityDriver(requestParameters.workspaceId, requestParameters.powerBiRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Power Bi Push Dataset
         * @param {ObservabilityDriverApiCreatePowerBiPushDatasetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPowerBiPushDataset(requestParameters: ObservabilityDriverApiCreatePowerBiPushDatasetRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiPushDatasetResponse> {
            return localVarFp.createPowerBiPushDataset(requestParameters.workspaceId, requestParameters.powerBiPushDatasetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Observability Driver
         * @param {ObservabilityDriverApiDeleteObservabilityDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObservabilityDriver(requestParameters: ObservabilityDriverApiDeleteObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<DriverSuccessResponse> {
            return localVarFp.deleteObservabilityDriver(requestParameters.driverType, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Observability Driver
         * @param {ObservabilityDriverApiGetObservabilityDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObservabilityDriver(requestParameters: ObservabilityDriverApiGetObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse> {
            return localVarFp.getObservabilityDriver(requestParameters.driverType, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Observability Driver Workspace
         * @param {ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObservabilityDriverWorkspace(requestParameters: ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ObservabilityDriverResponse>> {
            return localVarFp.getObservabilityDriverWorkspace(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Power Bi Datasets
         * @param {ObservabilityDriverApiListPowerBiDatasetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPowerBiDatasets(requestParameters: ObservabilityDriverApiListPowerBiDatasetsRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiDatasetsResponse> {
            return localVarFp.listPowerBiDatasets(requestParameters.workspaceId, requestParameters.powerBiDatasetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Power Bi Tables
         * @param {ObservabilityDriverApiListPowerBiTablesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPowerBiTables(requestParameters: ObservabilityDriverApiListPowerBiTablesRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiTablesResponse> {
            return localVarFp.listPowerBiTables(requestParameters.workspaceId, requestParameters.powerBiTableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Power Bi Workspaces
         * @param {ObservabilityDriverApiListPowerBiWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPowerBiWorkspaces(requestParameters: ObservabilityDriverApiListPowerBiWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiWorkspacesResponse> {
            return localVarFp.listPowerBiWorkspaces(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Langfuse Observability Driver
         * @param {ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLangfuseObservabilityDriver(requestParameters: ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse> {
            return localVarFp.updateLangfuseObservabilityDriver(requestParameters.workspaceId, requestParameters.langfuseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Power Bi Observability Driver
         * @param {ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePowerBiObservabilityDriver(requestParameters: ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse> {
            return localVarFp.updatePowerBiObservabilityDriver(requestParameters.workspaceId, requestParameters.powerBiRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate Push Dataset Table
         * @param {ObservabilityDriverApiValidatePushDatasetTableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePushDatasetTable(requestParameters: ObservabilityDriverApiValidatePushDatasetTableRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiTableValidateResponse> {
            return localVarFp.validatePushDatasetTable(requestParameters.workspaceId, requestParameters.powerBiRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObservabilityDriverApi - interface
 * @export
 * @interface ObservabilityDriverApi
 */
export interface ObservabilityDriverApiInterface {
    /**
     * 
     * @summary Activate Langfuse Observability Driver
     * @param {ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    activateLangfuseObservabilityDriver(requestParameters: ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse>;

    /**
     * 
     * @summary Activate Power Bi Observability Driver
     * @param {ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    activatePowerBiObservabilityDriver(requestParameters: ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse>;

    /**
     * 
     * @summary Create Power Bi Push Dataset
     * @param {ObservabilityDriverApiCreatePowerBiPushDatasetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    createPowerBiPushDataset(requestParameters: ObservabilityDriverApiCreatePowerBiPushDatasetRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiPushDatasetResponse>;

    /**
     * 
     * @summary Delete Observability Driver
     * @param {ObservabilityDriverApiDeleteObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    deleteObservabilityDriver(requestParameters: ObservabilityDriverApiDeleteObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<DriverSuccessResponse>;

    /**
     * 
     * @summary Get Observability Driver
     * @param {ObservabilityDriverApiGetObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    getObservabilityDriver(requestParameters: ObservabilityDriverApiGetObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse>;

    /**
     * 
     * @summary Get Observability Driver Workspace
     * @param {ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    getObservabilityDriverWorkspace(requestParameters: ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ObservabilityDriverResponse>>;

    /**
     * 
     * @summary List Power Bi Datasets
     * @param {ObservabilityDriverApiListPowerBiDatasetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    listPowerBiDatasets(requestParameters: ObservabilityDriverApiListPowerBiDatasetsRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiDatasetsResponse>;

    /**
     * 
     * @summary List Power Bi Tables
     * @param {ObservabilityDriverApiListPowerBiTablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    listPowerBiTables(requestParameters: ObservabilityDriverApiListPowerBiTablesRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiTablesResponse>;

    /**
     * 
     * @summary List Power Bi Workspaces
     * @param {ObservabilityDriverApiListPowerBiWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    listPowerBiWorkspaces(requestParameters: ObservabilityDriverApiListPowerBiWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiWorkspacesResponse>;

    /**
     * 
     * @summary Update Langfuse Observability Driver
     * @param {ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    updateLangfuseObservabilityDriver(requestParameters: ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse>;

    /**
     * 
     * @summary Update Power Bi Observability Driver
     * @param {ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    updatePowerBiObservabilityDriver(requestParameters: ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse>;

    /**
     * 
     * @summary Validate Push Dataset Table
     * @param {ObservabilityDriverApiValidatePushDatasetTableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    validatePushDatasetTable(requestParameters: ObservabilityDriverApiValidatePushDatasetTableRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiTableValidateResponse>;

}

/**
 * Request parameters for activateLangfuseObservabilityDriver operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest
 */
export interface ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiActivateLangfuseObservabilityDriver
     */
    readonly workspaceId: string

    /**
     * 
     * @type {LangfuseRequest}
     * @memberof ObservabilityDriverApiActivateLangfuseObservabilityDriver
     */
    readonly langfuseRequest: LangfuseRequest
}

/**
 * Request parameters for activatePowerBiObservabilityDriver operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest
 */
export interface ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiActivatePowerBiObservabilityDriver
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PowerBiRequest}
     * @memberof ObservabilityDriverApiActivatePowerBiObservabilityDriver
     */
    readonly powerBiRequest: PowerBiRequest
}

/**
 * Request parameters for createPowerBiPushDataset operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiCreatePowerBiPushDatasetRequest
 */
export interface ObservabilityDriverApiCreatePowerBiPushDatasetRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiCreatePowerBiPushDataset
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PowerBiPushDatasetRequest}
     * @memberof ObservabilityDriverApiCreatePowerBiPushDataset
     */
    readonly powerBiPushDatasetRequest: PowerBiPushDatasetRequest
}

/**
 * Request parameters for deleteObservabilityDriver operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiDeleteObservabilityDriverRequest
 */
export interface ObservabilityDriverApiDeleteObservabilityDriverRequest {
    /**
     * 
     * @type {DriverType}
     * @memberof ObservabilityDriverApiDeleteObservabilityDriver
     */
    readonly driverType: DriverType

    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiDeleteObservabilityDriver
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getObservabilityDriver operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiGetObservabilityDriverRequest
 */
export interface ObservabilityDriverApiGetObservabilityDriverRequest {
    /**
     * 
     * @type {DriverType}
     * @memberof ObservabilityDriverApiGetObservabilityDriver
     */
    readonly driverType: DriverType

    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiGetObservabilityDriver
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getObservabilityDriverWorkspace operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest
 */
export interface ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiGetObservabilityDriverWorkspace
     */
    readonly workspaceId: string
}

/**
 * Request parameters for listPowerBiDatasets operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiListPowerBiDatasetsRequest
 */
export interface ObservabilityDriverApiListPowerBiDatasetsRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiListPowerBiDatasets
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PowerBiDatasetRequest}
     * @memberof ObservabilityDriverApiListPowerBiDatasets
     */
    readonly powerBiDatasetRequest: PowerBiDatasetRequest
}

/**
 * Request parameters for listPowerBiTables operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiListPowerBiTablesRequest
 */
export interface ObservabilityDriverApiListPowerBiTablesRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiListPowerBiTables
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PowerBiTableRequest}
     * @memberof ObservabilityDriverApiListPowerBiTables
     */
    readonly powerBiTableRequest: PowerBiTableRequest
}

/**
 * Request parameters for listPowerBiWorkspaces operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiListPowerBiWorkspacesRequest
 */
export interface ObservabilityDriverApiListPowerBiWorkspacesRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiListPowerBiWorkspaces
     */
    readonly workspaceId: string
}

/**
 * Request parameters for updateLangfuseObservabilityDriver operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest
 */
export interface ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiUpdateLangfuseObservabilityDriver
     */
    readonly workspaceId: string

    /**
     * 
     * @type {LangfuseRequest}
     * @memberof ObservabilityDriverApiUpdateLangfuseObservabilityDriver
     */
    readonly langfuseRequest: LangfuseRequest
}

/**
 * Request parameters for updatePowerBiObservabilityDriver operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest
 */
export interface ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiUpdatePowerBiObservabilityDriver
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PowerBiRequest}
     * @memberof ObservabilityDriverApiUpdatePowerBiObservabilityDriver
     */
    readonly powerBiRequest: PowerBiRequest
}

/**
 * Request parameters for validatePushDatasetTable operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiValidatePushDatasetTableRequest
 */
export interface ObservabilityDriverApiValidatePushDatasetTableRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiValidatePushDatasetTable
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PowerBiRequest}
     * @memberof ObservabilityDriverApiValidatePushDatasetTable
     */
    readonly powerBiRequest: PowerBiRequest
}

/**
 * ObservabilityDriverApi - object-oriented interface
 * @export
 * @class ObservabilityDriverApi
 * @extends {BaseAPI}
 */
export class ObservabilityDriverApi extends BaseAPI implements ObservabilityDriverApiInterface {
    /**
     * 
     * @summary Activate Langfuse Observability Driver
     * @param {ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public activateLangfuseObservabilityDriver(requestParameters: ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).activateLangfuseObservabilityDriver(requestParameters.workspaceId, requestParameters.langfuseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Activate Power Bi Observability Driver
     * @param {ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public activatePowerBiObservabilityDriver(requestParameters: ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).activatePowerBiObservabilityDriver(requestParameters.workspaceId, requestParameters.powerBiRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Power Bi Push Dataset
     * @param {ObservabilityDriverApiCreatePowerBiPushDatasetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public createPowerBiPushDataset(requestParameters: ObservabilityDriverApiCreatePowerBiPushDatasetRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).createPowerBiPushDataset(requestParameters.workspaceId, requestParameters.powerBiPushDatasetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Observability Driver
     * @param {ObservabilityDriverApiDeleteObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public deleteObservabilityDriver(requestParameters: ObservabilityDriverApiDeleteObservabilityDriverRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).deleteObservabilityDriver(requestParameters.driverType, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Observability Driver
     * @param {ObservabilityDriverApiGetObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public getObservabilityDriver(requestParameters: ObservabilityDriverApiGetObservabilityDriverRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).getObservabilityDriver(requestParameters.driverType, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Observability Driver Workspace
     * @param {ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public getObservabilityDriverWorkspace(requestParameters: ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).getObservabilityDriverWorkspace(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Power Bi Datasets
     * @param {ObservabilityDriverApiListPowerBiDatasetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public listPowerBiDatasets(requestParameters: ObservabilityDriverApiListPowerBiDatasetsRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).listPowerBiDatasets(requestParameters.workspaceId, requestParameters.powerBiDatasetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Power Bi Tables
     * @param {ObservabilityDriverApiListPowerBiTablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public listPowerBiTables(requestParameters: ObservabilityDriverApiListPowerBiTablesRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).listPowerBiTables(requestParameters.workspaceId, requestParameters.powerBiTableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Power Bi Workspaces
     * @param {ObservabilityDriverApiListPowerBiWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public listPowerBiWorkspaces(requestParameters: ObservabilityDriverApiListPowerBiWorkspacesRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).listPowerBiWorkspaces(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Langfuse Observability Driver
     * @param {ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public updateLangfuseObservabilityDriver(requestParameters: ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).updateLangfuseObservabilityDriver(requestParameters.workspaceId, requestParameters.langfuseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Power Bi Observability Driver
     * @param {ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public updatePowerBiObservabilityDriver(requestParameters: ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).updatePowerBiObservabilityDriver(requestParameters.workspaceId, requestParameters.powerBiRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate Push Dataset Table
     * @param {ObservabilityDriverApiValidatePushDatasetTableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public validatePushDatasetTable(requestParameters: ObservabilityDriverApiValidatePushDatasetTableRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).validatePushDatasetTable(requestParameters.workspaceId, requestParameters.powerBiRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PhotoAIApi - axios parameter creator
 * @export
 */
export const PhotoAIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Explore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explore: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/photo_ai/public/explore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Effects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffects: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/photo_ai/public/effects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStyles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/photo_ai/public/styles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/photo_ai/public/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhotoAIApi - functional programming interface
 * @export
 */
export const PhotoAIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PhotoAIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Explore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explore(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommunityImageGenerationsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explore(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhotoAIApi.explore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Effects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEffects(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PhotoAIEffectResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEffects(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhotoAIApi.getEffects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStyles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PhotoAIStyleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStyles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhotoAIApi.getStyles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PhotoAITemplateResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhotoAIApi.getTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PhotoAIApi - factory interface
 * @export
 */
export const PhotoAIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PhotoAIApiFp(configuration)
    return {
        /**
         * 
         * @summary Explore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explore(options?: RawAxiosRequestConfig): AxiosPromise<Array<CommunityImageGenerationsResponse>> {
            return localVarFp.explore(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Effects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffects(options?: RawAxiosRequestConfig): AxiosPromise<Array<PhotoAIEffectResponse>> {
            return localVarFp.getEffects(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStyles(options?: RawAxiosRequestConfig): AxiosPromise<Array<PhotoAIStyleResponse>> {
            return localVarFp.getStyles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(options?: RawAxiosRequestConfig): AxiosPromise<Array<PhotoAITemplateResponse>> {
            return localVarFp.getTemplates(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PhotoAIApi - interface
 * @export
 * @interface PhotoAIApi
 */
export interface PhotoAIApiInterface {
    /**
     * 
     * @summary Explore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApiInterface
     */
    explore(options?: RawAxiosRequestConfig): AxiosPromise<Array<CommunityImageGenerationsResponse>>;

    /**
     * 
     * @summary Get Effects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApiInterface
     */
    getEffects(options?: RawAxiosRequestConfig): AxiosPromise<Array<PhotoAIEffectResponse>>;

    /**
     * 
     * @summary Get Styles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApiInterface
     */
    getStyles(options?: RawAxiosRequestConfig): AxiosPromise<Array<PhotoAIStyleResponse>>;

    /**
     * 
     * @summary Get Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApiInterface
     */
    getTemplates(options?: RawAxiosRequestConfig): AxiosPromise<Array<PhotoAITemplateResponse>>;

}

/**
 * PhotoAIApi - object-oriented interface
 * @export
 * @class PhotoAIApi
 * @extends {BaseAPI}
 */
export class PhotoAIApi extends BaseAPI implements PhotoAIApiInterface {
    /**
     * 
     * @summary Explore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApi
     */
    public explore(options?: RawAxiosRequestConfig) {
        return PhotoAIApiFp(this.configuration).explore(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Effects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApi
     */
    public getEffects(options?: RawAxiosRequestConfig) {
        return PhotoAIApiFp(this.configuration).getEffects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Styles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApi
     */
    public getStyles(options?: RawAxiosRequestConfig) {
        return PhotoAIApiFp(this.configuration).getStyles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApi
     */
    public getTemplates(options?: RawAxiosRequestConfig) {
        return PhotoAIApiFp(this.configuration).getTemplates(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptsApi - axios parameter creator
 * @export
 */
export const PromptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Prompt
         * @param {string} workspaceId 
         * @param {PromptCreateRequest} promptCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrompt: async (workspaceId: string, promptCreateRequest: PromptCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createPrompt', 'workspaceId', workspaceId)
            // verify required parameter 'promptCreateRequest' is not null or undefined
            assertParamExists('createPrompt', 'promptCreateRequest', promptCreateRequest)
            const localVarPath = `/v2/prompts/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Prompt Category
         * @param {string} workspaceId 
         * @param {PromptCategoryCreateRequest} promptCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPromptCategory: async (workspaceId: string, promptCategoryCreateRequest: PromptCategoryCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createPromptCategory', 'workspaceId', workspaceId)
            // verify required parameter 'promptCategoryCreateRequest' is not null or undefined
            assertParamExists('createPromptCategory', 'promptCategoryCreateRequest', promptCategoryCreateRequest)
            const localVarPath = `/v2/prompts/categories/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptCategoryCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Prompt
         * @param {string} promptId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrompt: async (promptId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('deletePrompt', 'promptId', promptId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deletePrompt', 'workspaceId', workspaceId)
            const localVarPath = `/v2/prompts/{prompt_id}`
                .replace(`{${"prompt_id"}}`, encodeURIComponent(String(promptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Prompt Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePromptCategory: async (catId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('deletePromptCategory', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deletePromptCategory', 'workspaceId', workspaceId)
            const localVarPath = `/v2/prompts/categories/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optimize Prompt
         * @param {string} workspaceId 
         * @param {PromptOptimizerRequest} promptOptimizerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optimizePrompt: async (workspaceId: string, promptOptimizerRequest: PromptOptimizerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('optimizePrompt', 'workspaceId', workspaceId)
            // verify required parameter 'promptOptimizerRequest' is not null or undefined
            assertParamExists('optimizePrompt', 'promptOptimizerRequest', promptOptimizerRequest)
            const localVarPath = `/v2/prompts/optimize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptOptimizerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Prompt Categories
         * @param {string} workspaceId 
         * @param {PromptCategorySearchRequest} promptCategorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPromptCategories: async (workspaceId: string, promptCategorySearchRequest: PromptCategorySearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchPromptCategories', 'workspaceId', workspaceId)
            // verify required parameter 'promptCategorySearchRequest' is not null or undefined
            assertParamExists('searchPromptCategories', 'promptCategorySearchRequest', promptCategorySearchRequest)
            const localVarPath = `/v2/prompts/categories/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptCategorySearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Prompts
         * @param {string} workspaceId 
         * @param {PromptSearchRequest} promptSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPrompts: async (workspaceId: string, promptSearchRequest: PromptSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchPrompts', 'workspaceId', workspaceId)
            // verify required parameter 'promptSearchRequest' is not null or undefined
            assertParamExists('searchPrompts', 'promptSearchRequest', promptSearchRequest)
            const localVarPath = `/v2/prompts/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Prompt
         * @param {string} promptId 
         * @param {string} workspaceId 
         * @param {PromptUpdateRequest} promptUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrompt: async (promptId: string, workspaceId: string, promptUpdateRequest: PromptUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('updatePrompt', 'promptId', promptId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updatePrompt', 'workspaceId', workspaceId)
            // verify required parameter 'promptUpdateRequest' is not null or undefined
            assertParamExists('updatePrompt', 'promptUpdateRequest', promptUpdateRequest)
            const localVarPath = `/v2/prompts/{prompt_id}`
                .replace(`{${"prompt_id"}}`, encodeURIComponent(String(promptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Prompt Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {PromptCategoryUpdateRequest} promptCategoryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePromptCategory: async (catId: string, workspaceId: string, promptCategoryUpdateRequest: PromptCategoryUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('updatePromptCategory', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updatePromptCategory', 'workspaceId', workspaceId)
            // verify required parameter 'promptCategoryUpdateRequest' is not null or undefined
            assertParamExists('updatePromptCategory', 'promptCategoryUpdateRequest', promptCategoryUpdateRequest)
            const localVarPath = `/v2/prompts/categories/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptCategoryUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptsApi - functional programming interface
 * @export
 */
export const PromptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Prompt
         * @param {string} workspaceId 
         * @param {PromptCreateRequest} promptCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPrompt(workspaceId: string, promptCreateRequest: PromptCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPrompt(workspaceId, promptCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.createPrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Prompt Category
         * @param {string} workspaceId 
         * @param {PromptCategoryCreateRequest} promptCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPromptCategory(workspaceId: string, promptCategoryCreateRequest: PromptCategoryCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPromptCategory(workspaceId, promptCategoryCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.createPromptCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Prompt
         * @param {string} promptId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePrompt(promptId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePrompt(promptId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.deletePrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Prompt Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePromptCategory(catId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePromptCategory(catId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.deletePromptCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optimize Prompt
         * @param {string} workspaceId 
         * @param {PromptOptimizerRequest} promptOptimizerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optimizePrompt(workspaceId: string, promptOptimizerRequest: PromptOptimizerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OptimizedPromptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optimizePrompt(workspaceId, promptOptimizerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.optimizePrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Prompt Categories
         * @param {string} workspaceId 
         * @param {PromptCategorySearchRequest} promptCategorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPromptCategories(workspaceId: string, promptCategorySearchRequest: PromptCategorySearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PromptCategoryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPromptCategories(workspaceId, promptCategorySearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.searchPromptCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Prompts
         * @param {string} workspaceId 
         * @param {PromptSearchRequest} promptSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPrompts(workspaceId: string, promptSearchRequest: PromptSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PromptResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPrompts(workspaceId, promptSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.searchPrompts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Prompt
         * @param {string} promptId 
         * @param {string} workspaceId 
         * @param {PromptUpdateRequest} promptUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePrompt(promptId: string, workspaceId: string, promptUpdateRequest: PromptUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePrompt(promptId, workspaceId, promptUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.updatePrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Prompt Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {PromptCategoryUpdateRequest} promptCategoryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePromptCategory(catId: string, workspaceId: string, promptCategoryUpdateRequest: PromptCategoryUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePromptCategory(catId, workspaceId, promptCategoryUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.updatePromptCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptsApi - factory interface
 * @export
 */
export const PromptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Prompt
         * @param {PromptsApiCreatePromptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrompt(requestParameters: PromptsApiCreatePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse> {
            return localVarFp.createPrompt(requestParameters.workspaceId, requestParameters.promptCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Prompt Category
         * @param {PromptsApiCreatePromptCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPromptCategory(requestParameters: PromptsApiCreatePromptCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptCategoryResponse> {
            return localVarFp.createPromptCategory(requestParameters.workspaceId, requestParameters.promptCategoryCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Prompt
         * @param {PromptsApiDeletePromptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrompt(requestParameters: PromptsApiDeletePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deletePrompt(requestParameters.promptId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Prompt Category
         * @param {PromptsApiDeletePromptCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePromptCategory(requestParameters: PromptsApiDeletePromptCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deletePromptCategory(requestParameters.catId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optimize Prompt
         * @param {PromptsApiOptimizePromptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optimizePrompt(requestParameters: PromptsApiOptimizePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<OptimizedPromptResponse> {
            return localVarFp.optimizePrompt(requestParameters.workspaceId, requestParameters.promptOptimizerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Prompt Categories
         * @param {PromptsApiSearchPromptCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPromptCategories(requestParameters: PromptsApiSearchPromptCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<PromptCategoryResponse>> {
            return localVarFp.searchPromptCategories(requestParameters.workspaceId, requestParameters.promptCategorySearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Prompts
         * @param {PromptsApiSearchPromptsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPrompts(requestParameters: PromptsApiSearchPromptsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<PromptResponse>> {
            return localVarFp.searchPrompts(requestParameters.workspaceId, requestParameters.promptSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Prompt
         * @param {PromptsApiUpdatePromptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrompt(requestParameters: PromptsApiUpdatePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse> {
            return localVarFp.updatePrompt(requestParameters.promptId, requestParameters.workspaceId, requestParameters.promptUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Prompt Category
         * @param {PromptsApiUpdatePromptCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePromptCategory(requestParameters: PromptsApiUpdatePromptCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptCategoryResponse> {
            return localVarFp.updatePromptCategory(requestParameters.catId, requestParameters.workspaceId, requestParameters.promptCategoryUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptsApi - interface
 * @export
 * @interface PromptsApi
 */
export interface PromptsApiInterface {
    /**
     * 
     * @summary Create Prompt
     * @param {PromptsApiCreatePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    createPrompt(requestParameters: PromptsApiCreatePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse>;

    /**
     * 
     * @summary Create Prompt Category
     * @param {PromptsApiCreatePromptCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    createPromptCategory(requestParameters: PromptsApiCreatePromptCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptCategoryResponse>;

    /**
     * 
     * @summary Delete Prompt
     * @param {PromptsApiDeletePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    deletePrompt(requestParameters: PromptsApiDeletePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Delete Prompt Category
     * @param {PromptsApiDeletePromptCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    deletePromptCategory(requestParameters: PromptsApiDeletePromptCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Optimize Prompt
     * @param {PromptsApiOptimizePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    optimizePrompt(requestParameters: PromptsApiOptimizePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<OptimizedPromptResponse>;

    /**
     * 
     * @summary Search Prompt Categories
     * @param {PromptsApiSearchPromptCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    searchPromptCategories(requestParameters: PromptsApiSearchPromptCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<PromptCategoryResponse>>;

    /**
     * 
     * @summary Search Prompts
     * @param {PromptsApiSearchPromptsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    searchPrompts(requestParameters: PromptsApiSearchPromptsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<PromptResponse>>;

    /**
     * 
     * @summary Update Prompt
     * @param {PromptsApiUpdatePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    updatePrompt(requestParameters: PromptsApiUpdatePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse>;

    /**
     * 
     * @summary Update Prompt Category
     * @param {PromptsApiUpdatePromptCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    updatePromptCategory(requestParameters: PromptsApiUpdatePromptCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptCategoryResponse>;

}

/**
 * Request parameters for createPrompt operation in PromptsApi.
 * @export
 * @interface PromptsApiCreatePromptRequest
 */
export interface PromptsApiCreatePromptRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiCreatePrompt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PromptCreateRequest}
     * @memberof PromptsApiCreatePrompt
     */
    readonly promptCreateRequest: PromptCreateRequest
}

/**
 * Request parameters for createPromptCategory operation in PromptsApi.
 * @export
 * @interface PromptsApiCreatePromptCategoryRequest
 */
export interface PromptsApiCreatePromptCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiCreatePromptCategory
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PromptCategoryCreateRequest}
     * @memberof PromptsApiCreatePromptCategory
     */
    readonly promptCategoryCreateRequest: PromptCategoryCreateRequest
}

/**
 * Request parameters for deletePrompt operation in PromptsApi.
 * @export
 * @interface PromptsApiDeletePromptRequest
 */
export interface PromptsApiDeletePromptRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiDeletePrompt
     */
    readonly promptId: string

    /**
     * 
     * @type {string}
     * @memberof PromptsApiDeletePrompt
     */
    readonly workspaceId: string
}

/**
 * Request parameters for deletePromptCategory operation in PromptsApi.
 * @export
 * @interface PromptsApiDeletePromptCategoryRequest
 */
export interface PromptsApiDeletePromptCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiDeletePromptCategory
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof PromptsApiDeletePromptCategory
     */
    readonly workspaceId: string
}

/**
 * Request parameters for optimizePrompt operation in PromptsApi.
 * @export
 * @interface PromptsApiOptimizePromptRequest
 */
export interface PromptsApiOptimizePromptRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiOptimizePrompt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PromptOptimizerRequest}
     * @memberof PromptsApiOptimizePrompt
     */
    readonly promptOptimizerRequest: PromptOptimizerRequest
}

/**
 * Request parameters for searchPromptCategories operation in PromptsApi.
 * @export
 * @interface PromptsApiSearchPromptCategoriesRequest
 */
export interface PromptsApiSearchPromptCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiSearchPromptCategories
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PromptCategorySearchRequest}
     * @memberof PromptsApiSearchPromptCategories
     */
    readonly promptCategorySearchRequest: PromptCategorySearchRequest
}

/**
 * Request parameters for searchPrompts operation in PromptsApi.
 * @export
 * @interface PromptsApiSearchPromptsRequest
 */
export interface PromptsApiSearchPromptsRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiSearchPrompts
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PromptSearchRequest}
     * @memberof PromptsApiSearchPrompts
     */
    readonly promptSearchRequest: PromptSearchRequest
}

/**
 * Request parameters for updatePrompt operation in PromptsApi.
 * @export
 * @interface PromptsApiUpdatePromptRequest
 */
export interface PromptsApiUpdatePromptRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiUpdatePrompt
     */
    readonly promptId: string

    /**
     * 
     * @type {string}
     * @memberof PromptsApiUpdatePrompt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PromptUpdateRequest}
     * @memberof PromptsApiUpdatePrompt
     */
    readonly promptUpdateRequest: PromptUpdateRequest
}

/**
 * Request parameters for updatePromptCategory operation in PromptsApi.
 * @export
 * @interface PromptsApiUpdatePromptCategoryRequest
 */
export interface PromptsApiUpdatePromptCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiUpdatePromptCategory
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof PromptsApiUpdatePromptCategory
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PromptCategoryUpdateRequest}
     * @memberof PromptsApiUpdatePromptCategory
     */
    readonly promptCategoryUpdateRequest: PromptCategoryUpdateRequest
}

/**
 * PromptsApi - object-oriented interface
 * @export
 * @class PromptsApi
 * @extends {BaseAPI}
 */
export class PromptsApi extends BaseAPI implements PromptsApiInterface {
    /**
     * 
     * @summary Create Prompt
     * @param {PromptsApiCreatePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public createPrompt(requestParameters: PromptsApiCreatePromptRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).createPrompt(requestParameters.workspaceId, requestParameters.promptCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Prompt Category
     * @param {PromptsApiCreatePromptCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public createPromptCategory(requestParameters: PromptsApiCreatePromptCategoryRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).createPromptCategory(requestParameters.workspaceId, requestParameters.promptCategoryCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Prompt
     * @param {PromptsApiDeletePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public deletePrompt(requestParameters: PromptsApiDeletePromptRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).deletePrompt(requestParameters.promptId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Prompt Category
     * @param {PromptsApiDeletePromptCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public deletePromptCategory(requestParameters: PromptsApiDeletePromptCategoryRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).deletePromptCategory(requestParameters.catId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optimize Prompt
     * @param {PromptsApiOptimizePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public optimizePrompt(requestParameters: PromptsApiOptimizePromptRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).optimizePrompt(requestParameters.workspaceId, requestParameters.promptOptimizerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Prompt Categories
     * @param {PromptsApiSearchPromptCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public searchPromptCategories(requestParameters: PromptsApiSearchPromptCategoriesRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).searchPromptCategories(requestParameters.workspaceId, requestParameters.promptCategorySearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Prompts
     * @param {PromptsApiSearchPromptsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public searchPrompts(requestParameters: PromptsApiSearchPromptsRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).searchPrompts(requestParameters.workspaceId, requestParameters.promptSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Prompt
     * @param {PromptsApiUpdatePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public updatePrompt(requestParameters: PromptsApiUpdatePromptRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).updatePrompt(requestParameters.promptId, requestParameters.workspaceId, requestParameters.promptUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Prompt Category
     * @param {PromptsApiUpdatePromptCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public updatePromptCategory(requestParameters: PromptsApiUpdatePromptCategoryRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).updatePromptCategory(requestParameters.catId, requestParameters.workspaceId, requestParameters.promptCategoryUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SERPApi - axios parameter creator
 * @export
 */
export const SERPApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Search Cluster Query
         * @param {string} workspaceId 
         * @param {SerpClusterGroupSearchRequest} serpClusterGroupSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchClusterQuery: async (workspaceId: string, serpClusterGroupSearchRequest: SerpClusterGroupSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchClusterQuery', 'workspaceId', workspaceId)
            // verify required parameter 'serpClusterGroupSearchRequest' is not null or undefined
            assertParamExists('searchClusterQuery', 'serpClusterGroupSearchRequest', serpClusterGroupSearchRequest)
            const localVarPath = `/v2/serp/clusters/keywords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpClusterGroupSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Add Queries
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {SerpClusterAddQueryRequests} serpClusterAddQueryRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterAddQueries: async (customerId: string, campaignId: string, groupId: string, workspaceId: string, serpClusterAddQueryRequests: SerpClusterAddQueryRequests, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('serpClusterAddQueries', 'customerId', customerId)
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('serpClusterAddQueries', 'campaignId', campaignId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('serpClusterAddQueries', 'groupId', groupId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterAddQueries', 'workspaceId', workspaceId)
            // verify required parameter 'serpClusterAddQueryRequests' is not null or undefined
            assertParamExists('serpClusterAddQueries', 'serpClusterAddQueryRequests', serpClusterAddQueryRequests)
            const localVarPath = `/v2/serp/clusters/{customer_id}/{campaign_id}/{group_id}/add_keywords`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpClusterAddQueryRequests, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Delete Campaign
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteCampaign: async (customerId: string, campaignId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('serpClusterDeleteCampaign', 'customerId', customerId)
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('serpClusterDeleteCampaign', 'campaignId', campaignId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterDeleteCampaign', 'workspaceId', workspaceId)
            const localVarPath = `/v2/serp/clusters/{customer_id}/{campaign_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Delete Customer
         * @param {string} customerId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteCustomer: async (customerId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('serpClusterDeleteCustomer', 'customerId', customerId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterDeleteCustomer', 'workspaceId', workspaceId)
            const localVarPath = `/v2/serp/clusters/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Delete Group
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteGroup: async (customerId: string, campaignId: string, groupId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('serpClusterDeleteGroup', 'customerId', customerId)
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('serpClusterDeleteGroup', 'campaignId', campaignId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('serpClusterDeleteGroup', 'groupId', groupId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterDeleteGroup', 'workspaceId', workspaceId)
            const localVarPath = `/v2/serp/clusters/{customer_id}/{campaign_id}/{group_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Delete Group Queries
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {SerpQueryRequest} serpQueryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteGroupQueries: async (customerId: string, campaignId: string, groupId: string, workspaceId: string, serpQueryRequest: SerpQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('serpClusterDeleteGroupQueries', 'customerId', customerId)
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('serpClusterDeleteGroupQueries', 'campaignId', campaignId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('serpClusterDeleteGroupQueries', 'groupId', groupId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterDeleteGroupQueries', 'workspaceId', workspaceId)
            // verify required parameter 'serpQueryRequest' is not null or undefined
            assertParamExists('serpClusterDeleteGroupQueries', 'serpQueryRequest', serpQueryRequest)
            const localVarPath = `/v2/serp/clusters/{customer_id}/{campaign_id}/{group_id}/delete_queries`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Get Graph Nodes
         * @param {string} workspaceId 
         * @param {SerpClusterGroupIntersectionsRequest} serpClusterGroupIntersectionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterGetGraphNodes: async (workspaceId: string, serpClusterGroupIntersectionsRequest: SerpClusterGroupIntersectionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterGetGraphNodes', 'workspaceId', workspaceId)
            // verify required parameter 'serpClusterGroupIntersectionsRequest' is not null or undefined
            assertParamExists('serpClusterGetGraphNodes', 'serpClusterGroupIntersectionsRequest', serpClusterGroupIntersectionsRequest)
            const localVarPath = `/v2/serp/clusters/graph_nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpClusterGroupIntersectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Get Matching Groups To Query
         * @param {string} workspaceId 
         * @param {SerpClusterBestGroupsRequest} serpClusterBestGroupsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterGetMatchingGroupsToQuery: async (workspaceId: string, serpClusterBestGroupsRequest: SerpClusterBestGroupsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterGetMatchingGroupsToQuery', 'workspaceId', workspaceId)
            // verify required parameter 'serpClusterBestGroupsRequest' is not null or undefined
            assertParamExists('serpClusterGetMatchingGroupsToQuery', 'serpClusterBestGroupsRequest', serpClusterBestGroupsRequest)
            const localVarPath = `/v2/serp/clusters/recommended_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpClusterBestGroupsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Get Related Keywords To Query
         * @param {string} workspaceId 
         * @param {SerpClusterKeywordIntersectionsRequest} serpClusterKeywordIntersectionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterGetRelatedKeywordsToQuery: async (workspaceId: string, serpClusterKeywordIntersectionsRequest: SerpClusterKeywordIntersectionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterGetRelatedKeywordsToQuery', 'workspaceId', workspaceId)
            // verify required parameter 'serpClusterKeywordIntersectionsRequest' is not null or undefined
            assertParamExists('serpClusterGetRelatedKeywordsToQuery', 'serpClusterKeywordIntersectionsRequest', serpClusterKeywordIntersectionsRequest)
            const localVarPath = `/v2/serp/clusters/related_keywords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpClusterKeywordIntersectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Split To Sub Clusters
         * @param {string} workspaceId 
         * @param {SerpClusterGroupSubClustersRequest} serpClusterGroupSubClustersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterSplitToSubClusters: async (workspaceId: string, serpClusterGroupSubClustersRequest: SerpClusterGroupSubClustersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterSplitToSubClusters', 'workspaceId', workspaceId)
            // verify required parameter 'serpClusterGroupSubClustersRequest' is not null or undefined
            assertParamExists('serpClusterSplitToSubClusters', 'serpClusterGroupSubClustersRequest', serpClusterGroupSubClustersRequest)
            const localVarPath = `/v2/serp/clusters/split_sub_clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpClusterGroupSubClustersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Search
         * @param {string} workspaceId 
         * @param {SerpSearchRequests} serpSearchRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpSearch: async (workspaceId: string, serpSearchRequests: SerpSearchRequests, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpSearch', 'workspaceId', workspaceId)
            // verify required parameter 'serpSearchRequests' is not null or undefined
            assertParamExists('serpSearch', 'serpSearchRequests', serpSearchRequests)
            const localVarPath = `/v2/serp/serp/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpSearchRequests, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Volumes
         * @param {string} workspaceId 
         * @param {SerpVolumeRequest} serpVolumeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpVolumes: async (workspaceId: string, serpVolumeRequest: SerpVolumeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpVolumes', 'workspaceId', workspaceId)
            // verify required parameter 'serpVolumeRequest' is not null or undefined
            assertParamExists('serpVolumes', 'serpVolumeRequest', serpVolumeRequest)
            const localVarPath = `/v2/serp/serp/volumes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpVolumeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Volumes Pingback
         * @param {string} id 
         * @param {string | null} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpVolumesPingback: async (id: string, tag: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serpVolumesPingback', 'id', id)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('serpVolumesPingback', 'tag', tag)
            const localVarPath = `/v2/serp/serp/volumes/pingback/{id}/{tag}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SERPApi - functional programming interface
 * @export
 */
export const SERPApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SERPApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Search Cluster Query
         * @param {string} workspaceId 
         * @param {SerpClusterGroupSearchRequest} serpClusterGroupSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchClusterQuery(workspaceId: string, serpClusterGroupSearchRequest: SerpClusterGroupSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SerpClusterKeywordResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchClusterQuery(workspaceId, serpClusterGroupSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.searchClusterQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Add Queries
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {SerpClusterAddQueryRequests} serpClusterAddQueryRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterAddQueries(customerId: string, campaignId: string, groupId: string, workspaceId: string, serpClusterAddQueryRequests: SerpClusterAddQueryRequests, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterAddQueries(customerId, campaignId, groupId, workspaceId, serpClusterAddQueryRequests, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterAddQueries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Delete Campaign
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterDeleteCampaign(customerId: string, campaignId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterDeleteCampaign(customerId, campaignId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterDeleteCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Delete Customer
         * @param {string} customerId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterDeleteCustomer(customerId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterDeleteCustomer(customerId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterDeleteCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Delete Group
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterDeleteGroup(customerId: string, campaignId: string, groupId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterDeleteGroup(customerId, campaignId, groupId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterDeleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Delete Group Queries
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {SerpQueryRequest} serpQueryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterDeleteGroupQueries(customerId: string, campaignId: string, groupId: string, workspaceId: string, serpQueryRequest: SerpQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterDeleteGroupQueries(customerId, campaignId, groupId, workspaceId, serpQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterDeleteGroupQueries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Get Graph Nodes
         * @param {string} workspaceId 
         * @param {SerpClusterGroupIntersectionsRequest} serpClusterGroupIntersectionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterGetGraphNodes(workspaceId: string, serpClusterGroupIntersectionsRequest: SerpClusterGroupIntersectionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SerpKeywordRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterGetGraphNodes(workspaceId, serpClusterGroupIntersectionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterGetGraphNodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Get Matching Groups To Query
         * @param {string} workspaceId 
         * @param {SerpClusterBestGroupsRequest} serpClusterBestGroupsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterGetMatchingGroupsToQuery(workspaceId: string, serpClusterBestGroupsRequest: SerpClusterBestGroupsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SerpGroupIntersection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterGetMatchingGroupsToQuery(workspaceId, serpClusterBestGroupsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterGetMatchingGroupsToQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Get Related Keywords To Query
         * @param {string} workspaceId 
         * @param {SerpClusterKeywordIntersectionsRequest} serpClusterKeywordIntersectionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterGetRelatedKeywordsToQuery(workspaceId: string, serpClusterKeywordIntersectionsRequest: SerpClusterKeywordIntersectionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SerpKeywordRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterGetRelatedKeywordsToQuery(workspaceId, serpClusterKeywordIntersectionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterGetRelatedKeywordsToQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Split To Sub Clusters
         * @param {string} workspaceId 
         * @param {SerpClusterGroupSubClustersRequest} serpClusterGroupSubClustersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterSplitToSubClusters(workspaceId: string, serpClusterGroupSubClustersRequest: SerpClusterGroupSubClustersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SerpSubclusterKeywordsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterSplitToSubClusters(workspaceId, serpClusterGroupSubClustersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterSplitToSubClusters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Search
         * @param {string} workspaceId 
         * @param {SerpSearchRequests} serpSearchRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpSearch(workspaceId: string, serpSearchRequests: SerpSearchRequests, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpSearch(workspaceId, serpSearchRequests, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Volumes
         * @param {string} workspaceId 
         * @param {SerpVolumeRequest} serpVolumeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpVolumes(workspaceId: string, serpVolumeRequest: SerpVolumeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpVolumes(workspaceId, serpVolumeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpVolumes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Volumes Pingback
         * @param {string} id 
         * @param {string | null} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpVolumesPingback(id: string, tag: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpVolumesPingback(id, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpVolumesPingback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SERPApi - factory interface
 * @export
 */
export const SERPApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SERPApiFp(configuration)
    return {
        /**
         * 
         * @summary Search Cluster Query
         * @param {SERPApiSearchClusterQueryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchClusterQuery(requestParameters: SERPApiSearchClusterQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpClusterKeywordResponse>> {
            return localVarFp.searchClusterQuery(requestParameters.workspaceId, requestParameters.serpClusterGroupSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Add Queries
         * @param {SERPApiSerpClusterAddQueriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterAddQueries(requestParameters: SERPApiSerpClusterAddQueriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.serpClusterAddQueries(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, requestParameters.serpClusterAddQueryRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Delete Campaign
         * @param {SERPApiSerpClusterDeleteCampaignRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteCampaign(requestParameters: SERPApiSerpClusterDeleteCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.serpClusterDeleteCampaign(requestParameters.customerId, requestParameters.campaignId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Delete Customer
         * @param {SERPApiSerpClusterDeleteCustomerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteCustomer(requestParameters: SERPApiSerpClusterDeleteCustomerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.serpClusterDeleteCustomer(requestParameters.customerId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Delete Group
         * @param {SERPApiSerpClusterDeleteGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteGroup(requestParameters: SERPApiSerpClusterDeleteGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.serpClusterDeleteGroup(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Delete Group Queries
         * @param {SERPApiSerpClusterDeleteGroupQueriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteGroupQueries(requestParameters: SERPApiSerpClusterDeleteGroupQueriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.serpClusterDeleteGroupQueries(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, requestParameters.serpQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Get Graph Nodes
         * @param {SERPApiSerpClusterGetGraphNodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterGetGraphNodes(requestParameters: SERPApiSerpClusterGetGraphNodesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpKeywordRelation>> {
            return localVarFp.serpClusterGetGraphNodes(requestParameters.workspaceId, requestParameters.serpClusterGroupIntersectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Get Matching Groups To Query
         * @param {SERPApiSerpClusterGetMatchingGroupsToQueryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterGetMatchingGroupsToQuery(requestParameters: SERPApiSerpClusterGetMatchingGroupsToQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpGroupIntersection>> {
            return localVarFp.serpClusterGetMatchingGroupsToQuery(requestParameters.workspaceId, requestParameters.serpClusterBestGroupsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Get Related Keywords To Query
         * @param {SERPApiSerpClusterGetRelatedKeywordsToQueryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterGetRelatedKeywordsToQuery(requestParameters: SERPApiSerpClusterGetRelatedKeywordsToQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpKeywordRelation>> {
            return localVarFp.serpClusterGetRelatedKeywordsToQuery(requestParameters.workspaceId, requestParameters.serpClusterKeywordIntersectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Split To Sub Clusters
         * @param {SERPApiSerpClusterSplitToSubClustersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterSplitToSubClusters(requestParameters: SERPApiSerpClusterSplitToSubClustersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpSubclusterKeywordsResponse>> {
            return localVarFp.serpClusterSplitToSubClusters(requestParameters.workspaceId, requestParameters.serpClusterGroupSubClustersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Search
         * @param {SERPApiSerpSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpSearch(requestParameters: SERPApiSerpSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskResponse>> {
            return localVarFp.serpSearch(requestParameters.workspaceId, requestParameters.serpSearchRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Volumes
         * @param {SERPApiSerpVolumesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpVolumes(requestParameters: SERPApiSerpVolumesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.serpVolumes(requestParameters.workspaceId, requestParameters.serpVolumeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Volumes Pingback
         * @param {SERPApiSerpVolumesPingbackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpVolumesPingback(requestParameters: SERPApiSerpVolumesPingbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.serpVolumesPingback(requestParameters.id, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SERPApi - interface
 * @export
 * @interface SERPApi
 */
export interface SERPApiInterface {
    /**
     * 
     * @summary Search Cluster Query
     * @param {SERPApiSearchClusterQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    searchClusterQuery(requestParameters: SERPApiSearchClusterQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpClusterKeywordResponse>>;

    /**
     * 
     * @summary Serp Cluster Add Queries
     * @param {SERPApiSerpClusterAddQueriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterAddQueries(requestParameters: SERPApiSerpClusterAddQueriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Serp Cluster Delete Campaign
     * @param {SERPApiSerpClusterDeleteCampaignRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterDeleteCampaign(requestParameters: SERPApiSerpClusterDeleteCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Serp Cluster Delete Customer
     * @param {SERPApiSerpClusterDeleteCustomerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterDeleteCustomer(requestParameters: SERPApiSerpClusterDeleteCustomerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Serp Cluster Delete Group
     * @param {SERPApiSerpClusterDeleteGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterDeleteGroup(requestParameters: SERPApiSerpClusterDeleteGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Serp Cluster Delete Group Queries
     * @param {SERPApiSerpClusterDeleteGroupQueriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterDeleteGroupQueries(requestParameters: SERPApiSerpClusterDeleteGroupQueriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Serp Cluster Get Graph Nodes
     * @param {SERPApiSerpClusterGetGraphNodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterGetGraphNodes(requestParameters: SERPApiSerpClusterGetGraphNodesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpKeywordRelation>>;

    /**
     * 
     * @summary Serp Cluster Get Matching Groups To Query
     * @param {SERPApiSerpClusterGetMatchingGroupsToQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterGetMatchingGroupsToQuery(requestParameters: SERPApiSerpClusterGetMatchingGroupsToQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpGroupIntersection>>;

    /**
     * 
     * @summary Serp Cluster Get Related Keywords To Query
     * @param {SERPApiSerpClusterGetRelatedKeywordsToQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterGetRelatedKeywordsToQuery(requestParameters: SERPApiSerpClusterGetRelatedKeywordsToQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpKeywordRelation>>;

    /**
     * 
     * @summary Serp Cluster Split To Sub Clusters
     * @param {SERPApiSerpClusterSplitToSubClustersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterSplitToSubClusters(requestParameters: SERPApiSerpClusterSplitToSubClustersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpSubclusterKeywordsResponse>>;

    /**
     * 
     * @summary Serp Search
     * @param {SERPApiSerpSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpSearch(requestParameters: SERPApiSerpSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskResponse>>;

    /**
     * 
     * @summary Serp Volumes
     * @param {SERPApiSerpVolumesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpVolumes(requestParameters: SERPApiSerpVolumesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

    /**
     * 
     * @summary Serp Volumes Pingback
     * @param {SERPApiSerpVolumesPingbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpVolumesPingback(requestParameters: SERPApiSerpVolumesPingbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

}

/**
 * Request parameters for searchClusterQuery operation in SERPApi.
 * @export
 * @interface SERPApiSearchClusterQueryRequest
 */
export interface SERPApiSearchClusterQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSearchClusterQuery
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpClusterGroupSearchRequest}
     * @memberof SERPApiSearchClusterQuery
     */
    readonly serpClusterGroupSearchRequest: SerpClusterGroupSearchRequest
}

/**
 * Request parameters for serpClusterAddQueries operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterAddQueriesRequest
 */
export interface SERPApiSerpClusterAddQueriesRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterAddQueries
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterAddQueries
     */
    readonly campaignId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterAddQueries
     */
    readonly groupId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterAddQueries
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpClusterAddQueryRequests}
     * @memberof SERPApiSerpClusterAddQueries
     */
    readonly serpClusterAddQueryRequests: SerpClusterAddQueryRequests
}

/**
 * Request parameters for serpClusterDeleteCampaign operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterDeleteCampaignRequest
 */
export interface SERPApiSerpClusterDeleteCampaignRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteCampaign
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteCampaign
     */
    readonly campaignId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteCampaign
     */
    readonly workspaceId: string
}

/**
 * Request parameters for serpClusterDeleteCustomer operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterDeleteCustomerRequest
 */
export interface SERPApiSerpClusterDeleteCustomerRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteCustomer
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteCustomer
     */
    readonly workspaceId: string
}

/**
 * Request parameters for serpClusterDeleteGroup operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterDeleteGroupRequest
 */
export interface SERPApiSerpClusterDeleteGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroup
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroup
     */
    readonly campaignId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroup
     */
    readonly groupId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroup
     */
    readonly workspaceId: string
}

/**
 * Request parameters for serpClusterDeleteGroupQueries operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterDeleteGroupQueriesRequest
 */
export interface SERPApiSerpClusterDeleteGroupQueriesRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroupQueries
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroupQueries
     */
    readonly campaignId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroupQueries
     */
    readonly groupId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroupQueries
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpQueryRequest}
     * @memberof SERPApiSerpClusterDeleteGroupQueries
     */
    readonly serpQueryRequest: SerpQueryRequest
}

/**
 * Request parameters for serpClusterGetGraphNodes operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterGetGraphNodesRequest
 */
export interface SERPApiSerpClusterGetGraphNodesRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterGetGraphNodes
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpClusterGroupIntersectionsRequest}
     * @memberof SERPApiSerpClusterGetGraphNodes
     */
    readonly serpClusterGroupIntersectionsRequest: SerpClusterGroupIntersectionsRequest
}

/**
 * Request parameters for serpClusterGetMatchingGroupsToQuery operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterGetMatchingGroupsToQueryRequest
 */
export interface SERPApiSerpClusterGetMatchingGroupsToQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterGetMatchingGroupsToQuery
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpClusterBestGroupsRequest}
     * @memberof SERPApiSerpClusterGetMatchingGroupsToQuery
     */
    readonly serpClusterBestGroupsRequest: SerpClusterBestGroupsRequest
}

/**
 * Request parameters for serpClusterGetRelatedKeywordsToQuery operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterGetRelatedKeywordsToQueryRequest
 */
export interface SERPApiSerpClusterGetRelatedKeywordsToQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterGetRelatedKeywordsToQuery
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpClusterKeywordIntersectionsRequest}
     * @memberof SERPApiSerpClusterGetRelatedKeywordsToQuery
     */
    readonly serpClusterKeywordIntersectionsRequest: SerpClusterKeywordIntersectionsRequest
}

/**
 * Request parameters for serpClusterSplitToSubClusters operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterSplitToSubClustersRequest
 */
export interface SERPApiSerpClusterSplitToSubClustersRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterSplitToSubClusters
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpClusterGroupSubClustersRequest}
     * @memberof SERPApiSerpClusterSplitToSubClusters
     */
    readonly serpClusterGroupSubClustersRequest: SerpClusterGroupSubClustersRequest
}

/**
 * Request parameters for serpSearch operation in SERPApi.
 * @export
 * @interface SERPApiSerpSearchRequest
 */
export interface SERPApiSerpSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpSearch
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpSearchRequests}
     * @memberof SERPApiSerpSearch
     */
    readonly serpSearchRequests: SerpSearchRequests
}

/**
 * Request parameters for serpVolumes operation in SERPApi.
 * @export
 * @interface SERPApiSerpVolumesRequest
 */
export interface SERPApiSerpVolumesRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpVolumes
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpVolumeRequest}
     * @memberof SERPApiSerpVolumes
     */
    readonly serpVolumeRequest: SerpVolumeRequest
}

/**
 * Request parameters for serpVolumesPingback operation in SERPApi.
 * @export
 * @interface SERPApiSerpVolumesPingbackRequest
 */
export interface SERPApiSerpVolumesPingbackRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpVolumesPingback
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpVolumesPingback
     */
    readonly tag: string | null
}

/**
 * SERPApi - object-oriented interface
 * @export
 * @class SERPApi
 * @extends {BaseAPI}
 */
export class SERPApi extends BaseAPI implements SERPApiInterface {
    /**
     * 
     * @summary Search Cluster Query
     * @param {SERPApiSearchClusterQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public searchClusterQuery(requestParameters: SERPApiSearchClusterQueryRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).searchClusterQuery(requestParameters.workspaceId, requestParameters.serpClusterGroupSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Add Queries
     * @param {SERPApiSerpClusterAddQueriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterAddQueries(requestParameters: SERPApiSerpClusterAddQueriesRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterAddQueries(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, requestParameters.serpClusterAddQueryRequests, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Delete Campaign
     * @param {SERPApiSerpClusterDeleteCampaignRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterDeleteCampaign(requestParameters: SERPApiSerpClusterDeleteCampaignRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterDeleteCampaign(requestParameters.customerId, requestParameters.campaignId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Delete Customer
     * @param {SERPApiSerpClusterDeleteCustomerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterDeleteCustomer(requestParameters: SERPApiSerpClusterDeleteCustomerRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterDeleteCustomer(requestParameters.customerId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Delete Group
     * @param {SERPApiSerpClusterDeleteGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterDeleteGroup(requestParameters: SERPApiSerpClusterDeleteGroupRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterDeleteGroup(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Delete Group Queries
     * @param {SERPApiSerpClusterDeleteGroupQueriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterDeleteGroupQueries(requestParameters: SERPApiSerpClusterDeleteGroupQueriesRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterDeleteGroupQueries(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, requestParameters.serpQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Get Graph Nodes
     * @param {SERPApiSerpClusterGetGraphNodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterGetGraphNodes(requestParameters: SERPApiSerpClusterGetGraphNodesRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterGetGraphNodes(requestParameters.workspaceId, requestParameters.serpClusterGroupIntersectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Get Matching Groups To Query
     * @param {SERPApiSerpClusterGetMatchingGroupsToQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterGetMatchingGroupsToQuery(requestParameters: SERPApiSerpClusterGetMatchingGroupsToQueryRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterGetMatchingGroupsToQuery(requestParameters.workspaceId, requestParameters.serpClusterBestGroupsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Get Related Keywords To Query
     * @param {SERPApiSerpClusterGetRelatedKeywordsToQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterGetRelatedKeywordsToQuery(requestParameters: SERPApiSerpClusterGetRelatedKeywordsToQueryRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterGetRelatedKeywordsToQuery(requestParameters.workspaceId, requestParameters.serpClusterKeywordIntersectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Split To Sub Clusters
     * @param {SERPApiSerpClusterSplitToSubClustersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterSplitToSubClusters(requestParameters: SERPApiSerpClusterSplitToSubClustersRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterSplitToSubClusters(requestParameters.workspaceId, requestParameters.serpClusterGroupSubClustersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Search
     * @param {SERPApiSerpSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpSearch(requestParameters: SERPApiSerpSearchRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpSearch(requestParameters.workspaceId, requestParameters.serpSearchRequests, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Volumes
     * @param {SERPApiSerpVolumesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpVolumes(requestParameters: SERPApiSerpVolumesRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpVolumes(requestParameters.workspaceId, requestParameters.serpVolumeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Volumes Pingback
     * @param {SERPApiSerpVolumesPingbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpVolumesPingback(requestParameters: SERPApiSerpVolumesPingbackRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpVolumesPingback(requestParameters.id, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchedulesApi - axios parameter creator
 * @export
 */
export const SchedulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Schedules
         * @param {string} workspaceId 
         * @param {Array<ScheduleCreateRequest>} scheduleCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedules: async (workspaceId: string, scheduleCreateRequest: Array<ScheduleCreateRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createSchedules', 'workspaceId', workspaceId)
            // verify required parameter 'scheduleCreateRequest' is not null or undefined
            assertParamExists('createSchedules', 'scheduleCreateRequest', scheduleCreateRequest)
            const localVarPath = `/v2/schedules/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedule: async (scheduleId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('deleteSchedule', 'scheduleId', scheduleId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteSchedule', 'workspaceId', workspaceId)
            const localVarPath = `/v2/schedules/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Schedule Url
         * @param {string} scheduleId 
         * @param {string} urlId 
         * @param {string} domainId 
         * @param {string} workspaceId 
         * @param {ScheduleUrlDeleteRequest} scheduleUrlDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduleUrl: async (scheduleId: string, urlId: string, domainId: string, workspaceId: string, scheduleUrlDeleteRequest: ScheduleUrlDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('deleteScheduleUrl', 'scheduleId', scheduleId)
            // verify required parameter 'urlId' is not null or undefined
            assertParamExists('deleteScheduleUrl', 'urlId', urlId)
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('deleteScheduleUrl', 'domainId', domainId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteScheduleUrl', 'workspaceId', workspaceId)
            // verify required parameter 'scheduleUrlDeleteRequest' is not null or undefined
            assertParamExists('deleteScheduleUrl', 'scheduleUrlDeleteRequest', scheduleUrlDeleteRequest)
            const localVarPath = `/v2/schedules/{schedule_id}/urls/{domain_id}/{url_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)))
                .replace(`{${"url_id"}}`, encodeURIComponent(String(urlId)))
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleUrlDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedule: async (scheduleId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('getSchedule', 'scheduleId', scheduleId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSchedule', 'workspaceId', workspaceId)
            const localVarPath = `/v2/schedules/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Schedule Url Details
         * @param {string} scheduleId 
         * @param {string} urlId 
         * @param {string} domainId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleUrlDetails: async (scheduleId: string, urlId: string, domainId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('getScheduleUrlDetails', 'scheduleId', scheduleId)
            // verify required parameter 'urlId' is not null or undefined
            assertParamExists('getScheduleUrlDetails', 'urlId', urlId)
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('getScheduleUrlDetails', 'domainId', domainId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScheduleUrlDetails', 'workspaceId', workspaceId)
            const localVarPath = `/v2/schedules/{schedule_id}/urls/{domain_id}/{url_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)))
                .replace(`{${"url_id"}}`, encodeURIComponent(String(urlId)))
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Schedules
         * @param {string} workspaceId 
         * @param {ScheduleSearchRequest} scheduleSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedules: async (workspaceId: string, scheduleSearchRequest: ScheduleSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSchedules', 'workspaceId', workspaceId)
            // verify required parameter 'scheduleSearchRequest' is not null or undefined
            assertParamExists('getSchedules', 'scheduleSearchRequest', scheduleSearchRequest)
            const localVarPath = `/v2/schedules/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSchedule: async (scheduleId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('runSchedule', 'scheduleId', scheduleId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('runSchedule', 'workspaceId', workspaceId)
            const localVarPath = `/v2/schedules/run/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Schedule Urls
         * @param {string} workspaceId 
         * @param {ScheduleUrlSearchRequest} scheduleUrlSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScheduleUrls: async (workspaceId: string, scheduleUrlSearchRequest: ScheduleUrlSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchScheduleUrls', 'workspaceId', workspaceId)
            // verify required parameter 'scheduleUrlSearchRequest' is not null or undefined
            assertParamExists('searchScheduleUrls', 'scheduleUrlSearchRequest', scheduleUrlSearchRequest)
            const localVarPath = `/v2/schedules/urls/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleUrlSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {ScheduleUpdateRequest} scheduleUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchedule: async (scheduleId: string, workspaceId: string, scheduleUpdateRequest: ScheduleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('updateSchedule', 'scheduleId', scheduleId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateSchedule', 'workspaceId', workspaceId)
            // verify required parameter 'scheduleUpdateRequest' is not null or undefined
            assertParamExists('updateSchedule', 'scheduleUpdateRequest', scheduleUpdateRequest)
            const localVarPath = `/v2/schedules/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchedulesApi - functional programming interface
 * @export
 */
export const SchedulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchedulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Schedules
         * @param {string} workspaceId 
         * @param {Array<ScheduleCreateRequest>} scheduleCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSchedules(workspaceId: string, scheduleCreateRequest: Array<ScheduleCreateRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSchedules(workspaceId, scheduleCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.createSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSchedule(scheduleId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSchedule(scheduleId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.deleteSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Schedule Url
         * @param {string} scheduleId 
         * @param {string} urlId 
         * @param {string} domainId 
         * @param {string} workspaceId 
         * @param {ScheduleUrlDeleteRequest} scheduleUrlDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScheduleUrl(scheduleId: string, urlId: string, domainId: string, workspaceId: string, scheduleUrlDeleteRequest: ScheduleUrlDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScheduleUrl(scheduleId, urlId, domainId, workspaceId, scheduleUrlDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.deleteScheduleUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchedule(scheduleId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchedule(scheduleId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.getSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Schedule Url Details
         * @param {string} scheduleId 
         * @param {string} urlId 
         * @param {string} domainId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduleUrlDetails(scheduleId: string, urlId: string, domainId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleUrlDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduleUrlDetails(scheduleId, urlId, domainId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.getScheduleUrlDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Schedules
         * @param {string} workspaceId 
         * @param {ScheduleSearchRequest} scheduleSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchedules(workspaceId: string, scheduleSearchRequest: ScheduleSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchedules(workspaceId, scheduleSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.getSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Run Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runSchedule(scheduleId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runSchedule(scheduleId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.runSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Schedule Urls
         * @param {string} workspaceId 
         * @param {ScheduleUrlSearchRequest} scheduleUrlSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchScheduleUrls(workspaceId: string, scheduleUrlSearchRequest: ScheduleUrlSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduleUrlResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchScheduleUrls(workspaceId, scheduleUrlSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.searchScheduleUrls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {ScheduleUpdateRequest} scheduleUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSchedule(scheduleId: string, workspaceId: string, scheduleUpdateRequest: ScheduleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSchedule(scheduleId, workspaceId, scheduleUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.updateSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchedulesApi - factory interface
 * @export
 */
export const SchedulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchedulesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Schedules
         * @param {SchedulesApiCreateSchedulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedules(requestParameters: SchedulesApiCreateSchedulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScheduleResponse>> {
            return localVarFp.createSchedules(requestParameters.workspaceId, requestParameters.scheduleCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Schedule
         * @param {SchedulesApiDeleteScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedule(requestParameters: SchedulesApiDeleteScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteSchedule(requestParameters.scheduleId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Schedule Url
         * @param {SchedulesApiDeleteScheduleUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduleUrl(requestParameters: SchedulesApiDeleteScheduleUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteScheduleUrl(requestParameters.scheduleId, requestParameters.urlId, requestParameters.domainId, requestParameters.workspaceId, requestParameters.scheduleUrlDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Schedule
         * @param {SchedulesApiGetScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedule(requestParameters: SchedulesApiGetScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleResponse> {
            return localVarFp.getSchedule(requestParameters.scheduleId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Schedule Url Details
         * @param {SchedulesApiGetScheduleUrlDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleUrlDetails(requestParameters: SchedulesApiGetScheduleUrlDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleUrlDetailResponse> {
            return localVarFp.getScheduleUrlDetails(requestParameters.scheduleId, requestParameters.urlId, requestParameters.domainId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Schedules
         * @param {SchedulesApiGetSchedulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedules(requestParameters: SchedulesApiGetSchedulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScheduleResponse>> {
            return localVarFp.getSchedules(requestParameters.workspaceId, requestParameters.scheduleSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run Schedule
         * @param {SchedulesApiRunScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSchedule(requestParameters: SchedulesApiRunScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.runSchedule(requestParameters.scheduleId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Schedule Urls
         * @param {SchedulesApiSearchScheduleUrlsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScheduleUrls(requestParameters: SchedulesApiSearchScheduleUrlsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScheduleUrlResponse>> {
            return localVarFp.searchScheduleUrls(requestParameters.workspaceId, requestParameters.scheduleUrlSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Schedule
         * @param {SchedulesApiUpdateScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchedule(requestParameters: SchedulesApiUpdateScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleResponse> {
            return localVarFp.updateSchedule(requestParameters.scheduleId, requestParameters.workspaceId, requestParameters.scheduleUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchedulesApi - interface
 * @export
 * @interface SchedulesApi
 */
export interface SchedulesApiInterface {
    /**
     * 
     * @summary Create Schedules
     * @param {SchedulesApiCreateSchedulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    createSchedules(requestParameters: SchedulesApiCreateSchedulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScheduleResponse>>;

    /**
     * 
     * @summary Delete Schedule
     * @param {SchedulesApiDeleteScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    deleteSchedule(requestParameters: SchedulesApiDeleteScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Delete Schedule Url
     * @param {SchedulesApiDeleteScheduleUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    deleteScheduleUrl(requestParameters: SchedulesApiDeleteScheduleUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Get Schedule
     * @param {SchedulesApiGetScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    getSchedule(requestParameters: SchedulesApiGetScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleResponse>;

    /**
     * 
     * @summary Get Schedule Url Details
     * @param {SchedulesApiGetScheduleUrlDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    getScheduleUrlDetails(requestParameters: SchedulesApiGetScheduleUrlDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleUrlDetailResponse>;

    /**
     * 
     * @summary Get Schedules
     * @param {SchedulesApiGetSchedulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    getSchedules(requestParameters: SchedulesApiGetSchedulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScheduleResponse>>;

    /**
     * 
     * @summary Run Schedule
     * @param {SchedulesApiRunScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    runSchedule(requestParameters: SchedulesApiRunScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Search Schedule Urls
     * @param {SchedulesApiSearchScheduleUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    searchScheduleUrls(requestParameters: SchedulesApiSearchScheduleUrlsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScheduleUrlResponse>>;

    /**
     * 
     * @summary Update Schedule
     * @param {SchedulesApiUpdateScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    updateSchedule(requestParameters: SchedulesApiUpdateScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleResponse>;

}

/**
 * Request parameters for createSchedules operation in SchedulesApi.
 * @export
 * @interface SchedulesApiCreateSchedulesRequest
 */
export interface SchedulesApiCreateSchedulesRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiCreateSchedules
     */
    readonly workspaceId: string

    /**
     * 
     * @type {Array<ScheduleCreateRequest>}
     * @memberof SchedulesApiCreateSchedules
     */
    readonly scheduleCreateRequest: Array<ScheduleCreateRequest>
}

/**
 * Request parameters for deleteSchedule operation in SchedulesApi.
 * @export
 * @interface SchedulesApiDeleteScheduleRequest
 */
export interface SchedulesApiDeleteScheduleRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiDeleteSchedule
     */
    readonly scheduleId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiDeleteSchedule
     */
    readonly workspaceId: string
}

/**
 * Request parameters for deleteScheduleUrl operation in SchedulesApi.
 * @export
 * @interface SchedulesApiDeleteScheduleUrlRequest
 */
export interface SchedulesApiDeleteScheduleUrlRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiDeleteScheduleUrl
     */
    readonly scheduleId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiDeleteScheduleUrl
     */
    readonly urlId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiDeleteScheduleUrl
     */
    readonly domainId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiDeleteScheduleUrl
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ScheduleUrlDeleteRequest}
     * @memberof SchedulesApiDeleteScheduleUrl
     */
    readonly scheduleUrlDeleteRequest: ScheduleUrlDeleteRequest
}

/**
 * Request parameters for getSchedule operation in SchedulesApi.
 * @export
 * @interface SchedulesApiGetScheduleRequest
 */
export interface SchedulesApiGetScheduleRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiGetSchedule
     */
    readonly scheduleId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiGetSchedule
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getScheduleUrlDetails operation in SchedulesApi.
 * @export
 * @interface SchedulesApiGetScheduleUrlDetailsRequest
 */
export interface SchedulesApiGetScheduleUrlDetailsRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiGetScheduleUrlDetails
     */
    readonly scheduleId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiGetScheduleUrlDetails
     */
    readonly urlId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiGetScheduleUrlDetails
     */
    readonly domainId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiGetScheduleUrlDetails
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getSchedules operation in SchedulesApi.
 * @export
 * @interface SchedulesApiGetSchedulesRequest
 */
export interface SchedulesApiGetSchedulesRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiGetSchedules
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ScheduleSearchRequest}
     * @memberof SchedulesApiGetSchedules
     */
    readonly scheduleSearchRequest: ScheduleSearchRequest
}

/**
 * Request parameters for runSchedule operation in SchedulesApi.
 * @export
 * @interface SchedulesApiRunScheduleRequest
 */
export interface SchedulesApiRunScheduleRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiRunSchedule
     */
    readonly scheduleId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiRunSchedule
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchScheduleUrls operation in SchedulesApi.
 * @export
 * @interface SchedulesApiSearchScheduleUrlsRequest
 */
export interface SchedulesApiSearchScheduleUrlsRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiSearchScheduleUrls
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ScheduleUrlSearchRequest}
     * @memberof SchedulesApiSearchScheduleUrls
     */
    readonly scheduleUrlSearchRequest: ScheduleUrlSearchRequest
}

/**
 * Request parameters for updateSchedule operation in SchedulesApi.
 * @export
 * @interface SchedulesApiUpdateScheduleRequest
 */
export interface SchedulesApiUpdateScheduleRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiUpdateSchedule
     */
    readonly scheduleId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiUpdateSchedule
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ScheduleUpdateRequest}
     * @memberof SchedulesApiUpdateSchedule
     */
    readonly scheduleUpdateRequest: ScheduleUpdateRequest
}

/**
 * SchedulesApi - object-oriented interface
 * @export
 * @class SchedulesApi
 * @extends {BaseAPI}
 */
export class SchedulesApi extends BaseAPI implements SchedulesApiInterface {
    /**
     * 
     * @summary Create Schedules
     * @param {SchedulesApiCreateSchedulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public createSchedules(requestParameters: SchedulesApiCreateSchedulesRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).createSchedules(requestParameters.workspaceId, requestParameters.scheduleCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Schedule
     * @param {SchedulesApiDeleteScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public deleteSchedule(requestParameters: SchedulesApiDeleteScheduleRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).deleteSchedule(requestParameters.scheduleId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Schedule Url
     * @param {SchedulesApiDeleteScheduleUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public deleteScheduleUrl(requestParameters: SchedulesApiDeleteScheduleUrlRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).deleteScheduleUrl(requestParameters.scheduleId, requestParameters.urlId, requestParameters.domainId, requestParameters.workspaceId, requestParameters.scheduleUrlDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Schedule
     * @param {SchedulesApiGetScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public getSchedule(requestParameters: SchedulesApiGetScheduleRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).getSchedule(requestParameters.scheduleId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Schedule Url Details
     * @param {SchedulesApiGetScheduleUrlDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public getScheduleUrlDetails(requestParameters: SchedulesApiGetScheduleUrlDetailsRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).getScheduleUrlDetails(requestParameters.scheduleId, requestParameters.urlId, requestParameters.domainId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Schedules
     * @param {SchedulesApiGetSchedulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public getSchedules(requestParameters: SchedulesApiGetSchedulesRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).getSchedules(requestParameters.workspaceId, requestParameters.scheduleSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run Schedule
     * @param {SchedulesApiRunScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public runSchedule(requestParameters: SchedulesApiRunScheduleRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).runSchedule(requestParameters.scheduleId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Schedule Urls
     * @param {SchedulesApiSearchScheduleUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public searchScheduleUrls(requestParameters: SchedulesApiSearchScheduleUrlsRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).searchScheduleUrls(requestParameters.workspaceId, requestParameters.scheduleUrlSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Schedule
     * @param {SchedulesApiUpdateScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public updateSchedule(requestParameters: SchedulesApiUpdateScheduleRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).updateSchedule(requestParameters.scheduleId, requestParameters.workspaceId, requestParameters.scheduleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SemanticSearchApi - axios parameter creator
 * @export
 */
export const SemanticSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Similar Docs By Doc Id
         * @param {string} workspaceId 
         * @param {DocumentSimilarityRequest} documentSimilarityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarDocsByDocId: async (workspaceId: string, documentSimilarityRequest: DocumentSimilarityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSimilarDocsByDocId', 'workspaceId', workspaceId)
            // verify required parameter 'documentSimilarityRequest' is not null or undefined
            assertParamExists('getSimilarDocsByDocId', 'documentSimilarityRequest', documentSimilarityRequest)
            const localVarPath = `/v2/similarities/document/live`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentSimilarityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Similar Docs By Query
         * @param {string} workspaceId 
         * @param {QuerySimilarityRequest} querySimilarityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarDocsByQuery: async (workspaceId: string, querySimilarityRequest: QuerySimilarityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSimilarDocsByQuery', 'workspaceId', workspaceId)
            // verify required parameter 'querySimilarityRequest' is not null or undefined
            assertParamExists('getSimilarDocsByQuery', 'querySimilarityRequest', querySimilarityRequest)
            const localVarPath = `/v2/similarities/query/live`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(querySimilarityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Schedule Similar Docs By Doc Id
         * @param {string} workspaceId 
         * @param {DocumentSimilarityTaskRequest} documentSimilarityTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleSimilarDocsByDocId: async (workspaceId: string, documentSimilarityTaskRequest: DocumentSimilarityTaskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('scheduleSimilarDocsByDocId', 'workspaceId', workspaceId)
            // verify required parameter 'documentSimilarityTaskRequest' is not null or undefined
            assertParamExists('scheduleSimilarDocsByDocId', 'documentSimilarityTaskRequest', documentSimilarityTaskRequest)
            const localVarPath = `/v2/similarities/document`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentSimilarityTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Schedule Similar Docs By Query
         * @param {string} workspaceId 
         * @param {QuerySimilarityTaskRequest} querySimilarityTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleSimilarDocsByQuery: async (workspaceId: string, querySimilarityTaskRequest: QuerySimilarityTaskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('scheduleSimilarDocsByQuery', 'workspaceId', workspaceId)
            // verify required parameter 'querySimilarityTaskRequest' is not null or undefined
            assertParamExists('scheduleSimilarDocsByQuery', 'querySimilarityTaskRequest', querySimilarityTaskRequest)
            const localVarPath = `/v2/similarities/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(querySimilarityTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SemanticSearchApi - functional programming interface
 * @export
 */
export const SemanticSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SemanticSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Similar Docs By Doc Id
         * @param {string} workspaceId 
         * @param {DocumentSimilarityRequest} documentSimilarityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarDocsByDocId(workspaceId: string, documentSimilarityRequest: DocumentSimilarityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VectorDocumentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimilarDocsByDocId(workspaceId, documentSimilarityRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SemanticSearchApi.getSimilarDocsByDocId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Similar Docs By Query
         * @param {string} workspaceId 
         * @param {QuerySimilarityRequest} querySimilarityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarDocsByQuery(workspaceId: string, querySimilarityRequest: QuerySimilarityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VectorDocumentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimilarDocsByQuery(workspaceId, querySimilarityRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SemanticSearchApi.getSimilarDocsByQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Schedule Similar Docs By Doc Id
         * @param {string} workspaceId 
         * @param {DocumentSimilarityTaskRequest} documentSimilarityTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleSimilarDocsByDocId(workspaceId: string, documentSimilarityTaskRequest: DocumentSimilarityTaskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VectorDocumentsTaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleSimilarDocsByDocId(workspaceId, documentSimilarityTaskRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SemanticSearchApi.scheduleSimilarDocsByDocId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Schedule Similar Docs By Query
         * @param {string} workspaceId 
         * @param {QuerySimilarityTaskRequest} querySimilarityTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleSimilarDocsByQuery(workspaceId: string, querySimilarityTaskRequest: QuerySimilarityTaskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VectorDocumentsTaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleSimilarDocsByQuery(workspaceId, querySimilarityTaskRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SemanticSearchApi.scheduleSimilarDocsByQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SemanticSearchApi - factory interface
 * @export
 */
export const SemanticSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SemanticSearchApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Similar Docs By Doc Id
         * @param {SemanticSearchApiGetSimilarDocsByDocIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarDocsByDocId(requestParameters: SemanticSearchApiGetSimilarDocsByDocIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<VectorDocumentResponse>> {
            return localVarFp.getSimilarDocsByDocId(requestParameters.workspaceId, requestParameters.documentSimilarityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Similar Docs By Query
         * @param {SemanticSearchApiGetSimilarDocsByQueryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarDocsByQuery(requestParameters: SemanticSearchApiGetSimilarDocsByQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<VectorDocumentResponse>> {
            return localVarFp.getSimilarDocsByQuery(requestParameters.workspaceId, requestParameters.querySimilarityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Schedule Similar Docs By Doc Id
         * @param {SemanticSearchApiScheduleSimilarDocsByDocIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleSimilarDocsByDocId(requestParameters: SemanticSearchApiScheduleSimilarDocsByDocIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<VectorDocumentsTaskResponse> {
            return localVarFp.scheduleSimilarDocsByDocId(requestParameters.workspaceId, requestParameters.documentSimilarityTaskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Schedule Similar Docs By Query
         * @param {SemanticSearchApiScheduleSimilarDocsByQueryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleSimilarDocsByQuery(requestParameters: SemanticSearchApiScheduleSimilarDocsByQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<VectorDocumentsTaskResponse> {
            return localVarFp.scheduleSimilarDocsByQuery(requestParameters.workspaceId, requestParameters.querySimilarityTaskRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SemanticSearchApi - interface
 * @export
 * @interface SemanticSearchApi
 */
export interface SemanticSearchApiInterface {
    /**
     * 
     * @summary Get Similar Docs By Doc Id
     * @param {SemanticSearchApiGetSimilarDocsByDocIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApiInterface
     */
    getSimilarDocsByDocId(requestParameters: SemanticSearchApiGetSimilarDocsByDocIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<VectorDocumentResponse>>;

    /**
     * 
     * @summary Get Similar Docs By Query
     * @param {SemanticSearchApiGetSimilarDocsByQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApiInterface
     */
    getSimilarDocsByQuery(requestParameters: SemanticSearchApiGetSimilarDocsByQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<VectorDocumentResponse>>;

    /**
     * 
     * @summary Schedule Similar Docs By Doc Id
     * @param {SemanticSearchApiScheduleSimilarDocsByDocIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApiInterface
     */
    scheduleSimilarDocsByDocId(requestParameters: SemanticSearchApiScheduleSimilarDocsByDocIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<VectorDocumentsTaskResponse>;

    /**
     * 
     * @summary Schedule Similar Docs By Query
     * @param {SemanticSearchApiScheduleSimilarDocsByQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApiInterface
     */
    scheduleSimilarDocsByQuery(requestParameters: SemanticSearchApiScheduleSimilarDocsByQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<VectorDocumentsTaskResponse>;

}

/**
 * Request parameters for getSimilarDocsByDocId operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiGetSimilarDocsByDocIdRequest
 */
export interface SemanticSearchApiGetSimilarDocsByDocIdRequest {
    /**
     * 
     * @type {string}
     * @memberof SemanticSearchApiGetSimilarDocsByDocId
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DocumentSimilarityRequest}
     * @memberof SemanticSearchApiGetSimilarDocsByDocId
     */
    readonly documentSimilarityRequest: DocumentSimilarityRequest
}

/**
 * Request parameters for getSimilarDocsByQuery operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiGetSimilarDocsByQueryRequest
 */
export interface SemanticSearchApiGetSimilarDocsByQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof SemanticSearchApiGetSimilarDocsByQuery
     */
    readonly workspaceId: string

    /**
     * 
     * @type {QuerySimilarityRequest}
     * @memberof SemanticSearchApiGetSimilarDocsByQuery
     */
    readonly querySimilarityRequest: QuerySimilarityRequest
}

/**
 * Request parameters for scheduleSimilarDocsByDocId operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiScheduleSimilarDocsByDocIdRequest
 */
export interface SemanticSearchApiScheduleSimilarDocsByDocIdRequest {
    /**
     * 
     * @type {string}
     * @memberof SemanticSearchApiScheduleSimilarDocsByDocId
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DocumentSimilarityTaskRequest}
     * @memberof SemanticSearchApiScheduleSimilarDocsByDocId
     */
    readonly documentSimilarityTaskRequest: DocumentSimilarityTaskRequest
}

/**
 * Request parameters for scheduleSimilarDocsByQuery operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiScheduleSimilarDocsByQueryRequest
 */
export interface SemanticSearchApiScheduleSimilarDocsByQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof SemanticSearchApiScheduleSimilarDocsByQuery
     */
    readonly workspaceId: string

    /**
     * 
     * @type {QuerySimilarityTaskRequest}
     * @memberof SemanticSearchApiScheduleSimilarDocsByQuery
     */
    readonly querySimilarityTaskRequest: QuerySimilarityTaskRequest
}

/**
 * SemanticSearchApi - object-oriented interface
 * @export
 * @class SemanticSearchApi
 * @extends {BaseAPI}
 */
export class SemanticSearchApi extends BaseAPI implements SemanticSearchApiInterface {
    /**
     * 
     * @summary Get Similar Docs By Doc Id
     * @param {SemanticSearchApiGetSimilarDocsByDocIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public getSimilarDocsByDocId(requestParameters: SemanticSearchApiGetSimilarDocsByDocIdRequest, options?: RawAxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).getSimilarDocsByDocId(requestParameters.workspaceId, requestParameters.documentSimilarityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Similar Docs By Query
     * @param {SemanticSearchApiGetSimilarDocsByQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public getSimilarDocsByQuery(requestParameters: SemanticSearchApiGetSimilarDocsByQueryRequest, options?: RawAxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).getSimilarDocsByQuery(requestParameters.workspaceId, requestParameters.querySimilarityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Schedule Similar Docs By Doc Id
     * @param {SemanticSearchApiScheduleSimilarDocsByDocIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public scheduleSimilarDocsByDocId(requestParameters: SemanticSearchApiScheduleSimilarDocsByDocIdRequest, options?: RawAxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).scheduleSimilarDocsByDocId(requestParameters.workspaceId, requestParameters.documentSimilarityTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Schedule Similar Docs By Query
     * @param {SemanticSearchApiScheduleSimilarDocsByQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public scheduleSimilarDocsByQuery(requestParameters: SemanticSearchApiScheduleSimilarDocsByQueryRequest, options?: RawAxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).scheduleSimilarDocsByQuery(requestParameters.workspaceId, requestParameters.querySimilarityTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ShopifyApi - axios parameter creator
 * @export
 */
export const ShopifyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Data Request
         * @param {CustomerDataRequestPayload} customerDataRequestPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDataRequest: async (customerDataRequestPayload: CustomerDataRequestPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerDataRequestPayload' is not null or undefined
            assertParamExists('customerDataRequest', 'customerDataRequestPayload', customerDataRequestPayload)
            const localVarPath = `/v2/integrations/shopify/webhooks/customers/data_request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerDataRequestPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Redact
         * @param {CustomerRedactPayload} customerRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerRedact: async (customerRedactPayload: CustomerRedactPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerRedactPayload' is not null or undefined
            assertParamExists('customerRedact', 'customerRedactPayload', customerRedactPayload)
            const localVarPath = `/v2/integrations/shopify/webhooks/customers/redact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerRedactPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Shopify
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopify: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getShopify', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/shopify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Shop Redact
         * @param {ShopRedactPayload} shopRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopRedact: async (shopRedactPayload: ShopRedactPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shopRedactPayload' is not null or undefined
            assertParamExists('shopRedact', 'shopRedactPayload', shopRedactPayload)
            const localVarPath = `/v2/integrations/shopify/webhooks/shop/redact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopRedactPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle subscription cancellation webhooks from Shopify.
         * @summary Subscription Cancel
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionCancel: async (xShopifyHmacSha256?: string, xShopifyTopic?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/integrations/shopify/webhooks/billing/subscription_cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xShopifyHmacSha256 != null) {
                localVarHeaderParameter['x-shopify-hmac-sha256'] = String(xShopifyHmacSha256);
            }
            if (xShopifyTopic != null) {
                localVarHeaderParameter['x-shopify-topic'] = String(xShopifyTopic);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
         * @summary Subscription Update
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionUpdate: async (xShopifyHmacSha256?: string, xShopifyTopic?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/integrations/shopify/webhooks/billing/subscription_update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xShopifyHmacSha256 != null) {
                localVarHeaderParameter['x-shopify-hmac-sha256'] = String(xShopifyHmacSha256);
            }
            if (xShopifyTopic != null) {
                localVarHeaderParameter['x-shopify-topic'] = String(xShopifyTopic);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShopifyApi - functional programming interface
 * @export
 */
export const ShopifyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShopifyApiAxiosParamCreator(configuration)
    return {
        /**
         * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Data Request
         * @param {CustomerDataRequestPayload} customerDataRequestPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerDataRequest(customerDataRequestPayload: CustomerDataRequestPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerDataRequest(customerDataRequestPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopifyApi.customerDataRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Redact
         * @param {CustomerRedactPayload} customerRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerRedact(customerRedactPayload: CustomerRedactPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerRedact(customerRedactPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopifyApi.customerRedact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Shopify
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShopify(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopifyIntegrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShopify(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopifyApi.getShopify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Shop Redact
         * @param {ShopRedactPayload} shopRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopRedact(shopRedactPayload: ShopRedactPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopRedact(shopRedactPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopifyApi.shopRedact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle subscription cancellation webhooks from Shopify.
         * @summary Subscription Cancel
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionCancel(xShopifyHmacSha256?: string, xShopifyTopic?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionCancel(xShopifyHmacSha256, xShopifyTopic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopifyApi.subscriptionCancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
         * @summary Subscription Update
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionUpdate(xShopifyHmacSha256?: string, xShopifyTopic?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionUpdate(xShopifyHmacSha256, xShopifyTopic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopifyApi.subscriptionUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShopifyApi - factory interface
 * @export
 */
export const ShopifyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShopifyApiFp(configuration)
    return {
        /**
         * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Data Request
         * @param {ShopifyApiCustomerDataRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDataRequest(requestParameters: ShopifyApiCustomerDataRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.customerDataRequest(requestParameters.customerDataRequestPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Redact
         * @param {ShopifyApiCustomerRedactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerRedact(requestParameters: ShopifyApiCustomerRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.customerRedact(requestParameters.customerRedactPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Shopify
         * @param {ShopifyApiGetShopifyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopify(requestParameters: ShopifyApiGetShopifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ShopifyIntegrationResponse> {
            return localVarFp.getShopify(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Shop Redact
         * @param {ShopifyApiShopRedactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopRedact(requestParameters: ShopifyApiShopRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.shopRedact(requestParameters.shopRedactPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle subscription cancellation webhooks from Shopify.
         * @summary Subscription Cancel
         * @param {ShopifyApiSubscriptionCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionCancel(requestParameters: ShopifyApiSubscriptionCancelRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.subscriptionCancel(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
         * @summary Subscription Update
         * @param {ShopifyApiSubscriptionUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionUpdate(requestParameters: ShopifyApiSubscriptionUpdateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.subscriptionUpdate(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShopifyApi - interface
 * @export
 * @interface ShopifyApi
 */
export interface ShopifyApiInterface {
    /**
     * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Data Request
     * @param {ShopifyApiCustomerDataRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApiInterface
     */
    customerDataRequest(requestParameters: ShopifyApiCustomerDataRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Redact
     * @param {ShopifyApiCustomerRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApiInterface
     */
    customerRedact(requestParameters: ShopifyApiCustomerRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Shopify
     * @param {ShopifyApiGetShopifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApiInterface
     */
    getShopify(requestParameters: ShopifyApiGetShopifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ShopifyIntegrationResponse>;

    /**
     * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Shop Redact
     * @param {ShopifyApiShopRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApiInterface
     */
    shopRedact(requestParameters: ShopifyApiShopRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle subscription cancellation webhooks from Shopify.
     * @summary Subscription Cancel
     * @param {ShopifyApiSubscriptionCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApiInterface
     */
    subscriptionCancel(requestParameters?: ShopifyApiSubscriptionCancelRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
     * @summary Subscription Update
     * @param {ShopifyApiSubscriptionUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApiInterface
     */
    subscriptionUpdate(requestParameters?: ShopifyApiSubscriptionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

}

/**
 * Request parameters for customerDataRequest operation in ShopifyApi.
 * @export
 * @interface ShopifyApiCustomerDataRequestRequest
 */
export interface ShopifyApiCustomerDataRequestRequest {
    /**
     * 
     * @type {CustomerDataRequestPayload}
     * @memberof ShopifyApiCustomerDataRequest
     */
    readonly customerDataRequestPayload: CustomerDataRequestPayload
}

/**
 * Request parameters for customerRedact operation in ShopifyApi.
 * @export
 * @interface ShopifyApiCustomerRedactRequest
 */
export interface ShopifyApiCustomerRedactRequest {
    /**
     * 
     * @type {CustomerRedactPayload}
     * @memberof ShopifyApiCustomerRedact
     */
    readonly customerRedactPayload: CustomerRedactPayload
}

/**
 * Request parameters for getShopify operation in ShopifyApi.
 * @export
 * @interface ShopifyApiGetShopifyRequest
 */
export interface ShopifyApiGetShopifyRequest {
    /**
     * 
     * @type {string}
     * @memberof ShopifyApiGetShopify
     */
    readonly workspaceId: string
}

/**
 * Request parameters for shopRedact operation in ShopifyApi.
 * @export
 * @interface ShopifyApiShopRedactRequest
 */
export interface ShopifyApiShopRedactRequest {
    /**
     * 
     * @type {ShopRedactPayload}
     * @memberof ShopifyApiShopRedact
     */
    readonly shopRedactPayload: ShopRedactPayload
}

/**
 * Request parameters for subscriptionCancel operation in ShopifyApi.
 * @export
 * @interface ShopifyApiSubscriptionCancelRequest
 */
export interface ShopifyApiSubscriptionCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof ShopifyApiSubscriptionCancel
     */
    readonly xShopifyHmacSha256?: string

    /**
     * 
     * @type {string}
     * @memberof ShopifyApiSubscriptionCancel
     */
    readonly xShopifyTopic?: string
}

/**
 * Request parameters for subscriptionUpdate operation in ShopifyApi.
 * @export
 * @interface ShopifyApiSubscriptionUpdateRequest
 */
export interface ShopifyApiSubscriptionUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ShopifyApiSubscriptionUpdate
     */
    readonly xShopifyHmacSha256?: string

    /**
     * 
     * @type {string}
     * @memberof ShopifyApiSubscriptionUpdate
     */
    readonly xShopifyTopic?: string
}

/**
 * ShopifyApi - object-oriented interface
 * @export
 * @class ShopifyApi
 * @extends {BaseAPI}
 */
export class ShopifyApi extends BaseAPI implements ShopifyApiInterface {
    /**
     * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Data Request
     * @param {ShopifyApiCustomerDataRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApi
     */
    public customerDataRequest(requestParameters: ShopifyApiCustomerDataRequestRequest, options?: RawAxiosRequestConfig) {
        return ShopifyApiFp(this.configuration).customerDataRequest(requestParameters.customerDataRequestPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Redact
     * @param {ShopifyApiCustomerRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApi
     */
    public customerRedact(requestParameters: ShopifyApiCustomerRedactRequest, options?: RawAxiosRequestConfig) {
        return ShopifyApiFp(this.configuration).customerRedact(requestParameters.customerRedactPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Shopify
     * @param {ShopifyApiGetShopifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApi
     */
    public getShopify(requestParameters: ShopifyApiGetShopifyRequest, options?: RawAxiosRequestConfig) {
        return ShopifyApiFp(this.configuration).getShopify(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Shop Redact
     * @param {ShopifyApiShopRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApi
     */
    public shopRedact(requestParameters: ShopifyApiShopRedactRequest, options?: RawAxiosRequestConfig) {
        return ShopifyApiFp(this.configuration).shopRedact(requestParameters.shopRedactPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle subscription cancellation webhooks from Shopify.
     * @summary Subscription Cancel
     * @param {ShopifyApiSubscriptionCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApi
     */
    public subscriptionCancel(requestParameters: ShopifyApiSubscriptionCancelRequest = {}, options?: RawAxiosRequestConfig) {
        return ShopifyApiFp(this.configuration).subscriptionCancel(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
     * @summary Subscription Update
     * @param {ShopifyApiSubscriptionUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApi
     */
    public subscriptionUpdate(requestParameters: ShopifyApiSubscriptionUpdateRequest = {}, options?: RawAxiosRequestConfig) {
        return ShopifyApiFp(this.configuration).subscriptionUpdate(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SlackApi - axios parameter creator
 * @export
 */
export const SlackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Slack Channels
         * @param {string} slackTeamId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackChannels: async (slackTeamId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slackTeamId' is not null or undefined
            assertParamExists('getSlackChannels', 'slackTeamId', slackTeamId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSlackChannels', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/slack/{slack_team_id}/channels`
                .replace(`{${"slack_team_id"}}`, encodeURIComponent(String(slackTeamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Slack Workspaces
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackWorkspaces: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSlackWorkspaces', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/slack/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SlackApi - functional programming interface
 * @export
 */
export const SlackApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SlackApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Slack Channels
         * @param {string} slackTeamId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlackChannels(slackTeamId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SlackChannelResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlackChannels(slackTeamId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlackApi.getSlackChannels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Slack Workspaces
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlackWorkspaces(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SlackWorkspaceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlackWorkspaces(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlackApi.getSlackWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SlackApi - factory interface
 * @export
 */
export const SlackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SlackApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Slack Channels
         * @param {SlackApiGetSlackChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackChannels(requestParameters: SlackApiGetSlackChannelsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackChannelResponse>> {
            return localVarFp.getSlackChannels(requestParameters.slackTeamId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Slack Workspaces
         * @param {SlackApiGetSlackWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackWorkspaces(requestParameters: SlackApiGetSlackWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackWorkspaceResponse>> {
            return localVarFp.getSlackWorkspaces(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SlackApi - interface
 * @export
 * @interface SlackApi
 */
export interface SlackApiInterface {
    /**
     * 
     * @summary Get Slack Channels
     * @param {SlackApiGetSlackChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackApiInterface
     */
    getSlackChannels(requestParameters: SlackApiGetSlackChannelsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackChannelResponse>>;

    /**
     * 
     * @summary Get Slack Workspaces
     * @param {SlackApiGetSlackWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackApiInterface
     */
    getSlackWorkspaces(requestParameters: SlackApiGetSlackWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackWorkspaceResponse>>;

}

/**
 * Request parameters for getSlackChannels operation in SlackApi.
 * @export
 * @interface SlackApiGetSlackChannelsRequest
 */
export interface SlackApiGetSlackChannelsRequest {
    /**
     * 
     * @type {string}
     * @memberof SlackApiGetSlackChannels
     */
    readonly slackTeamId: string

    /**
     * 
     * @type {string}
     * @memberof SlackApiGetSlackChannels
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getSlackWorkspaces operation in SlackApi.
 * @export
 * @interface SlackApiGetSlackWorkspacesRequest
 */
export interface SlackApiGetSlackWorkspacesRequest {
    /**
     * 
     * @type {string}
     * @memberof SlackApiGetSlackWorkspaces
     */
    readonly workspaceId: string
}

/**
 * SlackApi - object-oriented interface
 * @export
 * @class SlackApi
 * @extends {BaseAPI}
 */
export class SlackApi extends BaseAPI implements SlackApiInterface {
    /**
     * 
     * @summary Get Slack Channels
     * @param {SlackApiGetSlackChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackApi
     */
    public getSlackChannels(requestParameters: SlackApiGetSlackChannelsRequest, options?: RawAxiosRequestConfig) {
        return SlackApiFp(this.configuration).getSlackChannels(requestParameters.slackTeamId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Slack Workspaces
     * @param {SlackApiGetSlackWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackApi
     */
    public getSlackWorkspaces(requestParameters: SlackApiGetSlackWorkspacesRequest, options?: RawAxiosRequestConfig) {
        return SlackApiFp(this.configuration).getSlackWorkspaces(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Tag
         * @param {string} workspaceId 
         * @param {TagCreateRequest} tagCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (workspaceId: string, tagCreateRequest: TagCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createTag', 'workspaceId', workspaceId)
            // verify required parameter 'tagCreateRequest' is not null or undefined
            assertParamExists('createTag', 'tagCreateRequest', tagCreateRequest)
            const localVarPath = `/v2/tags/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Tag
         * @param {string} tagId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tagId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('deleteTag', 'tagId', tagId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteTag', 'workspaceId', workspaceId)
            const localVarPath = `/v2/tags/{tag_id}`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Tags
         * @param {string} workspaceId 
         * @param {TagSearchRequest} tagSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTags: async (workspaceId: string, tagSearchRequest: TagSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchTags', 'workspaceId', workspaceId)
            // verify required parameter 'tagSearchRequest' is not null or undefined
            assertParamExists('searchTags', 'tagSearchRequest', tagSearchRequest)
            const localVarPath = `/v2/tags/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Tag
         * @param {string} tagId 
         * @param {string} workspaceId 
         * @param {TagUpdateRequest} tagUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (tagId: string, workspaceId: string, tagUpdateRequest: TagUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('updateTag', 'tagId', tagId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateTag', 'workspaceId', workspaceId)
            // verify required parameter 'tagUpdateRequest' is not null or undefined
            assertParamExists('updateTag', 'tagUpdateRequest', tagUpdateRequest)
            const localVarPath = `/v2/tags/{tag_id}`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Tag
         * @param {string} workspaceId 
         * @param {TagCreateRequest} tagCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(workspaceId: string, tagCreateRequest: TagCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(workspaceId, tagCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.createTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Tag
         * @param {string} tagId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tagId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tagId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.deleteTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Tags
         * @param {string} workspaceId 
         * @param {TagSearchRequest} tagSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTags(workspaceId: string, tagSearchRequest: TagSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTags(workspaceId, tagSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.searchTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Tag
         * @param {string} tagId 
         * @param {string} workspaceId 
         * @param {TagUpdateRequest} tagUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(tagId: string, workspaceId: string, tagUpdateRequest: TagUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(tagId, workspaceId, tagUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.updateTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Tag
         * @param {TagsApiCreateTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(requestParameters: TagsApiCreateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagResponse> {
            return localVarFp.createTag(requestParameters.workspaceId, requestParameters.tagCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Tag
         * @param {TagsApiDeleteTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(requestParameters: TagsApiDeleteTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteTag(requestParameters.tagId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Tags
         * @param {TagsApiSearchTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTags(requestParameters: TagsApiSearchTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<TagResponse>> {
            return localVarFp.searchTags(requestParameters.workspaceId, requestParameters.tagSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Tag
         * @param {TagsApiUpdateTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(requestParameters: TagsApiUpdateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagResponse> {
            return localVarFp.updateTag(requestParameters.tagId, requestParameters.workspaceId, requestParameters.tagUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - interface
 * @export
 * @interface TagsApi
 */
export interface TagsApiInterface {
    /**
     * 
     * @summary Create Tag
     * @param {TagsApiCreateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    createTag(requestParameters: TagsApiCreateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagResponse>;

    /**
     * 
     * @summary Delete Tag
     * @param {TagsApiDeleteTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    deleteTag(requestParameters: TagsApiDeleteTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Search Tags
     * @param {TagsApiSearchTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    searchTags(requestParameters: TagsApiSearchTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<TagResponse>>;

    /**
     * 
     * @summary Update Tag
     * @param {TagsApiUpdateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    updateTag(requestParameters: TagsApiUpdateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagResponse>;

}

/**
 * Request parameters for createTag operation in TagsApi.
 * @export
 * @interface TagsApiCreateTagRequest
 */
export interface TagsApiCreateTagRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiCreateTag
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TagCreateRequest}
     * @memberof TagsApiCreateTag
     */
    readonly tagCreateRequest: TagCreateRequest
}

/**
 * Request parameters for deleteTag operation in TagsApi.
 * @export
 * @interface TagsApiDeleteTagRequest
 */
export interface TagsApiDeleteTagRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiDeleteTag
     */
    readonly tagId: string

    /**
     * 
     * @type {string}
     * @memberof TagsApiDeleteTag
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchTags operation in TagsApi.
 * @export
 * @interface TagsApiSearchTagsRequest
 */
export interface TagsApiSearchTagsRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiSearchTags
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TagSearchRequest}
     * @memberof TagsApiSearchTags
     */
    readonly tagSearchRequest: TagSearchRequest
}

/**
 * Request parameters for updateTag operation in TagsApi.
 * @export
 * @interface TagsApiUpdateTagRequest
 */
export interface TagsApiUpdateTagRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiUpdateTag
     */
    readonly tagId: string

    /**
     * 
     * @type {string}
     * @memberof TagsApiUpdateTag
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TagUpdateRequest}
     * @memberof TagsApiUpdateTag
     */
    readonly tagUpdateRequest: TagUpdateRequest
}

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI implements TagsApiInterface {
    /**
     * 
     * @summary Create Tag
     * @param {TagsApiCreateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public createTag(requestParameters: TagsApiCreateTagRequest, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).createTag(requestParameters.workspaceId, requestParameters.tagCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Tag
     * @param {TagsApiDeleteTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTag(requestParameters: TagsApiDeleteTagRequest, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteTag(requestParameters.tagId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Tags
     * @param {TagsApiSearchTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public searchTags(requestParameters: TagsApiSearchTagsRequest, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).searchTags(requestParameters.workspaceId, requestParameters.tagSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Tag
     * @param {TagsApiUpdateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTag(requestParameters: TagsApiUpdateTagRequest, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTag(requestParameters.tagId, requestParameters.workspaceId, requestParameters.tagUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TrackingApi - axios parameter creator
 * @export
 */
export const TrackingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Search Events
         * @param {string} workspaceId 
         * @param {TrackingEventSearchRequest} trackingEventSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEvents: async (workspaceId: string, trackingEventSearchRequest: TrackingEventSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchEvents', 'workspaceId', workspaceId)
            // verify required parameter 'trackingEventSearchRequest' is not null or undefined
            assertParamExists('searchEvents', 'trackingEventSearchRequest', trackingEventSearchRequest)
            const localVarPath = `/v2/tracking/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingEventSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Links
         * @param {string} workspaceId 
         * @param {TrackingLinkSearchRequest} trackingLinkSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLinks: async (workspaceId: string, trackingLinkSearchRequest: TrackingLinkSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchLinks', 'workspaceId', workspaceId)
            // verify required parameter 'trackingLinkSearchRequest' is not null or undefined
            assertParamExists('searchLinks', 'trackingLinkSearchRequest', trackingLinkSearchRequest)
            const localVarPath = `/v2/tracking/links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingLinkSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Sources
         * @param {string} workspaceId 
         * @param {TrackingSourceSearchRequest} trackingSourceSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSources: async (workspaceId: string, trackingSourceSearchRequest: TrackingSourceSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchSources', 'workspaceId', workspaceId)
            // verify required parameter 'trackingSourceSearchRequest' is not null or undefined
            assertParamExists('searchSources', 'trackingSourceSearchRequest', trackingSourceSearchRequest)
            const localVarPath = `/v2/tracking/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingSourceSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Track Click
         * @param {string} workspaceId 
         * @param {TrackingSourceCreateRequest} trackingSourceCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackClick: async (workspaceId: string, trackingSourceCreateRequest: TrackingSourceCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('trackClick', 'workspaceId', workspaceId)
            // verify required parameter 'trackingSourceCreateRequest' is not null or undefined
            assertParamExists('trackClick', 'trackingSourceCreateRequest', trackingSourceCreateRequest)
            const localVarPath = `/v2/tracking/clk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingSourceCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Track Event
         * @param {string} workspaceId 
         * @param {TrackingEventCreateRequests} trackingEventCreateRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackEvent: async (workspaceId: string, trackingEventCreateRequests: TrackingEventCreateRequests, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('trackEvent', 'workspaceId', workspaceId)
            // verify required parameter 'trackingEventCreateRequests' is not null or undefined
            assertParamExists('trackEvent', 'trackingEventCreateRequests', trackingEventCreateRequests)
            const localVarPath = `/v2/tracking/evnt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingEventCreateRequests, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Track Link
         * @param {string} workspaceId 
         * @param {TrackingLinksCreateRequest} trackingLinksCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackLink: async (workspaceId: string, trackingLinksCreateRequest: TrackingLinksCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('trackLink', 'workspaceId', workspaceId)
            // verify required parameter 'trackingLinksCreateRequest' is not null or undefined
            assertParamExists('trackLink', 'trackingLinksCreateRequest', trackingLinksCreateRequest)
            const localVarPath = `/v2/tracking/lnk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingLinksCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackingApi - functional programming interface
 * @export
 */
export const TrackingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Search Events
         * @param {string} workspaceId 
         * @param {TrackingEventSearchRequest} trackingEventSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchEvents(workspaceId: string, trackingEventSearchRequest: TrackingEventSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchEvents(workspaceId, trackingEventSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackingApi.searchEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Links
         * @param {string} workspaceId 
         * @param {TrackingLinkSearchRequest} trackingLinkSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchLinks(workspaceId: string, trackingLinkSearchRequest: TrackingLinkSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingLinksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchLinks(workspaceId, trackingLinkSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackingApi.searchLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Sources
         * @param {string} workspaceId 
         * @param {TrackingSourceSearchRequest} trackingSourceSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSources(workspaceId: string, trackingSourceSearchRequest: TrackingSourceSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingSourcesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSources(workspaceId, trackingSourceSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackingApi.searchSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Track Click
         * @param {string} workspaceId 
         * @param {TrackingSourceCreateRequest} trackingSourceCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackClick(workspaceId: string, trackingSourceCreateRequest: TrackingSourceCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackClick(workspaceId, trackingSourceCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackingApi.trackClick']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Track Event
         * @param {string} workspaceId 
         * @param {TrackingEventCreateRequests} trackingEventCreateRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackEvent(workspaceId: string, trackingEventCreateRequests: TrackingEventCreateRequests, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackEvent(workspaceId, trackingEventCreateRequests, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackingApi.trackEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Track Link
         * @param {string} workspaceId 
         * @param {TrackingLinksCreateRequest} trackingLinksCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackLink(workspaceId: string, trackingLinksCreateRequest: TrackingLinksCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackLink(workspaceId, trackingLinksCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackingApi.trackLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TrackingApi - factory interface
 * @export
 */
export const TrackingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackingApiFp(configuration)
    return {
        /**
         * 
         * @summary Search Events
         * @param {TrackingApiSearchEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEvents(requestParameters: TrackingApiSearchEventsRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrackingEventsResponse> {
            return localVarFp.searchEvents(requestParameters.workspaceId, requestParameters.trackingEventSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Links
         * @param {TrackingApiSearchLinksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLinks(requestParameters: TrackingApiSearchLinksRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrackingLinksResponse> {
            return localVarFp.searchLinks(requestParameters.workspaceId, requestParameters.trackingLinkSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Sources
         * @param {TrackingApiSearchSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSources(requestParameters: TrackingApiSearchSourcesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrackingSourcesResponse> {
            return localVarFp.searchSources(requestParameters.workspaceId, requestParameters.trackingSourceSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Track Click
         * @param {TrackingApiTrackClickRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackClick(requestParameters: TrackingApiTrackClickRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.trackClick(requestParameters.workspaceId, requestParameters.trackingSourceCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Track Event
         * @param {TrackingApiTrackEventRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackEvent(requestParameters: TrackingApiTrackEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.trackEvent(requestParameters.workspaceId, requestParameters.trackingEventCreateRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Track Link
         * @param {TrackingApiTrackLinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackLink(requestParameters: TrackingApiTrackLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.trackLink(requestParameters.workspaceId, requestParameters.trackingLinksCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrackingApi - interface
 * @export
 * @interface TrackingApi
 */
export interface TrackingApiInterface {
    /**
     * 
     * @summary Search Events
     * @param {TrackingApiSearchEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApiInterface
     */
    searchEvents(requestParameters: TrackingApiSearchEventsRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrackingEventsResponse>;

    /**
     * 
     * @summary Search Links
     * @param {TrackingApiSearchLinksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApiInterface
     */
    searchLinks(requestParameters: TrackingApiSearchLinksRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrackingLinksResponse>;

    /**
     * 
     * @summary Search Sources
     * @param {TrackingApiSearchSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApiInterface
     */
    searchSources(requestParameters: TrackingApiSearchSourcesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrackingSourcesResponse>;

    /**
     * 
     * @summary Track Click
     * @param {TrackingApiTrackClickRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApiInterface
     */
    trackClick(requestParameters: TrackingApiTrackClickRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Track Event
     * @param {TrackingApiTrackEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApiInterface
     */
    trackEvent(requestParameters: TrackingApiTrackEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Track Link
     * @param {TrackingApiTrackLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApiInterface
     */
    trackLink(requestParameters: TrackingApiTrackLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

}

/**
 * Request parameters for searchEvents operation in TrackingApi.
 * @export
 * @interface TrackingApiSearchEventsRequest
 */
export interface TrackingApiSearchEventsRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingApiSearchEvents
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TrackingEventSearchRequest}
     * @memberof TrackingApiSearchEvents
     */
    readonly trackingEventSearchRequest: TrackingEventSearchRequest
}

/**
 * Request parameters for searchLinks operation in TrackingApi.
 * @export
 * @interface TrackingApiSearchLinksRequest
 */
export interface TrackingApiSearchLinksRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingApiSearchLinks
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TrackingLinkSearchRequest}
     * @memberof TrackingApiSearchLinks
     */
    readonly trackingLinkSearchRequest: TrackingLinkSearchRequest
}

/**
 * Request parameters for searchSources operation in TrackingApi.
 * @export
 * @interface TrackingApiSearchSourcesRequest
 */
export interface TrackingApiSearchSourcesRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingApiSearchSources
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TrackingSourceSearchRequest}
     * @memberof TrackingApiSearchSources
     */
    readonly trackingSourceSearchRequest: TrackingSourceSearchRequest
}

/**
 * Request parameters for trackClick operation in TrackingApi.
 * @export
 * @interface TrackingApiTrackClickRequest
 */
export interface TrackingApiTrackClickRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingApiTrackClick
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TrackingSourceCreateRequest}
     * @memberof TrackingApiTrackClick
     */
    readonly trackingSourceCreateRequest: TrackingSourceCreateRequest
}

/**
 * Request parameters for trackEvent operation in TrackingApi.
 * @export
 * @interface TrackingApiTrackEventRequest
 */
export interface TrackingApiTrackEventRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingApiTrackEvent
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TrackingEventCreateRequests}
     * @memberof TrackingApiTrackEvent
     */
    readonly trackingEventCreateRequests: TrackingEventCreateRequests
}

/**
 * Request parameters for trackLink operation in TrackingApi.
 * @export
 * @interface TrackingApiTrackLinkRequest
 */
export interface TrackingApiTrackLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingApiTrackLink
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TrackingLinksCreateRequest}
     * @memberof TrackingApiTrackLink
     */
    readonly trackingLinksCreateRequest: TrackingLinksCreateRequest
}

/**
 * TrackingApi - object-oriented interface
 * @export
 * @class TrackingApi
 * @extends {BaseAPI}
 */
export class TrackingApi extends BaseAPI implements TrackingApiInterface {
    /**
     * 
     * @summary Search Events
     * @param {TrackingApiSearchEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    public searchEvents(requestParameters: TrackingApiSearchEventsRequest, options?: RawAxiosRequestConfig) {
        return TrackingApiFp(this.configuration).searchEvents(requestParameters.workspaceId, requestParameters.trackingEventSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Links
     * @param {TrackingApiSearchLinksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    public searchLinks(requestParameters: TrackingApiSearchLinksRequest, options?: RawAxiosRequestConfig) {
        return TrackingApiFp(this.configuration).searchLinks(requestParameters.workspaceId, requestParameters.trackingLinkSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Sources
     * @param {TrackingApiSearchSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    public searchSources(requestParameters: TrackingApiSearchSourcesRequest, options?: RawAxiosRequestConfig) {
        return TrackingApiFp(this.configuration).searchSources(requestParameters.workspaceId, requestParameters.trackingSourceSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Track Click
     * @param {TrackingApiTrackClickRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    public trackClick(requestParameters: TrackingApiTrackClickRequest, options?: RawAxiosRequestConfig) {
        return TrackingApiFp(this.configuration).trackClick(requestParameters.workspaceId, requestParameters.trackingSourceCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Track Event
     * @param {TrackingApiTrackEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    public trackEvent(requestParameters: TrackingApiTrackEventRequest, options?: RawAxiosRequestConfig) {
        return TrackingApiFp(this.configuration).trackEvent(requestParameters.workspaceId, requestParameters.trackingEventCreateRequests, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Track Link
     * @param {TrackingApiTrackLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    public trackLink(requestParameters: TrackingApiTrackLinkRequest, options?: RawAxiosRequestConfig) {
        return TrackingApiFp(this.configuration).trackLink(requestParameters.workspaceId, requestParameters.trackingLinksCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WixApi - axios parameter creator
 * @export
 */
export const WixApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Members
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getMembers', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/wix/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WixApi - functional programming interface
 * @export
 */
export const WixApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WixApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Members
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMembers(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WixMembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMembers(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WixApi.getMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WixApi - factory interface
 * @export
 */
export const WixApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WixApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Members
         * @param {WixApiGetMembersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers(requestParameters: WixApiGetMembersRequest, options?: RawAxiosRequestConfig): AxiosPromise<WixMembersResponse> {
            return localVarFp.getMembers(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WixApi - interface
 * @export
 * @interface WixApi
 */
export interface WixApiInterface {
    /**
     * 
     * @summary Get Members
     * @param {WixApiGetMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WixApiInterface
     */
    getMembers(requestParameters: WixApiGetMembersRequest, options?: RawAxiosRequestConfig): AxiosPromise<WixMembersResponse>;

}

/**
 * Request parameters for getMembers operation in WixApi.
 * @export
 * @interface WixApiGetMembersRequest
 */
export interface WixApiGetMembersRequest {
    /**
     * 
     * @type {string}
     * @memberof WixApiGetMembers
     */
    readonly workspaceId: string
}

/**
 * WixApi - object-oriented interface
 * @export
 * @class WixApi
 * @extends {BaseAPI}
 */
export class WixApi extends BaseAPI implements WixApiInterface {
    /**
     * 
     * @summary Get Members
     * @param {WixApiGetMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WixApi
     */
    public getMembers(requestParameters: WixApiGetMembersRequest, options?: RawAxiosRequestConfig) {
        return WixApiFp(this.configuration).getMembers(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WordPressApi - axios parameter creator
 * @export
 */
export const WordPressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Wordpress Post Categories
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostCategories: async (integrationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('getWordpressPostCategories', 'integrationId', integrationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWordpressPostCategories', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/wordpress/{integration_id}/categories`
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Wordpress Post Tags
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostTags: async (integrationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('getWordpressPostTags', 'integrationId', integrationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWordpressPostTags', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/wordpress/{integration_id}/tags`
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Wordpress Sites
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressSites: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWordpressSites', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/wordpress/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WordPressApi - functional programming interface
 * @export
 */
export const WordPressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WordPressApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Wordpress Post Categories
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWordpressPostCategories(integrationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WordPressCategoryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWordpressPostCategories(integrationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WordPressApi.getWordpressPostCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Wordpress Post Tags
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWordpressPostTags(integrationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WordPressTagsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWordpressPostTags(integrationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WordPressApi.getWordpressPostTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Wordpress Sites
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWordpressSites(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WordPressSiteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWordpressSites(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WordPressApi.getWordpressSites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WordPressApi - factory interface
 * @export
 */
export const WordPressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WordPressApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Wordpress Post Categories
         * @param {WordPressApiGetWordpressPostCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostCategories(requestParameters: WordPressApiGetWordpressPostCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressCategoryResponse>> {
            return localVarFp.getWordpressPostCategories(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Wordpress Post Tags
         * @param {WordPressApiGetWordpressPostTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostTags(requestParameters: WordPressApiGetWordpressPostTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressTagsResponse>> {
            return localVarFp.getWordpressPostTags(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Wordpress Sites
         * @param {WordPressApiGetWordpressSitesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressSites(requestParameters: WordPressApiGetWordpressSitesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressSiteResponse>> {
            return localVarFp.getWordpressSites(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WordPressApi - interface
 * @export
 * @interface WordPressApi
 */
export interface WordPressApiInterface {
    /**
     * 
     * @summary Get Wordpress Post Categories
     * @param {WordPressApiGetWordpressPostCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApiInterface
     */
    getWordpressPostCategories(requestParameters: WordPressApiGetWordpressPostCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressCategoryResponse>>;

    /**
     * 
     * @summary Get Wordpress Post Tags
     * @param {WordPressApiGetWordpressPostTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApiInterface
     */
    getWordpressPostTags(requestParameters: WordPressApiGetWordpressPostTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressTagsResponse>>;

    /**
     * 
     * @summary Get Wordpress Sites
     * @param {WordPressApiGetWordpressSitesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApiInterface
     */
    getWordpressSites(requestParameters: WordPressApiGetWordpressSitesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressSiteResponse>>;

}

/**
 * Request parameters for getWordpressPostCategories operation in WordPressApi.
 * @export
 * @interface WordPressApiGetWordpressPostCategoriesRequest
 */
export interface WordPressApiGetWordpressPostCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof WordPressApiGetWordpressPostCategories
     */
    readonly integrationId: string

    /**
     * 
     * @type {string}
     * @memberof WordPressApiGetWordpressPostCategories
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getWordpressPostTags operation in WordPressApi.
 * @export
 * @interface WordPressApiGetWordpressPostTagsRequest
 */
export interface WordPressApiGetWordpressPostTagsRequest {
    /**
     * 
     * @type {string}
     * @memberof WordPressApiGetWordpressPostTags
     */
    readonly integrationId: string

    /**
     * 
     * @type {string}
     * @memberof WordPressApiGetWordpressPostTags
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getWordpressSites operation in WordPressApi.
 * @export
 * @interface WordPressApiGetWordpressSitesRequest
 */
export interface WordPressApiGetWordpressSitesRequest {
    /**
     * 
     * @type {string}
     * @memberof WordPressApiGetWordpressSites
     */
    readonly workspaceId: string
}

/**
 * WordPressApi - object-oriented interface
 * @export
 * @class WordPressApi
 * @extends {BaseAPI}
 */
export class WordPressApi extends BaseAPI implements WordPressApiInterface {
    /**
     * 
     * @summary Get Wordpress Post Categories
     * @param {WordPressApiGetWordpressPostCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApi
     */
    public getWordpressPostCategories(requestParameters: WordPressApiGetWordpressPostCategoriesRequest, options?: RawAxiosRequestConfig) {
        return WordPressApiFp(this.configuration).getWordpressPostCategories(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Wordpress Post Tags
     * @param {WordPressApiGetWordpressPostTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApi
     */
    public getWordpressPostTags(requestParameters: WordPressApiGetWordpressPostTagsRequest, options?: RawAxiosRequestConfig) {
        return WordPressApiFp(this.configuration).getWordpressPostTags(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Wordpress Sites
     * @param {WordPressApiGetWordpressSitesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApi
     */
    public getWordpressSites(requestParameters: WordPressApiGetWordpressSitesRequest, options?: RawAxiosRequestConfig) {
        return WordPressApiFp(this.configuration).getWordpressSites(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkspacesApi - axios parameter creator
 * @export
 */
export const WorkspacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Workspace User
         * @param {string} workspaceId 
         * @param {WorkspaceUserCreateRequest} workspaceUserCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspaceUser: async (workspaceId: string, workspaceUserCreateRequest: WorkspaceUserCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addWorkspaceUser', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceUserCreateRequest' is not null or undefined
            assertParamExists('addWorkspaceUser', 'workspaceUserCreateRequest', workspaceUserCreateRequest)
            const localVarPath = `/v2/workspaces/{workspace_id}/add-member`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUserCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Workspace
         * @param {WorkspaceCreateRequest} workspaceCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace: async (workspaceCreateRequest: WorkspaceCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceCreateRequest' is not null or undefined
            assertParamExists('createWorkspace', 'workspaceCreateRequest', workspaceCreateRequest)
            const localVarPath = `/v2/workspaces/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Workspace
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/v2/workspaces/{workspace_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Workspace User
         * @param {string} workspaceId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceUser: async (workspaceId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspaceUser', 'workspaceId', workspaceId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteWorkspaceUser', 'userId', userId)
            const localVarPath = `/v2/workspaces/{workspace_id}/{user_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Workspace
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/v2/workspaces/{workspace_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search My Workspaces
         * @param {WorkspaceSearchRequest} workspaceSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMyWorkspaces: async (workspaceSearchRequest: WorkspaceSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceSearchRequest' is not null or undefined
            assertParamExists('searchMyWorkspaces', 'workspaceSearchRequest', workspaceSearchRequest)
            const localVarPath = `/v2/workspaces/me/my_workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Workspace Users
         * @param {string} workspaceId 
         * @param {WorkspaceUsersSearchRequest} workspaceUsersSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorkspaceUsers: async (workspaceId: string, workspaceUsersSearchRequest: WorkspaceUsersSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchWorkspaceUsers', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceUsersSearchRequest' is not null or undefined
            assertParamExists('searchWorkspaceUsers', 'workspaceUsersSearchRequest', workspaceUsersSearchRequest)
            const localVarPath = `/v2/workspaces/{workspace_id}/users`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUsersSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfer workspace ownership from current owner to another user. Only workspace owners and sudoers can perform this action. The old owner will become an Administrator.
         * @summary Transfer Workspace Ownership
         * @param {string} workspaceId 
         * @param {string} newOwnerUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferWorkspaceOwnership: async (workspaceId: string, newOwnerUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('transferWorkspaceOwnership', 'workspaceId', workspaceId)
            // verify required parameter 'newOwnerUserId' is not null or undefined
            assertParamExists('transferWorkspaceOwnership', 'newOwnerUserId', newOwnerUserId)
            const localVarPath = `/v2/workspaces/{workspace_id}/transfer-ownership/{new_owner_user_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"new_owner_user_id"}}`, encodeURIComponent(String(newOwnerUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Workspace
         * @param {string} workspaceId 
         * @param {WorkspaceUpdateRequest} workspaceUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace: async (workspaceId: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceUpdateRequest' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceUpdateRequest', workspaceUpdateRequest)
            const localVarPath = `/v2/workspaces/{workspace_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Workspace User
         * @param {string} workspaceId 
         * @param {string} userId 
         * @param {WorkspaceUserUpdateRequest} workspaceUserUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceUser: async (workspaceId: string, userId: string, workspaceUserUpdateRequest: WorkspaceUserUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspaceUser', 'workspaceId', workspaceId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateWorkspaceUser', 'userId', userId)
            // verify required parameter 'workspaceUserUpdateRequest' is not null or undefined
            assertParamExists('updateWorkspaceUser', 'workspaceUserUpdateRequest', workspaceUserUpdateRequest)
            const localVarPath = `/v2/workspaces/{workspace_id}/{user_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUserUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspacesApi - functional programming interface
 * @export
 */
export const WorkspacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspacesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Workspace User
         * @param {string} workspaceId 
         * @param {WorkspaceUserCreateRequest} workspaceUserCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addWorkspaceUser(workspaceId: string, workspaceUserCreateRequest: WorkspaceUserCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addWorkspaceUser(workspaceId, workspaceUserCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.addWorkspaceUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Workspace
         * @param {WorkspaceCreateRequest} workspaceCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspace(workspaceCreateRequest: WorkspaceCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspace(workspaceCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.createWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Workspace
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspace(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspace(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.deleteWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Workspace User
         * @param {string} workspaceId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceUser(workspaceId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceUser(workspaceId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.deleteWorkspaceUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Workspace
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspace(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspace(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.getWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search My Workspaces
         * @param {WorkspaceSearchRequest} workspaceSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMyWorkspaces(workspaceSearchRequest: WorkspaceSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceRole>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMyWorkspaces(workspaceSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.searchMyWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Workspace Users
         * @param {string} workspaceId 
         * @param {WorkspaceUsersSearchRequest} workspaceUsersSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchWorkspaceUsers(workspaceId: string, workspaceUsersSearchRequest: WorkspaceUsersSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceUserResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchWorkspaceUsers(workspaceId, workspaceUsersSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.searchWorkspaceUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transfer workspace ownership from current owner to another user. Only workspace owners and sudoers can perform this action. The old owner will become an Administrator.
         * @summary Transfer Workspace Ownership
         * @param {string} workspaceId 
         * @param {string} newOwnerUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferWorkspaceOwnership(workspaceId: string, newOwnerUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferWorkspaceOwnership(workspaceId, newOwnerUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.transferWorkspaceOwnership']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Workspace
         * @param {string} workspaceId 
         * @param {WorkspaceUpdateRequest} workspaceUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspace(workspaceId: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspace(workspaceId, workspaceUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.updateWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Workspace User
         * @param {string} workspaceId 
         * @param {string} userId 
         * @param {WorkspaceUserUpdateRequest} workspaceUserUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspaceUser(workspaceId: string, userId: string, workspaceUserUpdateRequest: WorkspaceUserUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceUser(workspaceId, userId, workspaceUserUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.updateWorkspaceUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspacesApi - factory interface
 * @export
 */
export const WorkspacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspacesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Workspace User
         * @param {WorkspacesApiAddWorkspaceUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspaceUser(requestParameters: WorkspacesApiAddWorkspaceUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.addWorkspaceUser(requestParameters.workspaceId, requestParameters.workspaceUserCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Workspace
         * @param {WorkspacesApiCreateWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(requestParameters: WorkspacesApiCreateWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceResponse> {
            return localVarFp.createWorkspace(requestParameters.workspaceCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Workspace
         * @param {WorkspacesApiDeleteWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(requestParameters: WorkspacesApiDeleteWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteWorkspace(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Workspace User
         * @param {WorkspacesApiDeleteWorkspaceUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceUser(requestParameters: WorkspacesApiDeleteWorkspaceUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteWorkspaceUser(requestParameters.workspaceId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Workspace
         * @param {WorkspacesApiGetWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(requestParameters: WorkspacesApiGetWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceResponse> {
            return localVarFp.getWorkspace(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search My Workspaces
         * @param {WorkspacesApiSearchMyWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMyWorkspaces(requestParameters: WorkspacesApiSearchMyWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceRole>> {
            return localVarFp.searchMyWorkspaces(requestParameters.workspaceSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Workspace Users
         * @param {WorkspacesApiSearchWorkspaceUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorkspaceUsers(requestParameters: WorkspacesApiSearchWorkspaceUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceUserResponse>> {
            return localVarFp.searchWorkspaceUsers(requestParameters.workspaceId, requestParameters.workspaceUsersSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Transfer workspace ownership from current owner to another user. Only workspace owners and sudoers can perform this action. The old owner will become an Administrator.
         * @summary Transfer Workspace Ownership
         * @param {WorkspacesApiTransferWorkspaceOwnershipRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferWorkspaceOwnership(requestParameters: WorkspacesApiTransferWorkspaceOwnershipRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.transferWorkspaceOwnership(requestParameters.workspaceId, requestParameters.newOwnerUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Workspace
         * @param {WorkspacesApiUpdateWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace(requestParameters: WorkspacesApiUpdateWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.updateWorkspace(requestParameters.workspaceId, requestParameters.workspaceUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Workspace User
         * @param {WorkspacesApiUpdateWorkspaceUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceUser(requestParameters: WorkspacesApiUpdateWorkspaceUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.updateWorkspaceUser(requestParameters.workspaceId, requestParameters.userId, requestParameters.workspaceUserUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspacesApi - interface
 * @export
 * @interface WorkspacesApi
 */
export interface WorkspacesApiInterface {
    /**
     * 
     * @summary Add Workspace User
     * @param {WorkspacesApiAddWorkspaceUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    addWorkspaceUser(requestParameters: WorkspacesApiAddWorkspaceUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Create Workspace
     * @param {WorkspacesApiCreateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    createWorkspace(requestParameters: WorkspacesApiCreateWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceResponse>;

    /**
     * 
     * @summary Delete Workspace
     * @param {WorkspacesApiDeleteWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    deleteWorkspace(requestParameters: WorkspacesApiDeleteWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Delete Workspace User
     * @param {WorkspacesApiDeleteWorkspaceUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    deleteWorkspaceUser(requestParameters: WorkspacesApiDeleteWorkspaceUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Get Workspace
     * @param {WorkspacesApiGetWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    getWorkspace(requestParameters: WorkspacesApiGetWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceResponse>;

    /**
     * 
     * @summary Search My Workspaces
     * @param {WorkspacesApiSearchMyWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    searchMyWorkspaces(requestParameters: WorkspacesApiSearchMyWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceRole>>;

    /**
     * 
     * @summary Search Workspace Users
     * @param {WorkspacesApiSearchWorkspaceUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    searchWorkspaceUsers(requestParameters: WorkspacesApiSearchWorkspaceUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceUserResponse>>;

    /**
     * Transfer workspace ownership from current owner to another user. Only workspace owners and sudoers can perform this action. The old owner will become an Administrator.
     * @summary Transfer Workspace Ownership
     * @param {WorkspacesApiTransferWorkspaceOwnershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    transferWorkspaceOwnership(requestParameters: WorkspacesApiTransferWorkspaceOwnershipRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Update Workspace
     * @param {WorkspacesApiUpdateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    updateWorkspace(requestParameters: WorkspacesApiUpdateWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Update Workspace User
     * @param {WorkspacesApiUpdateWorkspaceUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    updateWorkspaceUser(requestParameters: WorkspacesApiUpdateWorkspaceUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

}

/**
 * Request parameters for addWorkspaceUser operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiAddWorkspaceUserRequest
 */
export interface WorkspacesApiAddWorkspaceUserRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiAddWorkspaceUser
     */
    readonly workspaceId: string

    /**
     * 
     * @type {WorkspaceUserCreateRequest}
     * @memberof WorkspacesApiAddWorkspaceUser
     */
    readonly workspaceUserCreateRequest: WorkspaceUserCreateRequest
}

/**
 * Request parameters for createWorkspace operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiCreateWorkspaceRequest
 */
export interface WorkspacesApiCreateWorkspaceRequest {
    /**
     * 
     * @type {WorkspaceCreateRequest}
     * @memberof WorkspacesApiCreateWorkspace
     */
    readonly workspaceCreateRequest: WorkspaceCreateRequest
}

/**
 * Request parameters for deleteWorkspace operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiDeleteWorkspaceRequest
 */
export interface WorkspacesApiDeleteWorkspaceRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiDeleteWorkspace
     */
    readonly workspaceId: string
}

/**
 * Request parameters for deleteWorkspaceUser operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiDeleteWorkspaceUserRequest
 */
export interface WorkspacesApiDeleteWorkspaceUserRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiDeleteWorkspaceUser
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiDeleteWorkspaceUser
     */
    readonly userId: string
}

/**
 * Request parameters for getWorkspace operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiGetWorkspaceRequest
 */
export interface WorkspacesApiGetWorkspaceRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiGetWorkspace
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchMyWorkspaces operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiSearchMyWorkspacesRequest
 */
export interface WorkspacesApiSearchMyWorkspacesRequest {
    /**
     * 
     * @type {WorkspaceSearchRequest}
     * @memberof WorkspacesApiSearchMyWorkspaces
     */
    readonly workspaceSearchRequest: WorkspaceSearchRequest
}

/**
 * Request parameters for searchWorkspaceUsers operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiSearchWorkspaceUsersRequest
 */
export interface WorkspacesApiSearchWorkspaceUsersRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiSearchWorkspaceUsers
     */
    readonly workspaceId: string

    /**
     * 
     * @type {WorkspaceUsersSearchRequest}
     * @memberof WorkspacesApiSearchWorkspaceUsers
     */
    readonly workspaceUsersSearchRequest: WorkspaceUsersSearchRequest
}

/**
 * Request parameters for transferWorkspaceOwnership operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiTransferWorkspaceOwnershipRequest
 */
export interface WorkspacesApiTransferWorkspaceOwnershipRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiTransferWorkspaceOwnership
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiTransferWorkspaceOwnership
     */
    readonly newOwnerUserId: string
}

/**
 * Request parameters for updateWorkspace operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiUpdateWorkspaceRequest
 */
export interface WorkspacesApiUpdateWorkspaceRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiUpdateWorkspace
     */
    readonly workspaceId: string

    /**
     * 
     * @type {WorkspaceUpdateRequest}
     * @memberof WorkspacesApiUpdateWorkspace
     */
    readonly workspaceUpdateRequest: WorkspaceUpdateRequest
}

/**
 * Request parameters for updateWorkspaceUser operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiUpdateWorkspaceUserRequest
 */
export interface WorkspacesApiUpdateWorkspaceUserRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiUpdateWorkspaceUser
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiUpdateWorkspaceUser
     */
    readonly userId: string

    /**
     * 
     * @type {WorkspaceUserUpdateRequest}
     * @memberof WorkspacesApiUpdateWorkspaceUser
     */
    readonly workspaceUserUpdateRequest: WorkspaceUserUpdateRequest
}

/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class WorkspacesApi
 * @extends {BaseAPI}
 */
export class WorkspacesApi extends BaseAPI implements WorkspacesApiInterface {
    /**
     * 
     * @summary Add Workspace User
     * @param {WorkspacesApiAddWorkspaceUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public addWorkspaceUser(requestParameters: WorkspacesApiAddWorkspaceUserRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).addWorkspaceUser(requestParameters.workspaceId, requestParameters.workspaceUserCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Workspace
     * @param {WorkspacesApiCreateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public createWorkspace(requestParameters: WorkspacesApiCreateWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).createWorkspace(requestParameters.workspaceCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Workspace
     * @param {WorkspacesApiDeleteWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public deleteWorkspace(requestParameters: WorkspacesApiDeleteWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).deleteWorkspace(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Workspace User
     * @param {WorkspacesApiDeleteWorkspaceUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public deleteWorkspaceUser(requestParameters: WorkspacesApiDeleteWorkspaceUserRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).deleteWorkspaceUser(requestParameters.workspaceId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Workspace
     * @param {WorkspacesApiGetWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public getWorkspace(requestParameters: WorkspacesApiGetWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).getWorkspace(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search My Workspaces
     * @param {WorkspacesApiSearchMyWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public searchMyWorkspaces(requestParameters: WorkspacesApiSearchMyWorkspacesRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).searchMyWorkspaces(requestParameters.workspaceSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Workspace Users
     * @param {WorkspacesApiSearchWorkspaceUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public searchWorkspaceUsers(requestParameters: WorkspacesApiSearchWorkspaceUsersRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).searchWorkspaceUsers(requestParameters.workspaceId, requestParameters.workspaceUsersSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transfer workspace ownership from current owner to another user. Only workspace owners and sudoers can perform this action. The old owner will become an Administrator.
     * @summary Transfer Workspace Ownership
     * @param {WorkspacesApiTransferWorkspaceOwnershipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public transferWorkspaceOwnership(requestParameters: WorkspacesApiTransferWorkspaceOwnershipRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).transferWorkspaceOwnership(requestParameters.workspaceId, requestParameters.newOwnerUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Workspace
     * @param {WorkspacesApiUpdateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public updateWorkspace(requestParameters: WorkspacesApiUpdateWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).updateWorkspace(requestParameters.workspaceId, requestParameters.workspaceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Workspace User
     * @param {WorkspacesApiUpdateWorkspaceUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public updateWorkspaceUser(requestParameters: WorkspacesApiUpdateWorkspaceUserRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).updateWorkspaceUser(requestParameters.workspaceId, requestParameters.userId, requestParameters.workspaceUserUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



