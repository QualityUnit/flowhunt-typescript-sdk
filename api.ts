/* tslint:disable */
/* eslint-disable */
/**
 * FlowHunt
 * FlowHunt API
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddOnAddRequest
 */
export interface AddOnAddRequest {
    /**
     * 
     * @type {string}
     * @memberof AddOnAddRequest
     */
    'proration_behavior'?: AddOnAddRequestProrationBehaviorEnum | null;
    /**
     * 
     * @type {number}
     * @memberof AddOnAddRequest
     */
    'quantity'?: number | null;
}

export const AddOnAddRequestProrationBehaviorEnum = {
    CreateProrations: 'create_prorations',
    None: 'none'
} as const;

export type AddOnAddRequestProrationBehaviorEnum = typeof AddOnAddRequestProrationBehaviorEnum[keyof typeof AddOnAddRequestProrationBehaviorEnum];

/**
 * 
 * @export
 * @interface AllFlowsSearchRequest
 */
export interface AllFlowsSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof AllFlowsSearchRequest
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiKeyCreateRequest
 */
export interface ApiKeyCreateRequest {
    /**
     * User defined name of the API key
     * @type {string}
     * @memberof ApiKeyCreateRequest
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyCreateRequest
     */
    'valid_to'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiKeyResponse
 */
export interface ApiKeyResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'workspace_id': string;
    /**
     * API Key ID
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'api_key_id': string;
    /**
     * Name of the API key
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'display_name': string;
    /**
     * Masked API Key
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'mask': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'last_used'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'valid_to'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiKeySearchRequest
 */
export interface ApiKeySearchRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeySearchRequest
     */
    'api_key_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiKeySearchRequest
     */
    'display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiKeySearchRequest
     */
    'mask'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiKeyUpdateRequest
 */
export interface ApiKeyUpdateRequest {
    /**
     * User defined name of the API key
     * @type {string}
     * @memberof ApiKeyUpdateRequest
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyUpdateRequest
     */
    'valid_to'?: string | null;
}
/**
 * 
 * @export
 * @interface AppUrlInput
 */
export interface AppUrlInput {
    /**
     * 
     * @type {Array<any>}
     * @memberof AppUrlInput
     */
    'parsed_url'?: Array<any>;
    /**
     * The URL.
     * @type {string}
     * @memberof AppUrlInput
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface AppUrlOutput
 */
export interface AppUrlOutput {
    /**
     * The URL.
     * @type {string}
     * @memberof AppUrlOutput
     */
    'url': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AspecRatio = {
    _11: '1:1',
    _169: '16:9',
    _219: '21:9',
    _32: '3:2',
    _23: '2:3',
    _45: '4:5',
    _54: '5:4',
    _34: '3:4',
    _43: '4:3',
    _916: '9:16',
    _921: '9:21'
} as const;

export type AspecRatio = typeof AspecRatio[keyof typeof AspecRatio];


/**
 * 
 * @export
 * @enum {string}
 */

export const BaseFoundationModel = {
    FluxDev: 'flux-dev',
    FluxSchnell: 'flux-schnell',
    StableDiffusion35Medium: 'stable-diffusion-3.5-medium',
    StableDiffusion35LargeTurbo: 'stable-diffusion-3.5-large-turbo',
    StableDiffusion35Large: 'stable-diffusion-3.5-large',
    Imagen3: 'imagen-3',
    Imagen3Fast: 'imagen-3-fast',
    IdeogramV2: 'ideogram-v2',
    IdeogramV2Turbo: 'ideogram-v2-turbo',
    IdeogramV2a: 'ideogram-v2a',
    IdeogramV2aTurbo: 'ideogram-v2a-turbo',
    IdeogramV3Quality: 'ideogram-v3-quality',
    IdeogramV3Turbo: 'ideogram-v3-turbo',
    IdeogramV3Balanced: 'ideogram-v3-balanced',
    GptImage1: 'gpt-image-1',
    NanoBanana: 'nano-banana',
    Gemini25Flash: 'gemini-2.5-flash',
    QwenImageEditPlus: 'qwen-image-edit-plus',
    QwenImage: 'qwen-image',
    Wan22AnimateReplace: 'wan-2.2-animate-replace',
    Wan25T2vFast: 'wan-2.5-t2v-fast',
    Wan22AnimateAnimation: 'wan-2.2-animate-animation',
    Wan25I2vFast: 'wan-2.5-i2v-fast',
    Wan25I2v: 'wan-2.5-i2v'
} as const;

export type BaseFoundationModel = typeof BaseFoundationModel[keyof typeof BaseFoundationModel];


/**
 * 
 * @export
 * @enum {string}
 */

export const BillingProvider = {
    S: 'S',
    H: 'H'
} as const;

export type BillingProvider = typeof BillingProvider[keyof typeof BillingProvider];


/**
 * 
 * @export
 * @enum {string}
 */

export const BoolChar = {
    Y: 'Y',
    N: 'N'
} as const;

export type BoolChar = typeof BoolChar[keyof typeof BoolChar];


/**
 * 
 * @export
 * @enum {string}
 */

export const CategoryType = {
    M: 'M',
    D: 'D'
} as const;

export type CategoryType = typeof CategoryType[keyof typeof CategoryType];


/**
 * 
 * @export
 * @interface ChartSessionDurationResponse
 */
export interface ChartSessionDurationResponse {
    /**
     * 
     * @type {Array<PerDaySessionDurationResponse>}
     * @memberof ChartSessionDurationResponse
     */
    'per_day'?: Array<PerDaySessionDurationResponse> | null;
}
/**
 * 
 * @export
 * @interface ChartsFeedbackRequest
 */
export interface ChartsFeedbackRequest {
    /**
     * 
     * @type {string}
     * @memberof ChartsFeedbackRequest
     */
    'start_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChartsFeedbackRequest
     */
    'end_date'?: string | null;
}
/**
 * 
 * @export
 * @interface ChatbotCreateRequest
 */
export interface ChatbotCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'description'?: string | null;
    /**
     * Chatbot Flow ID
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'flow_id'?: string;
    /**
     * 
     * @type {ChatbotStatus}
     * @memberof ChatbotCreateRequest
     */
    'status': ChatbotStatus;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'url_suffix'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'theme'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'max_window_size'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotCreateRequest
     */
    'msg_rpm'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotCreateRequest
     */
    'msg_ip_rpm'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chatbot_description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotCreateRequest
     */
    'show_chatbot_header'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chat_bubble_bg_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chat_bubble_icon_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chat_bubble_img_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chatbot_theme'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chatbot_position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'message_placeholder'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chatbot_header_text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chatbot_header_logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'assistant_avatar_image_url'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotCreateRequest
     */
    'remove_branding'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'chatbot_style'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotCreateRequest
     */
    'session_message_history'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotCreateRequest
     */
    'chatbot_bubble_size'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotCreateRequest
     */
    'message_header_logo_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChatbotCreateRequest
     */
    'popup_messages'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotCreateRequest
     */
    'popup_messages_delay'?: number | null;
}


/**
 * 
 * @export
 * @interface ChatbotResponse
 */
export interface ChatbotResponse {
    /**
     * Workspace id
     * @type {string}
     * @memberof ChatbotResponse
     */
    'workspace_id': string;
    /**
     * Chatbot id
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chatbot_id': string;
    /**
     * Tenant name
     * @type {string}
     * @memberof ChatbotResponse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'description'?: string | null;
    /**
     * Flow ID
     * @type {string}
     * @memberof ChatbotResponse
     */
    'flow_id': string;
    /**
     * 
     * @type {ChatbotStatus}
     * @memberof ChatbotResponse
     */
    'status': ChatbotStatus | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'url_suffix'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'theme'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'max_window_size'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotResponse
     */
    'msg_rpm'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotResponse
     */
    'msg_ip_rpm'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chatbot_description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotResponse
     */
    'show_chatbot_header'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chat_bubble_bg_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chat_bubble_icon_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chat_bubble_img_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chatbot_theme'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chatbot_position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'message_placeholder'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chatbot_header_text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chatbot_header_logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'assistant_avatar_image_url'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotResponse
     */
    'remove_branding'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'chatbot_style'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotResponse
     */
    'session_message_history'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotResponse
     */
    'chatbot_bubble_size'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotResponse
     */
    'message_header_logo_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChatbotResponse
     */
    'popup_messages'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotResponse
     */
    'popup_messages_delay'?: number | null;
}


/**
 * 
 * @export
 * @interface ChatbotSearchRequest
 */
export interface ChatbotSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotSearchRequest
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotSearchRequest
     */
    'status'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Pagination}
     * @memberof ChatbotSearchRequest
     */
    'pagination'?: Pagination | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ChatbotStatus = {
    A: 'A',
    I: 'I'
} as const;

export type ChatbotStatus = typeof ChatbotStatus[keyof typeof ChatbotStatus];


/**
 * 
 * @export
 * @interface ChatbotUpdateRequest
 */
export interface ChatbotUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'flow_id'?: string | null;
    /**
     * 
     * @type {ChatbotStatus}
     * @memberof ChatbotUpdateRequest
     */
    'status'?: ChatbotStatus | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'url_suffix'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'theme'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'max_window_size'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotUpdateRequest
     */
    'msg_rpm'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotUpdateRequest
     */
    'msg_ip_rpm'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chatbot_description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotUpdateRequest
     */
    'show_chatbot_header'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chat_bubble_bg_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chat_bubble_icon_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chat_bubble_img_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chatbot_theme'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chatbot_position'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'message_placeholder'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chatbot_header_text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chatbot_header_logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'assistant_avatar_image_url'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotUpdateRequest
     */
    'remove_branding'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'chatbot_style'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatbotUpdateRequest
     */
    'session_message_history'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotUpdateRequest
     */
    'chatbot_bubble_size'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ChatbotUpdateRequest
     */
    'message_header_logo_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChatbotUpdateRequest
     */
    'popup_messages'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ChatbotUpdateRequest
     */
    'popup_messages_delay'?: number | null;
}


/**
 * 
 * @export
 * @interface CheckoutCreateRequest
 */
export interface CheckoutCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateRequest
     */
    'plan_id': string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateRequest
     */
    'interval': CheckoutCreateRequestIntervalEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CheckoutCreateRequest
     */
    'recurring'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateRequest
     */
    'workspace_id': string;
}

export const CheckoutCreateRequestIntervalEnum = {
    Monthly: 'monthly',
    Yearly: 'yearly'
} as const;

export type CheckoutCreateRequestIntervalEnum = typeof CheckoutCreateRequestIntervalEnum[keyof typeof CheckoutCreateRequestIntervalEnum];

/**
 * 
 * @export
 * @interface CommunityImageGenerationsResponse
 */
export interface CommunityImageGenerationsResponse {
    /**
     * 
     * @type {string}
     * @memberof CommunityImageGenerationsResponse
     */
    'generated_image': string;
    /**
     * 
     * @type {string}
     * @memberof CommunityImageGenerationsResponse
     */
    'prompt': string;
}
/**
 * 
 * @export
 * @interface Completed
 */
export interface Completed {
    /**
     * 
     * @type {string}
     * @memberof Completed
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface CreditBalanceResponse
 */
export interface CreditBalanceResponse {
    /**
     * Current User ID
     * @type {string}
     * @memberof CreditBalanceResponse
     */
    'user_id': string;
    /**
     * Amount of remaining credits
     * @type {number}
     * @memberof CreditBalanceResponse
     */
    'credits': number;
}
/**
 * 
 * @export
 * @interface CreditDailyTransactionResponse
 */
export interface CreditDailyTransactionResponse {
    /**
     * Transactions from date
     * @type {string}
     * @memberof CreditDailyTransactionResponse
     */
    'created_at': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof CreditDailyTransactionResponse
     */
    'workspace_id': string;
    /**
     * Transaction type
     * @type {TransactionType}
     * @memberof CreditDailyTransactionResponse
     */
    'transaction_type': TransactionType;
    /**
     * Amount of credits
     * @type {number}
     * @memberof CreditDailyTransactionResponse
     */
    'amount': number;
    /**
     * Number of transactions
     * @type {number}
     * @memberof CreditDailyTransactionResponse
     */
    'cnt': number;
}


/**
 * 
 * @export
 * @interface CreditDailyTransactionSearchRequest
 */
export interface CreditDailyTransactionSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditDailyTransactionSearchRequest
     */
    'created_at_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreditDailyTransactionSearchRequest
     */
    'created_at_to'?: string | null;
    /**
     * 
     * @type {TransactionType}
     * @memberof CreditDailyTransactionSearchRequest
     */
    'transaction_type'?: TransactionType | null;
    /**
     * 
     * @type {number}
     * @memberof CreditDailyTransactionSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Pagination}
     * @memberof CreditDailyTransactionSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * 
 * @export
 * @interface CreditTransactionResponse
 */
export interface CreditTransactionResponse {
    /**
     * Transaction ID
     * @type {string}
     * @memberof CreditTransactionResponse
     */
    'transaction_id': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof CreditTransactionResponse
     */
    'workspace_id': string;
    /**
     * User ID or user to whom is transaction assigned
     * @type {string}
     * @memberof CreditTransactionResponse
     */
    'user_id': string;
    /**
     * Transaction creation date
     * @type {string}
     * @memberof CreditTransactionResponse
     */
    'created_at': string;
    /**
     * Transaction type
     * @type {TransactionType}
     * @memberof CreditTransactionResponse
     */
    'transaction_type': TransactionType;
    /**
     * Context ID - identification of transaction context - eg chatbot id
     * @type {string}
     * @memberof CreditTransactionResponse
     */
    'context_id': string;
    /**
     * Context description - description of transaction context
     * @type {string}
     * @memberof CreditTransactionResponse
     */
    'context_desc'?: string;
    /**
     * Amount of credits
     * @type {number}
     * @memberof CreditTransactionResponse
     */
    'amount': number;
}


/**
 * 
 * @export
 * @interface CreditTransactionSearchRequest
 */
export interface CreditTransactionSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditTransactionSearchRequest
     */
    'transaction_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreditTransactionSearchRequest
     */
    'created_at_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreditTransactionSearchRequest
     */
    'created_at_to'?: string | null;
    /**
     * 
     * @type {TransactionType}
     * @memberof CreditTransactionSearchRequest
     */
    'transaction_type'?: TransactionType | null;
    /**
     * 
     * @type {string}
     * @memberof CreditTransactionSearchRequest
     */
    'context_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreditTransactionSearchRequest
     */
    'context_desc'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreditTransactionSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Pagination}
     * @memberof CreditTransactionSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * 
 * @export
 * @interface CustomerDataRequestPayload
 */
export interface CustomerDataRequestPayload {
    /**
     * 
     * @type {number}
     * @memberof CustomerDataRequestPayload
     */
    'shop_id': number;
    /**
     * 
     * @type {string}
     * @memberof CustomerDataRequestPayload
     */
    'shop_domain': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CustomerDataRequestPayload
     */
    'orders_requested': Array<number>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CustomerDataRequestPayload
     */
    'customer': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CustomerDataRequestPayload
     */
    'data_request': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CustomerRedactPayload
 */
export interface CustomerRedactPayload {
    /**
     * 
     * @type {number}
     * @memberof CustomerRedactPayload
     */
    'shop_id': number;
    /**
     * 
     * @type {string}
     * @memberof CustomerRedactPayload
     */
    'shop_domain': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CustomerRedactPayload
     */
    'customer': { [key: string]: any; };
    /**
     * 
     * @type {Array<number>}
     * @memberof CustomerRedactPayload
     */
    'orders_to_redact': Array<number>;
}
/**
 * Document linked to vector
 * @export
 * @interface Data
 */
export interface Data {
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'schedule_id': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'domain_id': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'url_id': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'last_text_timestamp': string;
    /**
     * 
     * @type {UrlScreenshotResponse}
     * @memberof Data
     */
    'page_screenshot': UrlScreenshotResponse;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'url_title': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'url_meta_description': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'url_og_image': string;
    /**
     * 
     * @type {boolean}
     * @memberof Data
     */
    'is_original_url': boolean;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'dest_url_id': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'created_at': string;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof Data
     */
    'url_text': Array<{ [key: string]: string; }>;
    /**
     * FAQ ID
     * @type {string}
     * @memberof Data
     */
    'faq_id': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof Data
     */
    'workspace_id': string;
    /**
     * Category ID
     * @type {string}
     * @memberof Data
     */
    'cat_id': string;
    /**
     * Question
     * @type {string}
     * @memberof Data
     */
    'question': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'answer'?: string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'parent_faq_id'?: string;
    /**
     * Document status
     * @type {string}
     * @memberof Data
     */
    'status': string;
    /**
     * Document updated at
     * @type {string}
     * @memberof Data
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'indexed_at'?: string;
    /**
     * Document ID
     * @type {string}
     * @memberof Data
     */
    'doc_id': string;
    /**
     * Document name
     * @type {string}
     * @memberof Data
     */
    'doc_name': string;
    /**
     * Document type
     * @type {string}
     * @memberof Data
     */
    'doc_type': string;
    /**
     * User status
     * @type {string}
     * @memberof Data
     */
    'user_status': string;
}
/**
 * 
 * @export
 * @interface DeleteNodeRequest
 */
export interface DeleteNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteNodeRequest
     */
    'cat_id'?: string | null;
}
/**
 * 
 * @export
 * @interface DocumentCategoryCreateRequest
 */
export interface DocumentCategoryCreateRequest {
    /**
     * Category name
     * @type {string}
     * @memberof DocumentCategoryCreateRequest
     */
    'cat_name': string;
    /**
     * Category color
     * @type {string}
     * @memberof DocumentCategoryCreateRequest
     */
    'cat_color': string;
    /**
     * 
     * @type {CategoryType}
     * @memberof DocumentCategoryCreateRequest
     */
    'cat_type'?: CategoryType | null;
}


/**
 * 
 * @export
 * @interface DocumentCategoryResponse
 */
export interface DocumentCategoryResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof DocumentCategoryResponse
     */
    'workspace_id': string;
    /**
     * Category ID
     * @type {string}
     * @memberof DocumentCategoryResponse
     */
    'cat_id': string;
    /**
     * Category name
     * @type {string}
     * @memberof DocumentCategoryResponse
     */
    'cat_name': string;
    /**
     * Category color
     * @type {string}
     * @memberof DocumentCategoryResponse
     */
    'cat_color': string;
}
/**
 * 
 * @export
 * @interface DocumentCategorySearchRequest
 */
export interface DocumentCategorySearchRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentCategorySearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentCategorySearchRequest
     */
    'cat_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentCategorySearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {CategoryType}
     * @memberof DocumentCategorySearchRequest
     */
    'cat_type'?: CategoryType | null;
}


/**
 * 
 * @export
 * @interface DocumentCategoryUpdateRequest
 */
export interface DocumentCategoryUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentCategoryUpdateRequest
     */
    'cat_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentCategoryUpdateRequest
     */
    'cat_color'?: string | null;
}
/**
 * 
 * @export
 * @interface DocumentContent
 */
export interface DocumentContent {
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'img_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentContent
     */
    'status_code'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentContent
     */
    'created_at'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentContent
     */
    'published_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'doc_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'lang'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'content_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'encoding'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'apparent_encoding'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<Array<any>>}
     * @memberof DocumentContent
     */
    'content'?: Array<Array<any>> | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DocumentContent
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentContent
     */
    'alt_content'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'content_hash'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'author'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'channel_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'channel_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContent
     */
    'channel_title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentContent
     */
    'duration'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentContent
     */
    'keywords'?: Array<string> | null;
    /**
     * 
     * @type {DocumentType}
     * @memberof DocumentContent
     */
    'doc_type'?: DocumentType | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentContent
     */
    'credits'?: number | null;
}


/**
 * 
 * @export
 * @interface DocumentContentResponse
 */
export interface DocumentContentResponse {
    /**
     * Task ID
     * @type {string}
     * @memberof DocumentContentResponse
     */
    'id': string;
    /**
     * Task status
     * @type {TaskStatus}
     * @memberof DocumentContentResponse
     */
    'status': TaskStatus;
    /**
     * 
     * @type {DocumentContent}
     * @memberof DocumentContentResponse
     */
    'result'?: DocumentContent | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentContentResponse
     */
    'error_message'?: string | null;
}


/**
 * 
 * @export
 * @interface DocumentResponse
 */
export interface DocumentResponse {
    /**
     * Document ID
     * @type {string}
     * @memberof DocumentResponse
     */
    'doc_id': string;
    /**
     * Category ID
     * @type {string}
     * @memberof DocumentResponse
     */
    'cat_id': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof DocumentResponse
     */
    'workspace_id': string;
    /**
     * Document name
     * @type {string}
     * @memberof DocumentResponse
     */
    'doc_name': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    'url'?: string | null;
    /**
     * Document type
     * @type {string}
     * @memberof DocumentResponse
     */
    'doc_type': string;
    /**
     * User status
     * @type {string}
     * @memberof DocumentResponse
     */
    'user_status': string;
    /**
     * Document status
     * @type {string}
     * @memberof DocumentResponse
     */
    'status': string;
    /**
     * Document updated at
     * @type {string}
     * @memberof DocumentResponse
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface DocumentSearchRequest
 */
export interface DocumentSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentSearchRequest
     */
    'doc_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSearchRequest
     */
    'doc_name'?: string | null;
    /**
     * 
     * @type {DocumentType}
     * @memberof DocumentSearchRequest
     */
    'doc_type'?: DocumentType | null;
    /**
     * 
     * @type {DocumentStatus}
     * @memberof DocumentSearchRequest
     */
    'status'?: DocumentStatus | null;
    /**
     * 
     * @type {UserDocumentStatus}
     * @memberof DocumentSearchRequest
     */
    'user_status'?: UserDocumentStatus | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSearchRequest
     */
    'updated_at_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSearchRequest
     */
    'updated_at_to'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Pagination}
     * @memberof DocumentSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * 
 * @export
 * @interface DocumentSimilarityRequest
 */
export interface DocumentSimilarityRequest {
    /**
     * 
     * @type {VectorDocumentType}
     * @memberof DocumentSimilarityRequest
     */
    'document_type'?: VectorDocumentType | null;
    /**
     * 
     * @type {PointerType}
     * @memberof DocumentSimilarityRequest
     */
    'pointer_type'?: PointerType | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityRequest
     */
    'schema_type'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityRequest
     */
    'score_trheshold'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentSimilarityRequest
     */
    'with_vectors'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityRequest
     */
    'pointer_position_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityRequest
     */
    'pointer_position_to'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityRequest
     */
    'vector_id_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityRequest
     */
    'vector_id_to'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityRequest
     */
    'filter_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentSimilarityRequest
     */
    'filter_domains'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityRequest
     */
    'document_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityRequest
     */
    'faq_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityRequest
     */
    'url_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityRequest
     */
    'url'?: string | null;
}


/**
 * 
 * @export
 * @interface DocumentSimilarityTaskRequest
 */
export interface DocumentSimilarityTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityTaskRequest
     */
    'post_back_url'?: string | null;
    /**
     * 
     * @type {VectorDocumentType}
     * @memberof DocumentSimilarityTaskRequest
     */
    'document_type'?: VectorDocumentType | null;
    /**
     * 
     * @type {PointerType}
     * @memberof DocumentSimilarityTaskRequest
     */
    'pointer_type'?: PointerType | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityTaskRequest
     */
    'schema_type'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityTaskRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityTaskRequest
     */
    'score_trheshold'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentSimilarityTaskRequest
     */
    'with_vectors'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityTaskRequest
     */
    'pointer_position_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityTaskRequest
     */
    'pointer_position_to'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityTaskRequest
     */
    'vector_id_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentSimilarityTaskRequest
     */
    'vector_id_to'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityTaskRequest
     */
    'filter_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentSimilarityTaskRequest
     */
    'filter_domains'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityTaskRequest
     */
    'document_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityTaskRequest
     */
    'faq_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityTaskRequest
     */
    'url_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentSimilarityTaskRequest
     */
    'url'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DocumentStatus = {
    N: 'N',
    U: 'U',
    T: 'T',
    I: 'I',
    F: 'F'
} as const;

export type DocumentStatus = typeof DocumentStatus[keyof typeof DocumentStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const DocumentType = {
    Pdf: 'PDF',
    Docx: 'DOCX',
    Xlsx: 'XLSX',
    Pptx: 'PPTX',
    Md: 'MD',
    Txt: 'TXT',
    Html: 'HTML',
    Yt: 'YT',
    Un: 'UN',
    Mp3: 'MP3',
    Flac: 'FLAC',
    Mp4: 'MP4',
    Mpeg: 'MPEG',
    Mpga: 'MPGA',
    M4A: 'M4A',
    Ogg: 'OGG',
    Wav: 'WAV',
    Webm: 'WEBM',
    Jpeg: 'JPEG',
    Jpg: 'JPG',
    Png: 'PNG',
    Gif: 'GIF',
    Webp: 'WEBP',
    Csv: 'CSV',
    Xml: 'XML',
    Json: 'JSON',
    GoogleDocs: 'GOOGLE_DOCS',
    GoogleSheets: 'GOOGLE_SHEETS',
    RssXml: 'RSS_XML'
} as const;

export type DocumentType = typeof DocumentType[keyof typeof DocumentType];


/**
 * 
 * @export
 * @interface DocumentUpdateRequest
 */
export interface DocumentUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentUpdateRequest
     */
    'doc_name'?: string | null;
    /**
     * 
     * @type {UserDocumentStatus}
     * @memberof DocumentUpdateRequest
     */
    'user_status'?: UserDocumentStatus | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentUpdateRequest
     */
    'cat_id'?: string | null;
}


/**
 * 
 * @export
 * @interface DriverSuccessResponse
 */
export interface DriverSuccessResponse {
    /**
     * 
     * @type {string}
     * @memberof DriverSuccessResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DriverType = {
    LangfuseDriver: 'langfuse_driver',
    FlowhuntDriver: 'flowhunt_driver',
    PowerBiDriver: 'power_bi_driver'
} as const;

export type DriverType = typeof DriverType[keyof typeof DriverType];


/**
 * 
 * @export
 * @enum {string}
 */

export const FTStatus = {
    P: 'P',
    S: 'S',
    F: 'F',
    N: 'N'
} as const;

export type FTStatus = typeof FTStatus[keyof typeof FTStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const FTType = {
    I: 'I',
    V: 'V'
} as const;

export type FTType = typeof FTType[keyof typeof FTType];


/**
 * 
 * @export
 * @interface FailedFaqItem
 */
export interface FailedFaqItem {
    /**
     * Question that failed to import
     * @type {string}
     * @memberof FailedFaqItem
     */
    'question': string;
    /**
     * Answer (truncated to 200 chars)
     * @type {string}
     * @memberof FailedFaqItem
     */
    'answer': string;
    /**
     * Reason for failure
     * @type {string}
     * @memberof FailedFaqItem
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface FaqCreateRequest
 */
export interface FaqCreateRequest {
    /**
     * Category ID
     * @type {string}
     * @memberof FaqCreateRequest
     */
    'cat_id': string;
    /**
     * Question
     * @type {string}
     * @memberof FaqCreateRequest
     */
    'primary_question': string;
    /**
     * 
     * @type {string}
     * @memberof FaqCreateRequest
     */
    'answer'?: string | null;
    /**
     * Parent FAQ ID if current question points to other answer
     * @type {Array<string>}
     * @memberof FaqCreateRequest
     */
    'secondary_questions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FaqImportResponse
 */
export interface FaqImportResponse {
    /**
     * List of successfully imported FAQs
     * @type {Array<FaqResponse>}
     * @memberof FaqImportResponse
     */
    'successful': Array<FaqResponse>;
    /**
     * List of FAQs that failed to import
     * @type {Array<FailedFaqItem>}
     * @memberof FaqImportResponse
     */
    'failed': Array<FailedFaqItem>;
    /**
     * Total number of FAQs attempted
     * @type {number}
     * @memberof FaqImportResponse
     */
    'total_attempted': number;
    /**
     * Number of successfully imported FAQs
     * @type {number}
     * @memberof FaqImportResponse
     */
    'total_successful': number;
    /**
     * Number of failed FAQs
     * @type {number}
     * @memberof FaqImportResponse
     */
    'total_failed': number;
}
/**
 * 
 * @export
 * @interface FaqResponse
 */
export interface FaqResponse {
    /**
     * FAQ ID
     * @type {string}
     * @memberof FaqResponse
     */
    'faq_id': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof FaqResponse
     */
    'workspace_id': string;
    /**
     * Category ID
     * @type {string}
     * @memberof FaqResponse
     */
    'cat_id': string;
    /**
     * Question
     * @type {string}
     * @memberof FaqResponse
     */
    'question': string;
    /**
     * 
     * @type {string}
     * @memberof FaqResponse
     */
    'answer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FaqResponse
     */
    'parent_faq_id'?: string | null;
    /**
     * FAQ status
     * @type {FaqStatus}
     * @memberof FaqResponse
     */
    'status': FaqStatus;
    /**
     * FAQ updated at
     * @type {string}
     * @memberof FaqResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof FaqResponse
     */
    'indexed_at'?: string | null;
}


/**
 * 
 * @export
 * @interface FaqSearchRequest
 */
export interface FaqSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof FaqSearchRequest
     */
    'faq_id'?: string | null;
    /**
     * 
     * @type {FaqStatus}
     * @memberof FaqSearchRequest
     */
    'status'?: FaqStatus | null;
    /**
     * 
     * @type {string}
     * @memberof FaqSearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FaqSearchRequest
     */
    'question'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FaqSearchRequest
     */
    'answer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FaqSearchRequest
     */
    'parent_faq_id'?: string | null;
    /**
     * 
     * @type {FaqType}
     * @memberof FaqSearchRequest
     */
    'faq_type'?: FaqType | null;
    /**
     * 
     * @type {number}
     * @memberof FaqSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Pagination}
     * @memberof FaqSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FaqStatus = {
    N: 'N',
    U: 'U',
    I: 'I'
} as const;

export type FaqStatus = typeof FaqStatus[keyof typeof FaqStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const FaqType = {
    P: 'P',
    S: 'S'
} as const;

export type FaqType = typeof FaqType[keyof typeof FaqType];


/**
 * 
 * @export
 * @interface FaqUpdateRequest
 */
export interface FaqUpdateRequest {
    /**
     * Category ID
     * @type {string}
     * @memberof FaqUpdateRequest
     */
    'cat_id'?: string;
    /**
     * Question
     * @type {string}
     * @memberof FaqUpdateRequest
     */
    'primary_question'?: string;
    /**
     * Answer formatted as markdow
     * @type {string}
     * @memberof FaqUpdateRequest
     */
    'answer'?: string;
    /**
     * Parent FAQ ID if current question points to other answer
     * @type {Array<string>}
     * @memberof FaqUpdateRequest
     */
    'secondary_questions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FeatureResponse
 */
export interface FeatureResponse {
    /**
     * 
     * @type {string}
     * @memberof FeatureResponse
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureResponse
     */
    'available': boolean;
}
/**
 * 
 * @export
 * @interface FeedbackChartResponse
 */
export interface FeedbackChartResponse {
    /**
     * 
     * @type {Array<PerDayFeedback>}
     * @memberof FeedbackChartResponse
     */
    'per_day'?: Array<PerDayFeedback> | null;
    /**
     * 
     * @type {TotalFeedback}
     * @memberof FeedbackChartResponse
     */
    'totals'?: TotalFeedback | null;
}
/**
 * 
 * @export
 * @interface FileUploadResponse
 */
export interface FileUploadResponse {
    /**
     * Image URL
     * @type {Array<string>}
     * @memberof FileUploadResponse
     */
    'file_urls': Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FlowAssistantAIModel = {
    Claude37Sonnet: 'Claude 3.7 Sonnet',
    Gpt41: 'GPT4.1',
    O4Mini: 'O4 Mini',
    O3Mini: 'O3 Mini'
} as const;

export type FlowAssistantAIModel = typeof FlowAssistantAIModel[keyof typeof FlowAssistantAIModel];


/**
 * 
 * @export
 * @interface FlowAssistantAddComponentMetadata
 */
export interface FlowAssistantAddComponentMetadata {
    /**
     * Action ID
     * @type {string}
     * @memberof FlowAssistantAddComponentMetadata
     */
    'action_id': string;
    /**
     * Component ID
     * @type {string}
     * @memberof FlowAssistantAddComponentMetadata
     */
    'component_id': string;
    /**
     * Component name
     * @type {string}
     * @memberof FlowAssistantAddComponentMetadata
     */
    'component_type': string;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantAddComponentMetadata
     */
    'component_display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantAddComponentMetadata
     */
    'component_icon'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowAssistantAddComponentMetadata
     */
    'parameter_values'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface FlowAssistantAddConnectionMetadata
 */
export interface FlowAssistantAddConnectionMetadata {
    /**
     * Action ID
     * @type {string}
     * @memberof FlowAssistantAddConnectionMetadata
     */
    'action_id': string;
    /**
     * Source component ID
     * @type {string}
     * @memberof FlowAssistantAddConnectionMetadata
     */
    'source_component_id': string;
    /**
     * Target component ID
     * @type {string}
     * @memberof FlowAssistantAddConnectionMetadata
     */
    'target_component_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantAddConnectionMetadata
     */
    'source_field_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantAddConnectionMetadata
     */
    'target_field_name'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowAssistantApplyRejectChangesRequest
 */
export interface FlowAssistantApplyRejectChangesRequest {
    /**
     * The Flow ID currently being enhanced by the AI Agent.
     * @type {string}
     * @memberof FlowAssistantApplyRejectChangesRequest
     */
    'flow_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantApplyRejectChangesRequest
     */
    'action_id'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowAssistantCreateBlankFlowMetadata
 */
export interface FlowAssistantCreateBlankFlowMetadata {
    /**
     * Flow name
     * @type {string}
     * @memberof FlowAssistantCreateBlankFlowMetadata
     */
    'flow_name': string;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantCreateBlankFlowMetadata
     */
    'flow_description'?: string | null;
    /**
     * Flow ID
     * @type {string}
     * @memberof FlowAssistantCreateBlankFlowMetadata
     */
    'flow_id': string;
}
/**
 * 
 * @export
 * @interface FlowAssistantDeleteComponentMetadata
 */
export interface FlowAssistantDeleteComponentMetadata {
    /**
     * Action ID
     * @type {string}
     * @memberof FlowAssistantDeleteComponentMetadata
     */
    'action_id': string;
    /**
     * Component ID
     * @type {string}
     * @memberof FlowAssistantDeleteComponentMetadata
     */
    'component_id': string;
    /**
     * Component name
     * @type {string}
     * @memberof FlowAssistantDeleteComponentMetadata
     */
    'component_type': string;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantDeleteComponentMetadata
     */
    'component_display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantDeleteComponentMetadata
     */
    'component_icon'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowAssistantDeleteConnectionMetadata
 */
export interface FlowAssistantDeleteConnectionMetadata {
    /**
     * Action ID
     * @type {string}
     * @memberof FlowAssistantDeleteConnectionMetadata
     */
    'action_id': string;
    /**
     * Source component ID
     * @type {string}
     * @memberof FlowAssistantDeleteConnectionMetadata
     */
    'source_component_id': string;
    /**
     * Target component ID
     * @type {string}
     * @memberof FlowAssistantDeleteConnectionMetadata
     */
    'target_component_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantDeleteConnectionMetadata
     */
    'source_field_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantDeleteConnectionMetadata
     */
    'target_field_name'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowAssistantInvokeRequest
 */
export interface FlowAssistantInvokeRequest {
    /**
     * The message of the user
     * @type {string}
     * @memberof FlowAssistantInvokeRequest
     */
    'message': string;
    /**
     * 
     * @type {FlowAssistantAIModel}
     * @memberof FlowAssistantInvokeRequest
     */
    'ai_model'?: FlowAssistantAIModel | null;
}


/**
 * 
 * @export
 * @interface FlowAssistantSessionCreateRequest
 */
export interface FlowAssistantSessionCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantSessionCreateRequest
     */
    'context_flow_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof FlowAssistantSessionCreateRequest
     */
    'start_with_welcome_message'?: boolean | null;
}
/**
 * 
 * @export
 * @interface FlowAssistantUpdateComponentMetadata
 */
export interface FlowAssistantUpdateComponentMetadata {
    /**
     * Action ID
     * @type {string}
     * @memberof FlowAssistantUpdateComponentMetadata
     */
    'action_id': string;
    /**
     * Component ID
     * @type {string}
     * @memberof FlowAssistantUpdateComponentMetadata
     */
    'component_id': string;
    /**
     * Component name
     * @type {string}
     * @memberof FlowAssistantUpdateComponentMetadata
     */
    'component_type': string;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantUpdateComponentMetadata
     */
    'component_display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantUpdateComponentMetadata
     */
    'component_icon'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowAssistantUpdateComponentMetadata
     */
    'parameter_values'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FlowBranch = {
    P: 'P',
    D: 'D'
} as const;

export type FlowBranch = typeof FlowBranch[keyof typeof FlowBranch];


/**
 * 
 * @export
 * @interface FlowCategoryCreateRequest
 */
export interface FlowCategoryCreateRequest {
    /**
     * The flow category name
     * @type {string}
     * @memberof FlowCategoryCreateRequest
     */
    'cat_name': string;
    /**
     * The flow category color
     * @type {string}
     * @memberof FlowCategoryCreateRequest
     */
    'cat_color': string;
}
/**
 * Flow category response.
 * @export
 * @interface FlowCategoryResponse
 */
export interface FlowCategoryResponse {
    /**
     * 
     * @type {string}
     * @memberof FlowCategoryResponse
     */
    'cat_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowCategoryResponse
     */
    'cat_name': string;
    /**
     * 
     * @type {string}
     * @memberof FlowCategoryResponse
     */
    'cat_color': string;
}
/**
 * 
 * @export
 * @interface FlowCategorySearchRequest
 */
export interface FlowCategorySearchRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowCategorySearchRequest
     */
    'cat_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FlowCategorySearchRequest
     */
    'limit'?: number | null;
}
/**
 * 
 * @export
 * @interface FlowCommitRequest
 */
export interface FlowCommitRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowCommitRequest
     */
    'commit_title'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowCommitResponse
 */
export interface FlowCommitResponse {
    /**
     * 
     * @type {string}
     * @memberof FlowCommitResponse
     */
    'commit_title'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowConfig
 */
export interface FlowConfig {
    /**
     * The flow nodes
     * @type {Array<any>}
     * @memberof FlowConfig
     */
    'nodes': Array<any>;
    /**
     * The flow edges
     * @type {Array<any>}
     * @memberof FlowConfig
     */
    'edges': Array<any>;
}
/**
 * 
 * @export
 * @interface FlowCreate
 */
export interface FlowCreate {
    /**
     * The flow name
     * @type {string}
     * @memberof FlowCreate
     */
    'name': string;
    /**
     * The flow description
     * @type {string}
     * @memberof FlowCreate
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof FlowCreate
     */
    'detailed_description'?: string | null;
    /**
     * The flow configuration
     * @type {FlowConfig}
     * @memberof FlowCreate
     */
    'config': FlowConfig;
    /**
     * 
     * @type {string}
     * @memberof FlowCreate
     */
    'category_id'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowCronCreateRequest
 */
export interface FlowCronCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowCronCreateRequest
     */
    'flow_id': string;
    /**
     * 
     * @type {FlowCronStatus}
     * @memberof FlowCronCreateRequest
     */
    'status': FlowCronStatus;
    /**
     * 
     * @type {string}
     * @memberof FlowCronCreateRequest
     */
    'input_text'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowCronCreateRequest
     */
    'variables'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronCreateRequest
     */
    'interval_settings': string;
    /**
     * 
     * @type {string}
     * @memberof FlowCronCreateRequest
     */
    'cron_name': string;
}


/**
 * Flow cron response.
 * @export
 * @interface FlowCronResponse
 */
export interface FlowCronResponse {
    /**
     * 
     * @type {string}
     * @memberof FlowCronResponse
     */
    'flow_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowCronResponse
     */
    'cron_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowCronResponse
     */
    'last_run'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronResponse
     */
    'next_run'?: string | null;
    /**
     * 
     * @type {FlowCronStatus}
     * @memberof FlowCronResponse
     */
    'status': FlowCronStatus;
    /**
     * 
     * @type {string}
     * @memberof FlowCronResponse
     */
    'input_text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronResponse
     */
    'interval_settings': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowCronResponse
     */
    'variables'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronResponse
     */
    'cron_name': string;
}


/**
 * 
 * @export
 * @interface FlowCronSearchRequest
 */
export interface FlowCronSearchRequest {
    /**
     * 
     * @type {FlowCronStatus}
     * @memberof FlowCronSearchRequest
     */
    'status'?: FlowCronStatus | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronSearchRequest
     */
    'next_run_to'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronSearchRequest
     */
    'next_run_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronSearchRequest
     */
    'last_run_to'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronSearchRequest
     */
    'last_run_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronSearchRequest
     */
    'flow_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronSearchRequest
     */
    'cron_name'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FlowCronStatus = {
    E: 'E',
    P: 'P'
} as const;

export type FlowCronStatus = typeof FlowCronStatus[keyof typeof FlowCronStatus];


/**
 * 
 * @export
 * @interface FlowCronUpdateRequest
 */
export interface FlowCronUpdateRequest {
    /**
     * 
     * @type {FlowCronStatus}
     * @memberof FlowCronUpdateRequest
     */
    'status'?: FlowCronStatus | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronUpdateRequest
     */
    'input_text'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowCronUpdateRequest
     */
    'variables'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronUpdateRequest
     */
    'interval_settings'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowCronUpdateRequest
     */
    'cron_name'?: string | null;
}


/**
 * 
 * @export
 * @interface FlowDetailResponse
 */
export interface FlowDetailResponse {
    /**
     * Flow ID
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'id': string;
    /**
     * Flow name
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'name': string;
    /**
     * Flow description
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'detailed_description'?: string | null;
    /**
     * Flow configuration
     * @type {FlowConfig}
     * @memberof FlowDetailResponse
     */
    'config': FlowConfig;
    /**
     * Flow type
     * @type {FlowType}
     * @memberof FlowDetailResponse
     */
    'flow_type': FlowType;
    /**
     * 
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'executed_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'category_id'?: string | null;
    /**
     * Flow branch
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'branch': string;
    /**
     * Enable cache
     * @type {boolean}
     * @memberof FlowDetailResponse
     */
    'enable_cache': boolean;
    /**
     * 
     * @type {number}
     * @memberof FlowDetailResponse
     */
    'draft_version_nr'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FlowDetailResponse
     */
    'prod_version_nr'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FlowDetailResponse
     */
    'last_modified'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FlowEventActionType = {
    Loading: 'loading',
    Message: 'message',
    ToolCall: 'tool_call',
    TaskResponse: 'task_response',
    Failed: 'failed',
    MessageFeedback: 'message_feedback',
    AddComponent: 'add_component',
    DeleteComponent: 'delete_component',
    ConnectComponents: 'connect_components',
    UpdateComponent: 'update_component',
    AddConnection: 'add_connection',
    DeleteConnection: 'delete_connection',
    CreateBlankFlow: 'create_blank_flow'
} as const;

export type FlowEventActionType = typeof FlowEventActionType[keyof typeof FlowEventActionType];


/**
 * Enum for FlowHunt product slugs.
 * @export
 * @enum {string}
 */

export const FlowHuntProductSlug = {
    S: 'S',
    P: 'P',
    A: 'A'
} as const;

export type FlowHuntProductSlug = typeof FlowHuntProductSlug[keyof typeof FlowHuntProductSlug];


/**
 * 
 * @export
 * @interface FlowInvokeRequest
 */
export interface FlowInvokeRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowInvokeRequest
     */
    'post_back_url'?: string | null;
    /**
     * The human input
     * @type {string}
     * @memberof FlowInvokeRequest
     */
    'human_input': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowInvokeRequest
     */
    'variables'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface FlowMessageFeedbackRequest
 */
export interface FlowMessageFeedbackRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowMessageFeedbackRequest
     */
    'message_id'?: string | null;
    /**
     * 
     * @type {MessageFeedback}
     * @memberof FlowMessageFeedbackRequest
     */
    'feedback'?: MessageFeedback | null;
}


/**
 * 
 * @export
 * @interface FlowMessageFeedbackResponse
 */
export interface FlowMessageFeedbackResponse {
    /**
     * Response message
     * @type {string}
     * @memberof FlowMessageFeedbackResponse
     */
    'response_message': string;
}
/**
 * 
 * @export
 * @interface FlowResponse
 */
export interface FlowResponse {
    /**
     * Flow ID
     * @type {string}
     * @memberof FlowResponse
     */
    'id': string;
    /**
     * Flow name
     * @type {string}
     * @memberof FlowResponse
     */
    'name': string;
    /**
     * Flow description
     * @type {string}
     * @memberof FlowResponse
     */
    'description': string;
    /**
     * Flow type
     * @type {FlowType}
     * @memberof FlowResponse
     */
    'flow_type': FlowType;
    /**
     * Component count
     * @type {number}
     * @memberof FlowResponse
     */
    'component_count': number;
    /**
     * 
     * @type {string}
     * @memberof FlowResponse
     */
    'executed_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowResponse
     */
    'category_id'?: string | null;
    /**
     * Enable cache
     * @type {boolean}
     * @memberof FlowResponse
     */
    'enable_cache': boolean;
    /**
     * 
     * @type {string}
     * @memberof FlowResponse
     */
    'last_modified'?: string | null;
}


/**
 * 
 * @export
 * @interface FlowSearchRequest
 */
export interface FlowSearchRequest {
    /**
     * 
     * @type {FlowType}
     * @memberof FlowSearchRequest
     */
    'flow_type'?: FlowType | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSearchRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSearchRequest
     */
    'category_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Pagination}
     * @memberof FlowSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * 
 * @export
 * @interface FlowSessionAttachmentResponse
 */
export interface FlowSessionAttachmentResponse {
    /**
     * File name
     * @type {string}
     * @memberof FlowSessionAttachmentResponse
     */
    'file_name': string;
    /**
     * File type
     * @type {string}
     * @memberof FlowSessionAttachmentResponse
     */
    'file_type': string;
    /**
     * File ID
     * @type {string}
     * @memberof FlowSessionAttachmentResponse
     */
    'file_id': string;
    /**
     * Document type
     * @type {DocumentType}
     * @memberof FlowSessionAttachmentResponse
     */
    'type': DocumentType;
}


/**
 * 
 * @export
 * @interface FlowSessionCreateFromFlowRequest
 */
export interface FlowSessionCreateFromFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'lang'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'access_token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'refresh_token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'password'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'variables'?: { [key: string]: string; } | null;
    /**
     * The flow ID
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'flow_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'on_chat_opened_postback_url'?: string | null;
    /**
     * The flow branch
     * @type {FlowBranch}
     * @memberof FlowSessionCreateFromFlowRequest
     */
    'flow_branch'?: FlowBranch;
}


/**
 * 
 * @export
 * @interface FlowSessionCreateRequest
 */
export interface FlowSessionCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'lang'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'access_token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'refresh_token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'password'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof FlowSessionCreateRequest
     */
    'variables'?: { [key: string]: string; } | null;
    /**
     * The chatbot ID
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'chatbot_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionCreateRequest
     */
    'on_chat_opened_postback_url'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowSessionEvent
 */
export interface FlowSessionEvent {
    /**
     * Workspace ID
     * @type {string}
     * @memberof FlowSessionEvent
     */
    'workspace_id': string;
    /**
     * Session ID
     * @type {string}
     * @memberof FlowSessionEvent
     */
    'session_id': string;
    /**
     * Event ID
     * @type {string}
     * @memberof FlowSessionEvent
     */
    'event_id': string;
    /**
     * Event type
     * @type {MessageType}
     * @memberof FlowSessionEvent
     */
    'event_type': MessageType;
    /**
     * Created at
     * @type {string}
     * @memberof FlowSessionEvent
     */
    'created_at_timestamp': string;
    /**
     * Action type
     * @type {FlowEventActionType}
     * @memberof FlowSessionEvent
     */
    'action_type': FlowEventActionType;
    /**
     * Credits
     * @type {number}
     * @memberof FlowSessionEvent
     */
    'credits': number;
    /**
     * 
     * @type {Metadata}
     * @memberof FlowSessionEvent
     */
    'metadata'?: Metadata | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionEvent
     */
    'component_name'?: string | null;
}


/**
 * 
 * @export
 * @interface FlowSessionInvocationResponse
 */
export interface FlowSessionInvocationResponse {
    /**
     * Message ID
     * @type {string}
     * @memberof FlowSessionInvocationResponse
     */
    'message_id': string;
    /**
     * Created at
     * @type {string}
     * @memberof FlowSessionInvocationResponse
     */
    'created_at': string;
    /**
     * 
     * @type {Array<FlowSessionEvent>}
     * @memberof FlowSessionInvocationResponse
     */
    'cached_events'?: Array<FlowSessionEvent> | null;
}
/**
 * 
 * @export
 * @interface FlowSessionInvokeRequest
 */
export interface FlowSessionInvokeRequest {
    /**
     * The message
     * @type {string}
     * @memberof FlowSessionInvokeRequest
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionInvokeRequest
     */
    'post_back_url'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowSessionLoadingMetadata
 */
export interface FlowSessionLoadingMetadata {
    /**
     * Message ID
     * @type {string}
     * @memberof FlowSessionLoadingMetadata
     */
    'message_id': string;
    /**
     * Tool name
     * @type {string}
     * @memberof FlowSessionLoadingMetadata
     */
    'tool_name': string;
    /**
     * Loading description
     * @type {string}
     * @memberof FlowSessionLoadingMetadata
     */
    'loading_desc': string;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionLoadingMetadata
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionLoadingMetadata
     */
    'color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionLoadingMetadata
     */
    'detailed_description'?: string | null;
}
/**
 * 
 * @export
 * @interface FlowSessionMessageFeedbackMetadata
 */
export interface FlowSessionMessageFeedbackMetadata {
    /**
     * Message ID
     * @type {string}
     * @memberof FlowSessionMessageFeedbackMetadata
     */
    'feedback_message_id': string;
    /**
     * 
     * @type {MessageFeedback}
     * @memberof FlowSessionMessageFeedbackMetadata
     */
    'feedback'?: MessageFeedback | null;
}


/**
 * 
 * @export
 * @interface FlowSessionMessageMetadata
 */
export interface FlowSessionMessageMetadata {
    /**
     * Message ID
     * @type {string}
     * @memberof FlowSessionMessageMetadata
     */
    'message_id': string;
    /**
     * Message
     * @type {string}
     * @memberof FlowSessionMessageMetadata
     */
    'message': string;
    /**
     * 
     * @type {HumanAgentSender}
     * @memberof FlowSessionMessageMetadata
     */
    'sender'?: HumanAgentSender | null;
}
/**
 * 
 * @export
 * @interface FlowSessionResponse
 */
export interface FlowSessionResponse {
    /**
     * Session ID
     * @type {string}
     * @memberof FlowSessionResponse
     */
    'session_id': string;
    /**
     * Session created at
     * @type {string}
     * @memberof FlowSessionResponse
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface FlowSessionTaskResponseMetadata
 */
export interface FlowSessionTaskResponseMetadata {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionTaskResponseMetadata
     */
    'task_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionTaskResponseMetadata
     */
    'task_input': string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionTaskResponseMetadata
     */
    'agent': string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionTaskResponseMetadata
     */
    'task_response': string | null;
}
/**
 * 
 * @export
 * @interface FlowSessionToolCallMetadata
 */
export interface FlowSessionToolCallMetadata {
    /**
     * Tool name
     * @type {string}
     * @memberof FlowSessionToolCallMetadata
     */
    'tool_name': string;
    /**
     * Search query
     * @type {string}
     * @memberof FlowSessionToolCallMetadata
     */
    'agent_query': string;
    /**
     * Tool response
     * @type {string}
     * @memberof FlowSessionToolCallMetadata
     */
    'tool_response': string;
}
/**
 * 
 * @export
 * @interface FlowSessionViewResponse
 */
export interface FlowSessionViewResponse {
    /**
     * Session ID
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'session_id': string;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'chatbot_id'?: string | null;
    /**
     * Flow ID
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'flow_id': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'workspace_id': string;
    /**
     * Created at
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'last_msg_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewResponse
     */
    'msg_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewResponse
     */
    'credits'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'chatbot_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'flow_name'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof FlowSessionViewResponse
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewResponse
     */
    'duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'ipaddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewResponse
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewResponse
     */
    'positive_feedback_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewResponse
     */
    'negative_feedback_count'?: number | null;
}
/**
 * 
 * @export
 * @interface FlowSessionViewSearchRequest
 */
export interface FlowSessionViewSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewSearchRequest
     */
    'chatbot_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewSearchRequest
     */
    'flow_id'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof FlowSessionViewSearchRequest
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowSessionViewSearchRequest
     */
    'created_at_filter'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowSessionViewSearchRequest
     */
    'last_message_at_filter'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowSessionViewSearchRequest
     */
    'duration_filter'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowSessionViewSearchRequest
     */
    'msg_count_filter'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowSessionViewSearchRequest
     */
    'credits_filter'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewSearchRequest
     */
    'chatbot_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowSessionViewSearchRequest
     */
    'flow_name'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FlowSessionViewSearchRequest
     */
    'ipaddress_filter'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {Pagination}
     * @memberof FlowSessionViewSearchRequest
     */
    'pagination'?: Pagination | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewSearchRequest
     */
    'positive_feedback'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FlowSessionViewSearchRequest
     */
    'negative_feedback'?: number | null;
}
/**
 * 
 * @export
 * @interface FlowSessionViewUpdateRequest
 */
export interface FlowSessionViewUpdateRequest {
    /**
     * New tags value
     * @type {Array<string>}
     * @memberof FlowSessionViewUpdateRequest
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FlowType = {
    P: 'p',
    V: 'v'
} as const;

export type FlowType = typeof FlowType[keyof typeof FlowType];


/**
 * 
 * @export
 * @interface FlowUpdate
 */
export interface FlowUpdate {
    /**
     * The flow name
     * @type {string}
     * @memberof FlowUpdate
     */
    'name': string;
    /**
     * The flow description
     * @type {string}
     * @memberof FlowUpdate
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof FlowUpdate
     */
    'detailed_description'?: string | null;
    /**
     * The flow configuration
     * @type {FlowConfig}
     * @memberof FlowUpdate
     */
    'config': FlowConfig;
    /**
     * 
     * @type {string}
     * @memberof FlowUpdate
     */
    'category_id'?: string | null;
    /**
     * The flow branch
     * @type {FlowBranch}
     * @memberof FlowUpdate
     */
    'branch'?: FlowBranch;
    /**
     * 
     * @type {boolean}
     * @memberof FlowUpdate
     */
    'enable_cache'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof FlowUpdate
     */
    'version_nr'?: number | null;
}


/**
 * 
 * @export
 * @interface FlowVersionHistoryResponse
 */
export interface FlowVersionHistoryResponse {
    /**
     * Flow ID
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'id': string;
    /**
     * Flow name
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'name': string;
    /**
     * Flow description
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof FlowVersionHistoryResponse
     */
    'version_nr'?: number | null;
    /**
     * Flow type
     * @type {FlowType}
     * @memberof FlowVersionHistoryResponse
     */
    'flow_type': FlowType;
    /**
     * 
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'executed_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'category_id'?: string | null;
    /**
     * Enable cache
     * @type {boolean}
     * @memberof FlowVersionHistoryResponse
     */
    'enable_cache': boolean;
    /**
     * 
     * @type {UserResponse}
     * @memberof FlowVersionHistoryResponse
     */
    'user'?: UserResponse | null;
    /**
     * Flow branch
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'branch': string;
    /**
     * 
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FlowVersionHistoryResponse
     */
    'commit_title'?: string | null;
}


/**
 * General response schema for MCP subserver capabilities
 * @export
 * @interface GeneralMCPSubserverCapabilitiesResponse
 */
export interface GeneralMCPSubserverCapabilitiesResponse {
    /**
     * ID of the capability
     * @type {string}
     * @memberof GeneralMCPSubserverCapabilitiesResponse
     */
    'capability_id': string;
    /**
     * Name of the capability
     * @type {string}
     * @memberof GeneralMCPSubserverCapabilitiesResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GeneralMCPSubserverCapabilitiesResponse
     */
    'description'?: string | null;
}
/**
 * General response schema for MCP subserver binding
 * @export
 * @interface GeneralMCPSubserverResponse
 */
export interface GeneralMCPSubserverResponse {
    /**
     * ID of the MCP subserver
     * @type {string}
     * @memberof GeneralMCPSubserverResponse
     */
    'server_id': string;
    /**
     * Name of the MCP subserver
     * @type {string}
     * @memberof GeneralMCPSubserverResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GeneralMCPSubserverResponse
     */
    'description'?: string | null;
    /**
     * Status of the MCP subserver
     * @type {string}
     * @memberof GeneralMCPSubserverResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof GeneralMCPSubserverResponse
     */
    'icon'?: string | null;
    /**
     * Version of the MCP subserver
     * @type {string}
     * @memberof GeneralMCPSubserverResponse
     */
    'version': string;
    /**
     * List of capabilities for the MCP subserver
     * @type {Array<GeneralMCPSubserverCapabilitiesResponse>}
     * @memberof GeneralMCPSubserverResponse
     */
    'capabilities'?: Array<GeneralMCPSubserverCapabilitiesResponse>;
    /**
     * 
     * @type {IntegrationSlug}
     * @memberof GeneralMCPSubserverResponse
     */
    'integration_slug': IntegrationSlug | null;
}


/**
 * 
 * @export
 * @interface GetNodeRequest
 */
export interface GetNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof GetNodeRequest
     */
    'cat_id'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GoogleAdsActionType = {
    I: 'I',
    N: 'N',
    O: 'O',
    Z: 'Z',
    R: 'R',
    H: 'H',
    M: 'M',
    L: 'L'
} as const;

export type GoogleAdsActionType = typeof GoogleAdsActionType[keyof typeof GoogleAdsActionType];


/**
 * 
 * @export
 * @interface GoogleAdsAnalyzeKeywordsRequest
 */
export interface GoogleAdsAnalyzeKeywordsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsAnalyzeKeywordsRequest
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsAnalyzeKeywordsRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsAnalyzeKeywordsRequest
     */
    'group_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsAnalyzeKeywordsRequest
     */
    'date_from'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GoogleAdsAnalyzeKeywordsRequest
     */
    'force_update'?: boolean | null;
}
/**
 * 
 * @export
 * @interface GoogleAdsCampaignResponse
 */
export interface GoogleAdsCampaignResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof GoogleAdsCampaignResponse
     */
    'workspace_id': string;
    /**
     * Google Ads Customer ID
     * @type {string}
     * @memberof GoogleAdsCampaignResponse
     */
    'customer_id': string;
    /**
     * Google Ads Campaign ID
     * @type {string}
     * @memberof GoogleAdsCampaignResponse
     */
    'campaign_id': string;
    /**
     * Google Ads Campaign Name
     * @type {string}
     * @memberof GoogleAdsCampaignResponse
     */
    'campaign_name': string;
    /**
     * Campaign Status
     * @type {GoogleAdsCampaignStatus}
     * @memberof GoogleAdsCampaignResponse
     */
    'campaign_status': GoogleAdsCampaignStatus;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignResponse
     */
    'language_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignResponse
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignResponse
     */
    'last_update'?: string | null;
    /**
     * Action Type
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsCampaignResponse
     */
    'action_type': GoogleAdsActionType;
}


/**
 * The possible statuses of an ad group.
 * @export
 * @enum {number}
 */

export const GoogleAdsCampaignStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type GoogleAdsCampaignStatus = typeof GoogleAdsCampaignStatus[keyof typeof GoogleAdsCampaignStatus];


/**
 * 
 * @export
 * @interface GoogleAdsCampaignUpdateRequest
 */
export interface GoogleAdsCampaignUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignUpdateRequest
     */
    'language_code': string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignUpdateRequest
     */
    'country': string | null;
    /**
     * 
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsCampaignUpdateRequest
     */
    'action_type': GoogleAdsActionType | null;
}


/**
 * 
 * @export
 * @interface GoogleAdsCampaignsResponse
 */
export interface GoogleAdsCampaignsResponse {
    /**
     * List of Google Ads Campaigns
     * @type {Array<GoogleAdsCampaignResponse>}
     * @memberof GoogleAdsCampaignsResponse
     */
    'campaigns': Array<GoogleAdsCampaignResponse>;
}
/**
 * 
 * @export
 * @interface GoogleAdsCampaignsSearchRequest
 */
export interface GoogleAdsCampaignsSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'campaign_name'?: string | null;
    /**
     * 
     * @type {GoogleAdsCampaignStatus}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'campaign_status'?: GoogleAdsCampaignStatus | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'language_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'country'?: string | null;
    /**
     * 
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'action_type'?: GoogleAdsActionType | null;
    /**
     * Limit of the search
     * @type {number}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {Pagination}
     * @memberof GoogleAdsCampaignsSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * 
 * @export
 * @interface GoogleAdsCustomerResponse
 */
export interface GoogleAdsCustomerResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'workspace_id': string;
    /**
     * Google Ads Customer ID
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'customer_id': string;
    /**
     * Google Ads Customer Name
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'customer_name': string;
    /**
     * Language Code
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'language_code': string;
    /**
     * Country Code
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'country': string;
    /**
     * Minimum Queries
     * @type {number}
     * @memberof GoogleAdsCustomerResponse
     */
    'min_queries': number;
    /**
     * Cluster Strength
     * @type {number}
     * @memberof GoogleAdsCustomerResponse
     */
    'cluster_strength': number;
    /**
     * Minimum Impressions
     * @type {number}
     * @memberof GoogleAdsCustomerResponse
     */
    'min_impressions': number;
    /**
     * Minimum Clicks
     * @type {number}
     * @memberof GoogleAdsCustomerResponse
     */
    'min_clicks': number;
    /**
     * 
     * @type {BoolChar}
     * @memberof GoogleAdsCustomerResponse
     */
    'process_negative_keywords'?: BoolChar | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'last_update'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'next_update'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'cron_settings'?: string | null;
    /**
     * Action Type
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsCustomerResponse
     */
    'action_type': GoogleAdsActionType;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'ga_measurement_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerResponse
     */
    'ga_api_secret'?: string | null;
}


/**
 * 
 * @export
 * @interface GoogleAdsCustomerUpdateRequest
 */
export interface GoogleAdsCustomerUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'language_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'country'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'min_queries'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'cluster_strength'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'min_impressions'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'min_clicks'?: number | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'process_negative_keywords'?: BoolChar | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'cron_settings'?: string | null;
    /**
     * 
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'action_type'?: GoogleAdsActionType | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'ga_measurement_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomerUpdateRequest
     */
    'ga_api_secret'?: string | null;
}


/**
 * 
 * @export
 * @interface GoogleAdsCustomersResponse
 */
export interface GoogleAdsCustomersResponse {
    /**
     * List of Google Ads Customers
     * @type {Array<GoogleAdsCustomerResponse>}
     * @memberof GoogleAdsCustomersResponse
     */
    'customers': Array<GoogleAdsCustomerResponse>;
}
/**
 * 
 * @export
 * @interface GoogleAdsCustomersSearchRequest
 */
export interface GoogleAdsCustomersSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'customer_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'language_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'country'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'min_queries'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'min_clicks'?: number | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'process_negative_keywords'?: BoolChar | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'min_impressions'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'cluster_strength'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'last_update'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'next_update'?: string | null;
    /**
     * 
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'action_type'?: GoogleAdsActionType | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'ga_measurement_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsCustomersSearchRequest
     */
    'ga_api_secret'?: string | null;
}


/**
 * 
 * @export
 * @interface GoogleAdsGroupResponse
 */
export interface GoogleAdsGroupResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'workspace_id': string;
    /**
     * Google Ads Customer ID
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'customer_id': string;
    /**
     * Google Ads Campaign ID
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'campaign_id': string;
    /**
     * Google Ads Group
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'group_id': string;
    /**
     * Google Ads Group Name
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'group_name': string;
    /**
     * Group Status
     * @type {GoogleAdsGroupStatus}
     * @memberof GoogleAdsGroupResponse
     */
    'group_status': GoogleAdsGroupStatus;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'last_update'?: string | null;
    /**
     * Action Type
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsGroupResponse
     */
    'action_type': GoogleAdsActionType;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'language_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupResponse
     */
    'country'?: string | null;
}


/**
 * The possible statuses of an ad group.
 * @export
 * @enum {number}
 */

export const GoogleAdsGroupStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type GoogleAdsGroupStatus = typeof GoogleAdsGroupStatus[keyof typeof GoogleAdsGroupStatus];


/**
 * 
 * @export
 * @interface GoogleAdsGroupUpdateRequest
 */
export interface GoogleAdsGroupUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupUpdateRequest
     */
    'language_code': string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupUpdateRequest
     */
    'country': string | null;
    /**
     * 
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsGroupUpdateRequest
     */
    'action_type': GoogleAdsActionType | null;
}


/**
 * 
 * @export
 * @interface GoogleAdsGroupsResponse
 */
export interface GoogleAdsGroupsResponse {
    /**
     * List of Google Ads Groups
     * @type {Array<GoogleAdsGroupResponse>}
     * @memberof GoogleAdsGroupsResponse
     */
    'groups': Array<GoogleAdsGroupResponse>;
}
/**
 * 
 * @export
 * @interface GoogleAdsGroupsSearchRequest
 */
export interface GoogleAdsGroupsSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'group_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'group_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'language_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'country'?: string | null;
    /**
     * 
     * @type {GoogleAdsActionType}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'action_type'?: GoogleAdsActionType | null;
    /**
     * 
     * @type {GoogleAdsGroupStatus}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'group_status'?: GoogleAdsGroupStatus | null;
    /**
     * Limit of the search
     * @type {number}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {Pagination}
     * @memberof GoogleAdsGroupsSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * 
 * @export
 * @interface GoogleAdsKeywordAddRequest
 */
export interface GoogleAdsKeywordAddRequest {
    /**
     * Customer id
     * @type {string}
     * @memberof GoogleAdsKeywordAddRequest
     */
    'customer_id': string;
    /**
     * Campaign id
     * @type {string}
     * @memberof GoogleAdsKeywordAddRequest
     */
    'campaign_id': string;
    /**
     * Group id
     * @type {string}
     * @memberof GoogleAdsKeywordAddRequest
     */
    'group_id': string;
    /**
     * List of keywords to add
     * @type {Array<string>}
     * @memberof GoogleAdsKeywordAddRequest
     */
    'keywords': Array<string>;
    /**
     * Is negative keyword
     * @type {boolean}
     * @memberof GoogleAdsKeywordAddRequest
     */
    'is_negative'?: boolean;
    /**
     * Match type
     * @type {GoogleAdsMatchType}
     * @memberof GoogleAdsKeywordAddRequest
     */
    'match_type': GoogleAdsMatchType;
}


/**
 * 
 * @export
 * @interface GoogleAdsKeywordRecommendation
 */
export interface GoogleAdsKeywordRecommendation {
    /**
     * Workspace ID
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'workspace_id': string;
    /**
     * Customer ID
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'customer_id': string;
    /**
     * Campaign ID
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'campaign_id': string;
    /**
     * Campaign Name
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'campaign_name': string;
    /**
     * Group ID
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'group_id': string;
    /**
     * Group Name
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'group_name': string;
    /**
     * Keyword ID
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'keyword_id': string;
    /**
     * Keyword
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'keyword': string;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {Array<GoogleAdsRecommendation>}
     * @memberof GoogleAdsKeywordRecommendation
     */
    'recommendations'?: Array<GoogleAdsRecommendation> | null;
}
/**
 * 
 * @export
 * @interface GoogleAdsKeywordRemoveRequest
 */
export interface GoogleAdsKeywordRemoveRequest {
    /**
     * Customer id
     * @type {string}
     * @memberof GoogleAdsKeywordRemoveRequest
     */
    'customer_id': string;
    /**
     * Campaign id
     * @type {string}
     * @memberof GoogleAdsKeywordRemoveRequest
     */
    'campaign_id': string;
    /**
     * Group id
     * @type {string}
     * @memberof GoogleAdsKeywordRemoveRequest
     */
    'group_id': string;
    /**
     * List of keywords to remove
     * @type {Array<string>}
     * @memberof GoogleAdsKeywordRemoveRequest
     */
    'keywords': Array<string>;
    /**
     * Is negative keyword
     * @type {boolean}
     * @memberof GoogleAdsKeywordRemoveRequest
     */
    'is_negative'?: boolean;
    /**
     * Match type
     * @type {GoogleAdsMatchType}
     * @memberof GoogleAdsKeywordRemoveRequest
     */
    'match_type': GoogleAdsMatchType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const GoogleAdsMatchType = {
    E: 'E',
    P: 'P',
    B: 'B'
} as const;

export type GoogleAdsMatchType = typeof GoogleAdsMatchType[keyof typeof GoogleAdsMatchType];


/**
 * 
 * @export
 * @interface GoogleAdsRecommendation
 */
export interface GoogleAdsRecommendation {
    /**
     * 
     * @type {GoogleAdsRecommendationType}
     * @memberof GoogleAdsRecommendation
     */
    'recommendation_type': GoogleAdsRecommendationType;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsRecommendation
     */
    'campaign_id': string;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsRecommendation
     */
    'campaign_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsRecommendation
     */
    'group_id': string;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsRecommendation
     */
    'group_name'?: string | null;
    /**
     * 
     * @type {GoogleAdsRecommendationStatus}
     * @memberof GoogleAdsRecommendation
     */
    'action_status': GoogleAdsRecommendationStatus;
    /**
     * 
     * @type {GoogleAdsRecommendationConfidence}
     * @memberof GoogleAdsRecommendation
     */
    'confidence'?: GoogleAdsRecommendationConfidence;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const GoogleAdsRecommendationConfidence = {
    H: 'H',
    M: 'M',
    L: 'L'
} as const;

export type GoogleAdsRecommendationConfidence = typeof GoogleAdsRecommendationConfidence[keyof typeof GoogleAdsRecommendationConfidence];


/**
 * 
 * @export
 * @enum {string}
 */

export const GoogleAdsRecommendationStatus = {
    E: 'E',
    S: 'S'
} as const;

export type GoogleAdsRecommendationStatus = typeof GoogleAdsRecommendationStatus[keyof typeof GoogleAdsRecommendationStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const GoogleAdsRecommendationType = {
    A: 'A',
    N: 'N'
} as const;

export type GoogleAdsRecommendationType = typeof GoogleAdsRecommendationType[keyof typeof GoogleAdsRecommendationType];


/**
 * 
 * @export
 * @interface GoogleAdsRecommendationsRequest
 */
export interface GoogleAdsRecommendationsRequest {
    /**
     * Customer id to get recommendations for
     * @type {string}
     * @memberof GoogleAdsRecommendationsRequest
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsRecommendationsRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsRecommendationsRequest
     */
    'group_id'?: string | null;
    /**
     * Limit of the search
     * @type {number}
     * @memberof GoogleAdsRecommendationsRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {Pagination}
     * @memberof GoogleAdsRecommendationsRequest
     */
    'pagination'?: Pagination | null;
}
/**
 * 
 * @export
 * @interface GoogleCalendarResponse
 */
export interface GoogleCalendarResponse {
    /**
     * Calendar ID
     * @type {string}
     * @memberof GoogleCalendarResponse
     */
    'calendar_id': string;
    /**
     * Calendar name
     * @type {string}
     * @memberof GoogleCalendarResponse
     */
    'calendar_name': string;
}
/**
 * 
 * @export
 * @interface GoogleCalendarsResponse
 */
export interface GoogleCalendarsResponse {
    /**
     * 
     * @type {Array<GoogleCalendarResponse>}
     * @memberof GoogleCalendarsResponse
     */
    'calendars': Array<GoogleCalendarResponse>;
}
/**
 * 
 * @export
 * @interface GooglePickerTokenResponse
 */
export interface GooglePickerTokenResponse {
    /**
     * Picker token
     * @type {string}
     * @memberof GooglePickerTokenResponse
     */
    'picker_token': string;
}
/**
 * 
 * @export
 * @interface GoogleSheetResponse
 */
export interface GoogleSheetResponse {
    /**
     * Sheet ID
     * @type {number}
     * @memberof GoogleSheetResponse
     */
    'sheet_id': number;
    /**
     * Sheet title
     * @type {string}
     * @memberof GoogleSheetResponse
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface GoogleSheetsResponse
 */
export interface GoogleSheetsResponse {
    /**
     * 
     * @type {Array<GoogleSheetResponse>}
     * @memberof GoogleSheetsResponse
     */
    'sheets': Array<GoogleSheetResponse>;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Health
 */
export interface Health {
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface HubSpotActorIdResponse
 */
export interface HubSpotActorIdResponse {
    /**
     * Actor ID
     * @type {string}
     * @memberof HubSpotActorIdResponse
     */
    'actor_id': string;
    /**
     * Actor Email
     * @type {string}
     * @memberof HubSpotActorIdResponse
     */
    'actor_email': string;
}
/**
 * 
 * @export
 * @interface HubSpotActorsResponse
 */
export interface HubSpotActorsResponse {
    /**
     * 
     * @type {Array<HubSpotActorIdResponse>}
     * @memberof HubSpotActorsResponse
     */
    'actors': Array<HubSpotActorIdResponse>;
}
/**
 * 
 * @export
 * @interface HumanAgentSender
 */
export interface HumanAgentSender {
    /**
     * 
     * @type {string}
     * @memberof HumanAgentSender
     */
    'sender_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof HumanAgentSender
     */
    'sender_avatar'?: string | null;
}
/**
 * 
 * @export
 * @interface ImageConvertRequest
 */
export interface ImageConvertRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageConvertRequest
     */
    'post_back_url'?: string | null;
    /**
     * Image URL to convert
     * @type {string}
     * @memberof ImageConvertRequest
     */
    'image_url': string;
    /**
     * Image format to convert to
     * @type {string}
     * @memberof ImageConvertRequest
     */
    'format': string;
    /**
     * 
     * @type {number}
     * @memberof ImageConvertRequest
     */
    'quality'?: number | null;
}
/**
 * 
 * @export
 * @interface ImageFTCreateRequest
 */
export interface ImageFTCreateRequest {
    /**
     * Fine tuning name
     * @type {string}
     * @memberof ImageFTCreateRequest
     */
    'name': string;
    /**
     * Trigger word
     * @type {string}
     * @memberof ImageFTCreateRequest
     */
    'trigger_word': string;
    /**
     * 
     * @type {number}
     * @memberof ImageFTCreateRequest
     */
    'steps'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ImageFTCreateRequest
     */
    'lora_rank'?: number | null;
    /**
     * Training images
     * @type {Array<string>}
     * @memberof ImageFTCreateRequest
     */
    'training_images': Array<string>;
    /**
     * Cover image
     * @type {string}
     * @memberof ImageFTCreateRequest
     */
    'cover_image': string;
}
/**
 * 
 * @export
 * @interface ImageFTResponse
 */
export interface ImageFTResponse {
    /**
     * Fine tuning type
     * @type {FTType}
     * @memberof ImageFTResponse
     */
    'ft_type': FTType;
    /**
     * Fine tuning id
     * @type {string}
     * @memberof ImageFTResponse
     */
    'ft_id': string;
    /**
     * Fine tuning name
     * @type {string}
     * @memberof ImageFTResponse
     */
    'name': string;
    /**
     * Number of steps
     * @type {number}
     * @memberof ImageFTResponse
     */
    'steps': number;
    /**
     * Lora rank
     * @type {number}
     * @memberof ImageFTResponse
     */
    'lora_rank': number;
    /**
     * Trigger word
     * @type {string}
     * @memberof ImageFTResponse
     */
    'trigger_word': string;
    /**
     * Training images
     * @type {Array<string>}
     * @memberof ImageFTResponse
     */
    'training_images': Array<string>;
    /**
     * Status
     * @type {FTStatus}
     * @memberof ImageFTResponse
     */
    'status': FTStatus;
    /**
     * 
     * @type {string}
     * @memberof ImageFTResponse
     */
    'cover_image': string | null;
}


/**
 * 
 * @export
 * @interface ImageFTSearchRequest
 */
export interface ImageFTSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageFTSearchRequest
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface ImageFTUpdateRequest
 */
export interface ImageFTUpdateRequest {
    /**
     * Fine tuning name
     * @type {string}
     * @memberof ImageFTUpdateRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ImageFTUpdateRequest
     */
    'steps'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ImageFTUpdateRequest
     */
    'lora_rank'?: number | null;
    /**
     * Training images
     * @type {Array<string>}
     * @memberof ImageFTUpdateRequest
     */
    'training_images': Array<string>;
    /**
     * Cover image
     * @type {string}
     * @memberof ImageFTUpdateRequest
     */
    'cover_image': string;
}
/**
 * 
 * @export
 * @interface ImageInferenceRequest
 */
export interface ImageInferenceRequest {
    /**
     * The base model to use for inference
     * @type {BaseFoundationModel}
     * @memberof ImageInferenceRequest
     */
    'base_model': BaseFoundationModel;
    /**
     * The prompt to use for inference
     * @type {string}
     * @memberof ImageInferenceRequest
     */
    'prompt': string;
    /**
     * The list of image FTs to use for inference
     * @type {Array<string>}
     * @memberof ImageInferenceRequest
     */
    'image_fts': Array<string>;
    /**
     * The number of outputs to generate
     * @type {number}
     * @memberof ImageInferenceRequest
     */
    'number_of_outputs'?: number;
    /**
     * The aspect ratio of the output images
     * @type {AspecRatio}
     * @memberof ImageInferenceRequest
     */
    'aspect_ratio'?: AspecRatio;
    /**
     * 
     * @type {number}
     * @memberof ImageInferenceRequest
     */
    'steps'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ImageInferenceRequest
     */
    'guidance_scale'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImageInferenceRequest
     */
    'styles'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImageInferenceRequest
     */
    'effects'?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ImageInferenceRequest
     */
    'use_ai_agent'?: boolean | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImageInferenceRequest
     */
    'reference_images'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImageInferenceRequest
     */
    'reference_videos'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ImageInferenceRequest
     */
    'duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ImageInferenceRequest
     */
    'resolution'?: string | null;
}


/**
 * 
 * @export
 * @interface ImageInferenceResponse
 */
export interface ImageInferenceResponse {
    /**
     * The ID of the inference
     * @type {string}
     * @memberof ImageInferenceResponse
     */
    'inference_id': string;
    /**
     * The URL of the image
     * @type {Array<string>}
     * @memberof ImageInferenceResponse
     */
    'image_url_outputs': Array<string>;
    /**
     * The date the image was created
     * @type {string}
     * @memberof ImageInferenceResponse
     */
    'date_created': string;
    /**
     * The prompt used for the inference
     * @type {string}
     * @memberof ImageInferenceResponse
     */
    'prompt': string;
    /**
     * The styles used for the inference
     * @type {Array<string>}
     * @memberof ImageInferenceResponse
     */
    'styles': Array<string>;
    /**
     * The effects used for the inference
     * @type {Array<string>}
     * @memberof ImageInferenceResponse
     */
    'effects': Array<string>;
    /**
     * The aspect ratio of the output images
     * @type {string}
     * @memberof ImageInferenceResponse
     */
    'aspect_ratio': string;
    /**
     * The AI model used for the inference
     * @type {string}
     * @memberof ImageInferenceResponse
     */
    'ai_model': string;
    /**
     * The status of the inference
     * @type {string}
     * @memberof ImageInferenceResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ImageInferenceResultResponse
 */
export interface ImageInferenceResultResponse {
    /**
     * 
     * @type {ImageInferenceResponse}
     * @memberof ImageInferenceResultResponse
     */
    'result'?: ImageInferenceResponse | null;
    /**
     * Whether the inference is completed
     * @type {string}
     * @memberof ImageInferenceResultResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ImageInferenceResultResponse
     */
    'error_message'?: string | null;
}
/**
 * 
 * @export
 * @interface ImageInferenceScheduleResponse
 */
export interface ImageInferenceScheduleResponse {
    /**
     * The ID of the inference
     * @type {string}
     * @memberof ImageInferenceScheduleResponse
     */
    'inference_id': string;
}
/**
 * 
 * @export
 * @interface ImageInferenceScrollResponse
 */
export interface ImageInferenceScrollResponse {
    /**
     * 
     * @type {Array<any>}
     * @memberof ImageInferenceScrollResponse
     */
    'search_after'?: Array<any> | null;
    /**
     * The list of inference results
     * @type {Array<ImageInferenceResponse>}
     * @memberof ImageInferenceScrollResponse
     */
    'results': Array<ImageInferenceResponse>;
}
/**
 * 
 * @export
 * @interface ImageOptimizeRequest
 */
export interface ImageOptimizeRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageOptimizeRequest
     */
    'post_back_url'?: string | null;
    /**
     * Image URL to optimize
     * @type {string}
     * @memberof ImageOptimizeRequest
     */
    'image_url': string;
    /**
     * 
     * @type {number}
     * @memberof ImageOptimizeRequest
     */
    'quality'?: number | null;
}
/**
 * 
 * @export
 * @interface ImagePromptGenerationRequest
 */
export interface ImagePromptGenerationRequest {
    /**
     * 
     * @type {string}
     * @memberof ImagePromptGenerationRequest
     */
    'current_prompt'?: string | null;
}
/**
 * 
 * @export
 * @interface ImagePromptResponse
 */
export interface ImagePromptResponse {
    /**
     * The prompt generated for the inference
     * @type {string}
     * @memberof ImagePromptResponse
     */
    'prompt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const InferenceFileType = {
    InferenceOutput: 'inference_output',
    TrainingData: 'training_data'
} as const;

export type InferenceFileType = typeof InferenceFileType[keyof typeof InferenceFileType];


/**
 * 
 * @export
 * @interface InferenceHistorySearchRequest
 */
export interface InferenceHistorySearchRequest {
    /**
     * 
     * @type {string}
     * @memberof InferenceHistorySearchRequest
     */
    'from_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InferenceHistorySearchRequest
     */
    'to_date'?: string | null;
    /**
     * The number of results to return
     * @type {number}
     * @memberof InferenceHistorySearchRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof InferenceHistorySearchRequest
     */
    'search_after'?: Array<any> | null;
    /**
     * 
     * @type {BaseFoundationModel}
     * @memberof InferenceHistorySearchRequest
     */
    'base_model'?: BaseFoundationModel | null;
    /**
     * 
     * @type {string}
     * @memberof InferenceHistorySearchRequest
     */
    'style'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InferenceHistorySearchRequest
     */
    'effect'?: string | null;
    /**
     * 
     * @type {AspecRatio}
     * @memberof InferenceHistorySearchRequest
     */
    'aspect_ratio'?: AspecRatio | null;
}


/**
 * 
 * @export
 * @interface InstagramProfileInformationResponse
 */
export interface InstagramProfileInformationResponse {
    /**
     * Instagram profile name
     * @type {string}
     * @memberof InstagramProfileInformationResponse
     */
    'user_name': string;
    /**
     * 
     * @type {string}
     * @memberof InstagramProfileInformationResponse
     */
    'profile_pic_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InstagramProfileInformationResponse
     */
    'biography'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InstagramProfileInformationResponse
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const IntegrationCategory = {
    DevTools: 'dev_tools',
    Crm: 'crm',
    SocialMedia: 'social_media',
    Ecommerce: 'ecommerce',
    Content: 'content',
    Sales: 'sales',
    Marketing: 'marketing',
    Cms: 'cms',
    Google: 'google',
    Communication: 'communication',
    Analytics: 'analytics',
    Finance: 'finance'
} as const;

export type IntegrationCategory = typeof IntegrationCategory[keyof typeof IntegrationCategory];


/**
 * 
 * @export
 * @interface IntegrationDetailResponse
 */
export interface IntegrationDetailResponse {
    /**
     * The type of the integration.
     * @type {string}
     * @memberof IntegrationDetailResponse
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationDetailResponse
     */
    'integration_id'?: string;
    /**
     * The name of the integration.
     * @type {string}
     * @memberof IntegrationDetailResponse
     */
    'integration_name': string;
    /**
     * The creation date of the integration.
     * @type {string}
     * @memberof IntegrationDetailResponse
     */
    'created_at': string;
    /**
     * The metadata of the integration.
     * @type {}
     * @memberof IntegrationDetailResponse
     */
    'metadata'?:  | null;
}
/**
 * 
 * @export
 * @interface IntegrationFlowResponse
 */
export interface IntegrationFlowResponse {
    /**
     * The URL to redirect to.
     * @type {string}
     * @memberof IntegrationFlowResponse
     */
    'redirect_to': string;
}
/**
 * 
 * @export
 * @interface IntegrationResponse
 */
export interface IntegrationResponse {
    /**
     * The slug of the integration.
     * @type {string}
     * @memberof IntegrationResponse
     */
    'slug': string;
    /**
     * The name of the integration.
     * @type {string}
     * @memberof IntegrationResponse
     */
    'name': string;
    /**
     * The description of the integration.
     * @type {string}
     * @memberof IntegrationResponse
     */
    'description': string;
    /**
     * The number of integrated instances.
     * @type {number}
     * @memberof IntegrationResponse
     */
    'integrated_instance_cnt': number;
    /**
     * The categories of the integration.
     * @type {Array<IntegrationCategory>}
     * @memberof IntegrationResponse
     */
    'categories': Array<IntegrationCategory>;
    /**
     * Whether the integration is in alpha or not.
     * @type {boolean}
     * @memberof IntegrationResponse
     */
    'alpha'?: boolean;
    /**
     * Whether the integration is in beta or not.
     * @type {boolean}
     * @memberof IntegrationResponse
     */
    'beta'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IntegrationResponse
     */
    'public_flow_id'?: string | null;
}
/**
 * 
 * @export
 * @interface IntegrationSearchRequest
 */
export interface IntegrationSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationSearchRequest
     */
    'integration_name'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const IntegrationSlug = {
    ShopifyIntegration: 'shopify_integration',
    SlackIntegration: 'slack_integration',
    HubspotIntegration: 'hubspot_integration',
    LiveagentIntegration: 'liveagent_integration',
    HubspotWidgetIntegration: 'hubspot_widget_integration',
    LivechatIntegration: 'livechat_integration',
    SmartsuppIntegration: 'smartsupp_integration',
    FreshchatIntegration: 'freshchat_integration',
    TawkIntegration: 'tawk_integration',
    GoogleIntegration: 'google_integration',
    WordpressIntegration: 'wordpress_integration',
    GmailIntegration: 'gmail_integration',
    InstagramIntegration: 'instagram_integration',
    MicrosoftOutlookIntegration: 'microsoft_outlook_integration',
    MicrosoftIntegration: 'microsoft_integration',
    OdooIntegration: 'odoo_integration',
    AtlassianTokenIntegration: 'atlassian_token_integration',
    BizniswebIntegration: 'biznisweb_integration',
    Bitrix24Integration: 'bitrix24_integration',
    ApiSportsIntegration: 'api_sports_integration',
    GithubIntegration: 'github_integration',
    PowerbiIntegration: 'powerbi_integration',
    BexioIntegration: 'bexio_integration',
    MailchimpIntegration: 'mailchimp_integration',
    LinkedinIntegration: 'linkedin_integration',
    Magento2Integration: 'magento2_integration',
    AlpacaIntegration: 'alpaca_integration',
    PolygonIntegration: 'polygon_integration',
    PostaffiliateproIntegration: 'postaffiliatepro_integration',
    KlaviyoIntegration: 'klaviyo_integration',
    GoogleCalendarIntegration: 'google_calendar_integration',
    GoogleAdsIntegration: 'google_ads_integration',
    GoogleDocsIntegration: 'google_docs_integration',
    GoogleDriveIntegration: 'google_drive_integration',
    GoogleSheetsIntegration: 'google_sheets_integration',
    GoogleTasksIntegration: 'google_tasks_integration',
    GoogleMeetIntegration: 'google_meet_integration',
    GoogleSlidesIntegration: 'google_slides_integration',
    GoogleSearchConsoleIntegration: 'google_search_console_integration',
    MicrosoftCalendarIntegration: 'microsoft_calendar_integration',
    MicrosoftExcelIntegration: 'microsoft_excel_integration',
    MicrosoftOnedriveIntegration: 'microsoft_onedrive_integration',
    MicrosoftSharepointIntegration: 'microsoft_sharepoint_integration',
    MicrosoftOnenoteIntegration: 'microsoft_onenote_integration',
    MicrosoftTodoIntegration: 'microsoft_todo_integration',
    MicrosoftPlannerIntegration: 'microsoft_planner_integration',
    MicrosoftOutlookContactsIntegration: 'microsoft_outlook_contacts_integration',
    MicrosoftTeamsIntegration: 'microsoft_teams_integration'
} as const;

export type IntegrationSlug = typeof IntegrationSlug[keyof typeof IntegrationSlug];


/**
 * 
 * @export
 * @interface LangfuseRequest
 */
export interface LangfuseRequest {
    /**
     * 
     * @type {string}
     * @memberof LangfuseRequest
     */
    'langfuse_public_key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LangfuseRequest
     */
    'langfuse_secret_key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LangfuseRequest
     */
    'langfuse_host'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LogEntryLevel = {
    I: 'I',
    W: 'W',
    E: 'E',
    D: 'D'
} as const;

export type LogEntryLevel = typeof LogEntryLevel[keyof typeof LogEntryLevel];


/**
 * 
 * @export
 * @enum {string}
 */

export const LogEntryType = {
    S: 'S',
    C: 'C',
    I: 'I',
    L: 'L',
    E: 'E'
} as const;

export type LogEntryType = typeof LogEntryType[keyof typeof LogEntryType];


/**
 * 
 * @export
 * @interface LogResponse
 */
export interface LogResponse {
    /**
     * Unique identifier for the log entry
     * @type {string}
     * @memberof LogResponse
     */
    'log_id': string;
    /**
     * Type of log (e.g., \'system\', \'application\', \'user\')
     * @type {LogEntryType}
     * @memberof LogResponse
     */
    'log_type': LogEntryType;
    /**
     * 
     * @type {string}
     * @memberof LogResponse
     */
    'category_id'?: string | null;
    /**
     * Log level (e.g., \'info\', \'warning\', \'error\', \'debug\')
     * @type {LogEntryLevel}
     * @memberof LogResponse
     */
    'log_level': LogEntryLevel;
    /**
     * Log message content
     * @type {string}
     * @memberof LogResponse
     */
    'message': string;
    /**
     * Timestamp when the log was created
     * @type {string}
     * @memberof LogResponse
     */
    'created_at': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof LogResponse
     */
    'metadata'?: { [key: string]: any; } | null;
}


/**
 * Request model for searching logs.
 * @export
 * @interface LogsSearchRequest
 */
export interface LogsSearchRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof LogsSearchRequest
     */
    'log_types'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LogsSearchRequest
     */
    'log_levels'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof LogsSearchRequest
     */
    'category_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LogsSearchRequest
     */
    'from_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LogsSearchRequest
     */
    'to_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LogsSearchRequest
     */
    'search_text'?: string | null;
    /**
     * Page number for pagination
     * @type {number}
     * @memberof LogsSearchRequest
     */
    'page'?: number;
    /**
     * Number of results per page
     * @type {number}
     * @memberof LogsSearchRequest
     */
    'page_size'?: number;
    /**
     * Field to sort results by
     * @type {string}
     * @memberof LogsSearchRequest
     */
    'sort_by'?: string;
    /**
     * Sort direction (asc or desc)
     * @type {SortDirection}
     * @memberof LogsSearchRequest
     */
    'sort_direction'?: SortDirection;
}


/**
 * Represents a binding between an MCP server and a capability
 * @export
 * @interface MCPCapabilityBinding
 */
export interface MCPCapabilityBinding {
    /**
     * 
     * @type {string}
     * @memberof MCPCapabilityBinding
     */
    'capability_id': string;
}
/**
 * Request schema for creating a new MCP server
 * @export
 * @interface MCPServerCreateRequest
 */
export interface MCPServerCreateRequest {
    /**
     * Name of the MCP server
     * @type {string}
     * @memberof MCPServerCreateRequest
     */
    'name': string;
    /**
     * Whether the MCP server is active
     * @type {boolean}
     * @memberof MCPServerCreateRequest
     */
    'is_active'?: boolean;
    /**
     * List of subserver bindings for the MCP server configuration
     * @type {Array<MCPSubServerBinding>}
     * @memberof MCPServerCreateRequest
     */
    'server_configuration': Array<MCPSubServerBinding>;
}
/**
 * Response schema for MCP server
 * @export
 * @interface MCPServerResponse
 */
export interface MCPServerResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof MCPServerResponse
     */
    'workspace_id': string;
    /**
     * MCP Server ID
     * @type {string}
     * @memberof MCPServerResponse
     */
    'mcp_server_id': string;
    /**
     * Name of the MCP server
     * @type {string}
     * @memberof MCPServerResponse
     */
    'name': string;
    /**
     * List of subserver bindings for the MCP server configuration
     * @type {Array<MCPSubServerBinding>}
     * @memberof MCPServerResponse
     */
    'server_configuration': Array<MCPSubServerBinding>;
    /**
     * Whether the MCP server is active
     * @type {boolean}
     * @memberof MCPServerResponse
     */
    'is_active': boolean;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof MCPServerResponse
     */
    'created_at': string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof MCPServerResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof MCPServerResponse
     */
    'remote_mcp_url'?: string | null;
}
/**
 * Request schema for searching MCP servers
 * @export
 * @interface MCPServerSearchRequest
 */
export interface MCPServerSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof MCPServerSearchRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MCPServerSearchRequest
     */
    'active_only'?: boolean | null;
}
/**
 * Represents a binding between an MCP server and an MCP sub server
 * @export
 * @interface MCPSubServerBinding
 */
export interface MCPSubServerBinding {
    /**
     * 
     * @type {string}
     * @memberof MCPSubServerBinding
     */
    'subserver_id': string;
    /**
     * 
     * @type {Array<MCPCapabilityBinding>}
     * @memberof MCPSubServerBinding
     */
    'capabilities': Array<MCPCapabilityBinding>;
}
/**
 * 
 * @export
 * @interface MemoryDocumentProcessRequest
 */
export interface MemoryDocumentProcessRequest {
    /**
     * Category ID
     * @type {string}
     * @memberof MemoryDocumentProcessRequest
     */
    'cat_id': string;
    /**
     * Flow ID to process the documents
     * @type {string}
     * @memberof MemoryDocumentProcessRequest
     */
    'flow_id': string;
    /**
     * List of document IDs to process
     * @type {Array<string>}
     * @memberof MemoryDocumentProcessRequest
     */
    'doc_ids': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MemoryDocumentProcessRequest
     */
    'parent_node_id'?: string | null;
}
/**
 * 
 * @export
 * @interface MemoryDocumentUploadResponse
 */
export interface MemoryDocumentUploadResponse {
    /**
     * Document ID
     * @type {string}
     * @memberof MemoryDocumentUploadResponse
     */
    'doc_id': string;
    /**
     * Document name
     * @type {string}
     * @memberof MemoryDocumentUploadResponse
     */
    'doc_name': string;
    /**
     * Upload status message
     * @type {string}
     * @memberof MemoryDocumentUploadResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface MemoryMessageResponse
 */
export interface MemoryMessageResponse {
    /**
     * Response message
     * @type {string}
     * @memberof MemoryMessageResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface MemoryNodeDetailResponse
 */
export interface MemoryNodeDetailResponse {
    /**
     * Node ID
     * @type {string}
     * @memberof MemoryNodeDetailResponse
     */
    'node_id': string;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeDetailResponse
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MemoryNodeDetailResponse
     */
    'depth'?: number | null;
    /**
     * 
     * @type {NodeType}
     * @memberof MemoryNodeDetailResponse
     */
    'node_type'?: NodeType | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeDetailResponse
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeDetailResponse
     */
    'body'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeDetailResponse
     */
    'path'?: string | null;
}


/**
 * 
 * @export
 * @interface MemoryNodeNameSearchRequest
 */
export interface MemoryNodeNameSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeNameSearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeNameSearchRequest
     */
    'query'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MemoryNodeNameSearchRequest
     */
    'depth'?: number | null;
}
/**
 * 
 * @export
 * @interface MemoryNodePathSearchRequest
 */
export interface MemoryNodePathSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryNodePathSearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodePathSearchRequest
     */
    'node_path'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MemoryNodePathSearchRequest
     */
    'depth'?: number | null;
}
/**
 * 
 * @export
 * @interface MemoryNodeResponse
 */
export interface MemoryNodeResponse {
    /**
     * Node ID
     * @type {string}
     * @memberof MemoryNodeResponse
     */
    'node_id': string;
    /**
     * 
     * @type {NodeType}
     * @memberof MemoryNodeResponse
     */
    'node_type'?: NodeType | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeResponse
     */
    'parent_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeResponse
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeResponse
     */
    'body'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemoryNodeResponse
     */
    'path'?: string | null;
}


/**
 * 
 * @export
 * @interface MemorySearchRequest
 */
export interface MemorySearchRequest {
    /**
     * 
     * @type {string}
     * @memberof MemorySearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemorySearchRequest
     */
    'query'?: string | null;
    /**
     * 
     * @type {SearchType}
     * @memberof MemorySearchRequest
     */
    'search_method'?: SearchType | null;
    /**
     * 
     * @type {number}
     * @memberof MemorySearchRequest
     */
    'depth'?: number | null;
}


/**
 * 
 * @export
 * @interface MemorySearchResponse
 */
export interface MemorySearchResponse {
    /**
     * Node ID
     * @type {string}
     * @memberof MemorySearchResponse
     */
    'node_id': string;
    /**
     * 
     * @type {NodeType}
     * @memberof MemorySearchResponse
     */
    'node_type'?: NodeType | null;
    /**
     * 
     * @type {string}
     * @memberof MemorySearchResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemorySearchResponse
     */
    'path'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MemorySearchResponse
     */
    'parent_id'?: string | null;
    /**
     * 
     * @type {Array<MemorySearchResponse>}
     * @memberof MemorySearchResponse
     */
    'children'?: Array<MemorySearchResponse> | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const MessageFeedback = {
    P: 'P',
    N: 'N'
} as const;

export type MessageFeedback = typeof MessageFeedback[keyof typeof MessageFeedback];


/**
 * 
 * @export
 * @enum {string}
 */

export const MessageType = {
    Ai: 'ai',
    Human: 'human',
    System: 'system',
    FlowAssistantAction: 'flow_assistant_action'
} as const;

export type MessageType = typeof MessageType[keyof typeof MessageType];


/**
 * Metadata
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * Message ID
     * @type {string}
     * @memberof Metadata
     */
    'message_id': string;
    /**
     * Message
     * @type {string}
     * @memberof Metadata
     */
    'message': string;
    /**
     * 
     * @type {HumanAgentSender}
     * @memberof Metadata
     */
    'sender'?: HumanAgentSender;
    /**
     * Tool name
     * @type {string}
     * @memberof Metadata
     */
    'tool_name': string;
    /**
     * Loading description
     * @type {string}
     * @memberof Metadata
     */
    'loading_desc': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'icon'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'detailed_description'?: string;
    /**
     * Message ID
     * @type {string}
     * @memberof Metadata
     */
    'feedback_message_id': string;
    /**
     * 
     * @type {MessageFeedback}
     * @memberof Metadata
     */
    'feedback'?: MessageFeedback;
    /**
     * Search query
     * @type {string}
     * @memberof Metadata
     */
    'agent_query': string;
    /**
     * Tool response
     * @type {string}
     * @memberof Metadata
     */
    'tool_response': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'task_name': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'task_input': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'agent': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'task_response': string;
    /**
     * Action ID
     * @type {string}
     * @memberof Metadata
     */
    'action_id': string;
    /**
     * Component ID
     * @type {string}
     * @memberof Metadata
     */
    'component_id': string;
    /**
     * Component name
     * @type {string}
     * @memberof Metadata
     */
    'component_type': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'component_display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'component_icon'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Metadata
     */
    'parameter_values'?: { [key: string]: any; };
    /**
     * Source component ID
     * @type {string}
     * @memberof Metadata
     */
    'source_component_id': string;
    /**
     * Target component ID
     * @type {string}
     * @memberof Metadata
     */
    'target_component_id': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'source_field_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'target_field_name'?: string;
    /**
     * Flow name
     * @type {string}
     * @memberof Metadata
     */
    'flow_name': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'flow_description'?: string;
    /**
     * Flow ID
     * @type {string}
     * @memberof Metadata
     */
    'flow_id': string;
}


/**
 * 
 * @export
 * @interface MicrosoftPowerBiDatasetResponse
 */
export interface MicrosoftPowerBiDatasetResponse {
    /**
     * Dataset ID
     * @type {string}
     * @memberof MicrosoftPowerBiDatasetResponse
     */
    'dataset_id': string;
    /**
     * Dataset name
     * @type {string}
     * @memberof MicrosoftPowerBiDatasetResponse
     */
    'dataset_name': string;
}
/**
 * 
 * @export
 * @interface MicrosoftPowerBiDatasetsResponse
 */
export interface MicrosoftPowerBiDatasetsResponse {
    /**
     * 
     * @type {Array<MicrosoftPowerBiDatasetResponse>}
     * @memberof MicrosoftPowerBiDatasetsResponse
     */
    'datasets': Array<MicrosoftPowerBiDatasetResponse>;
}
/**
 * 
 * @export
 * @interface MicrosoftPowerBiPushDatasetResponse
 */
export interface MicrosoftPowerBiPushDatasetResponse {
    /**
     * Power BI workspace ID
     * @type {string}
     * @memberof MicrosoftPowerBiPushDatasetResponse
     */
    'workspace_pbi_id': string;
    /**
     * Dataset ID
     * @type {string}
     * @memberof MicrosoftPowerBiPushDatasetResponse
     */
    'dataset_id': string;
    /**
     * Table name
     * @type {string}
     * @memberof MicrosoftPowerBiPushDatasetResponse
     */
    'table_name': string;
}
/**
 * 
 * @export
 * @interface MicrosoftPowerBiTableResponse
 */
export interface MicrosoftPowerBiTableResponse {
    /**
     * Table name
     * @type {string}
     * @memberof MicrosoftPowerBiTableResponse
     */
    'table_name': string;
}
/**
 * 
 * @export
 * @interface MicrosoftPowerBiTableValidateResponse
 */
export interface MicrosoftPowerBiTableValidateResponse {
    /**
     * Indicates if the table is valid
     * @type {boolean}
     * @memberof MicrosoftPowerBiTableValidateResponse
     */
    'valid': boolean;
}
/**
 * 
 * @export
 * @interface MicrosoftPowerBiTablesResponse
 */
export interface MicrosoftPowerBiTablesResponse {
    /**
     * 
     * @type {Array<MicrosoftPowerBiTableResponse>}
     * @memberof MicrosoftPowerBiTablesResponse
     */
    'tables': Array<MicrosoftPowerBiTableResponse>;
}
/**
 * 
 * @export
 * @interface MicrosoftPowerBiWorkspaceResponse
 */
export interface MicrosoftPowerBiWorkspaceResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof MicrosoftPowerBiWorkspaceResponse
     */
    'workspace_id': string;
    /**
     * Workspace name
     * @type {string}
     * @memberof MicrosoftPowerBiWorkspaceResponse
     */
    'workspace_name': string;
}
/**
 * 
 * @export
 * @interface MicrosoftPowerBiWorkspacesResponse
 */
export interface MicrosoftPowerBiWorkspacesResponse {
    /**
     * 
     * @type {Array<MicrosoftPowerBiWorkspaceResponse>}
     * @memberof MicrosoftPowerBiWorkspacesResponse
     */
    'workspaces': Array<MicrosoftPowerBiWorkspaceResponse>;
}
/**
 * 
 * @export
 * @interface NodeDetailRequest
 */
export interface NodeDetailRequest {
    /**
     * 
     * @type {string}
     * @memberof NodeDetailRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NodeDetailRequest
     */
    'parent_node_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NodeDetailRequest
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NodeDetailRequest
     */
    'body'?: string | null;
    /**
     * 
     * @type {NodeType}
     * @memberof NodeDetailRequest
     */
    'node_type'?: NodeType | null;
    /**
     * 
     * @type {number}
     * @memberof NodeDetailRequest
     */
    'position'?: number | null;
    /**
     * 
     * @type {Array<Source>}
     * @memberof NodeDetailRequest
     */
    'sources'?: Array<Source> | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const NodeType = {
    C: 'C',
    L: 'L'
} as const;

export type NodeType = typeof NodeType[keyof typeof NodeType];


/**
 * 
 * @export
 * @interface NodeUpdateRequest
 */
export interface NodeUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof NodeUpdateRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NodeUpdateRequest
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NodeUpdateRequest
     */
    'body'?: string | null;
}
/**
 * 
 * @export
 * @interface ObservabilityDriverResponse
 */
export interface ObservabilityDriverResponse {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverResponse
     */
    'driver_type': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ObservabilityDriverResponse
     */
    'additional_data'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {string}
     * @memberof Pagination
     */
    'sorting_key_value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Pagination
     */
    'scroll_id'?: string | null;
}
/**
 * 
 * @export
 * @interface PerDayFeedback
 */
export interface PerDayFeedback {
    /**
     * Date in YYYY-MM-DD format
     * @type {string}
     * @memberof PerDayFeedback
     */
    'date': string;
    /**
     * Count of positive feedback
     * @type {number}
     * @memberof PerDayFeedback
     */
    'positive'?: number;
    /**
     * Count of negative feedback
     * @type {number}
     * @memberof PerDayFeedback
     */
    'negative'?: number;
    /**
     * Count of unique sessions (visitor count)
     * @type {number}
     * @memberof PerDayFeedback
     */
    'session_count'?: number;
    /**
     * Count of human messages
     * @type {number}
     * @memberof PerDayFeedback
     */
    'human_message_count'?: number;
    /**
     * Count of tool calls
     * @type {number}
     * @memberof PerDayFeedback
     */
    'tool_calling_count'?: number;
}
/**
 * 
 * @export
 * @interface PerDaySessionDurationResponse
 */
export interface PerDaySessionDurationResponse {
    /**
     * Date in YYYY-MM-DD format
     * @type {string}
     * @memberof PerDaySessionDurationResponse
     */
    'date': string;
    /**
     * Average session duration in seconds
     * @type {number}
     * @memberof PerDaySessionDurationResponse
     */
    'average_duration'?: number;
    /**
     * Count of unique sessions (visitor count)
     * @type {number}
     * @memberof PerDaySessionDurationResponse
     */
    'session_count'?: number;
}
/**
 * 
 * @export
 * @interface PhotoAIEffectResponse
 */
export interface PhotoAIEffectResponse {
    /**
     * 
     * @type {string}
     * @memberof PhotoAIEffectResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIEffectResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIEffectResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIEffectResponse
     */
    'cover_image': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIEffectResponse
     */
    'prompt': string;
    /**
     * 
     * @type {boolean}
     * @memberof PhotoAIEffectResponse
     */
    'featured'?: boolean;
}
/**
 * 
 * @export
 * @interface PhotoAIStyleResponse
 */
export interface PhotoAIStyleResponse {
    /**
     * 
     * @type {string}
     * @memberof PhotoAIStyleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIStyleResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIStyleResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIStyleResponse
     */
    'cover_image': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAIStyleResponse
     */
    'prompt': string;
    /**
     * 
     * @type {boolean}
     * @memberof PhotoAIStyleResponse
     */
    'featured'?: boolean;
}
/**
 * 
 * @export
 * @interface PhotoAITemplateResponse
 */
export interface PhotoAITemplateResponse {
    /**
     * 
     * @type {string}
     * @memberof PhotoAITemplateResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAITemplateResponse
     */
    'cover_image': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAITemplateResponse
     */
    'prompt': string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAITemplateResponse
     */
    'model': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PhotoAITemplateResponse
     */
    'styles': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PhotoAITemplateResponse
     */
    'effects': Array<string>;
}
/**
 * 
 * @export
 * @interface PlanListItemResponse
 */
export interface PlanListItemResponse {
    /**
     * 
     * @type {string}
     * @memberof PlanListItemResponse
     */
    'product_id': string;
    /**
     * 
     * @type {string}
     * @memberof PlanListItemResponse
     */
    'price_id': string;
    /**
     * 
     * @type {string}
     * @memberof PlanListItemResponse
     */
    'currency': string;
    /**
     * 
     * @type {number}
     * @memberof PlanListItemResponse
     */
    'amount_monthly': number;
    /**
     * 
     * @type {number}
     * @memberof PlanListItemResponse
     */
    'amount_yearly'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PlanListItemResponse
     */
    'recurring': boolean;
    /**
     * 
     * @type {string}
     * @memberof PlanListItemResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlanListItemResponse
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof PlanListItemResponse
     */
    'popular': boolean;
    /**
     * 
     * @type {number}
     * @memberof PlanListItemResponse
     */
    'monthly_credits': number;
    /**
     * 
     * @type {Array<FeatureResponse>}
     * @memberof PlanListItemResponse
     */
    'features': Array<FeatureResponse>;
    /**
     * 
     * @type {SubscriptionPlan}
     * @memberof PlanListItemResponse
     */
    'subscription_plan': SubscriptionPlan | null;
    /**
     * 
     * @type {boolean}
     * @memberof PlanListItemResponse
     */
    'self_hosted'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PlanListItemResponse
     */
    'addon'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PlanListItemResponse
     */
    'addon_type'?: string | null;
}


/**
 * 
 * @export
 * @interface PlanResponse
 */
export interface PlanResponse {
    /**
     * 
     * @type {{ [key: string]: Array<PlanListItemResponse>; }}
     * @memberof PlanResponse
     */
    'plans': { [key: string]: Array<PlanListItemResponse>; };
    /**
     * 
     * @type {BillingProvider}
     * @memberof PlanResponse
     */
    'billing_provider'?: BillingProvider | null;
    /**
     * 
     * @type {string}
     * @memberof PlanResponse
     */
    'shopify_manage_url'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PointerType = {
    C: 'C',
    J: 'J',
    I: 'I',
    O: 'O',
    A: 'A',
    U: 'U'
} as const;

export type PointerType = typeof PointerType[keyof typeof PointerType];


/**
 * 
 * @export
 * @interface PowerBiDatasetRequest
 */
export interface PowerBiDatasetRequest {
    /**
     * 
     * @type {string}
     * @memberof PowerBiDatasetRequest
     */
    'workspace_pbi_id'?: string | null;
}
/**
 * 
 * @export
 * @interface PowerBiPushDatasetRequest
 */
export interface PowerBiPushDatasetRequest {
    /**
     * 
     * @type {string}
     * @memberof PowerBiPushDatasetRequest
     */
    'workspace_pbi_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PowerBiPushDatasetRequest
     */
    'dataset_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PowerBiPushDatasetRequest
     */
    'table_name'?: string | null;
}
/**
 * 
 * @export
 * @interface PowerBiRequest
 */
export interface PowerBiRequest {
    /**
     * 
     * @type {string}
     * @memberof PowerBiRequest
     */
    'workspace_pbi_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PowerBiRequest
     */
    'dataset_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PowerBiRequest
     */
    'table_name'?: string | null;
}
/**
 * 
 * @export
 * @interface PowerBiTableRequest
 */
export interface PowerBiTableRequest {
    /**
     * 
     * @type {string}
     * @memberof PowerBiTableRequest
     */
    'workspace_pbi_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PowerBiTableRequest
     */
    'dataset_id'?: string | null;
}
/**
 * 
 * @export
 * @interface PromptCategoryCreateRequest
 */
export interface PromptCategoryCreateRequest {
    /**
     * Category name
     * @type {string}
     * @memberof PromptCategoryCreateRequest
     */
    'cat_name': string;
    /**
     * Category color
     * @type {string}
     * @memberof PromptCategoryCreateRequest
     */
    'color': string;
    /**
     * 
     * @type {string}
     * @memberof PromptCategoryCreateRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface PromptCategoryResponse
 */
export interface PromptCategoryResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof PromptCategoryResponse
     */
    'workspace_id': string;
    /**
     * Category ID
     * @type {string}
     * @memberof PromptCategoryResponse
     */
    'cat_id': string;
    /**
     * Category name
     * @type {string}
     * @memberof PromptCategoryResponse
     */
    'cat_name': string;
    /**
     * Category color
     * @type {string}
     * @memberof PromptCategoryResponse
     */
    'color': string;
    /**
     * 
     * @type {string}
     * @memberof PromptCategoryResponse
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface PromptCategorySearchRequest
 */
export interface PromptCategorySearchRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptCategorySearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptCategorySearchRequest
     */
    'cat_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptCategorySearchRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PromptCategorySearchRequest
     */
    'limit'?: number | null;
}
/**
 * 
 * @export
 * @interface PromptCategoryUpdateRequest
 */
export interface PromptCategoryUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptCategoryUpdateRequest
     */
    'cat_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptCategoryUpdateRequest
     */
    'color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptCategoryUpdateRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface PromptCreateRequest
 */
export interface PromptCreateRequest {
    /**
     * Category ID
     * @type {string}
     * @memberof PromptCreateRequest
     */
    'cat_id': string;
    /**
     * Document name
     * @type {string}
     * @memberof PromptCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PromptCreateRequest
     */
    'description'?: string | null;
    /**
     * Prompt text
     * @type {string}
     * @memberof PromptCreateRequest
     */
    'prompt_text': string;
    /**
     * 
     * @type {AppUrlInput}
     * @memberof PromptCreateRequest
     */
    'prompt_url'?: AppUrlInput | null;
}
/**
 * 
 * @export
 * @interface PromptResponse
 */
export interface PromptResponse {
    /**
     * Prompt ID
     * @type {string}
     * @memberof PromptResponse
     */
    'prompt_id': string;
    /**
     * Category ID
     * @type {string}
     * @memberof PromptResponse
     */
    'cat_id': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof PromptResponse
     */
    'workspace_id': string;
    /**
     * Prompt name
     * @type {string}
     * @memberof PromptResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PromptResponse
     */
    'description'?: string | null;
    /**
     * Prompt text
     * @type {string}
     * @memberof PromptResponse
     */
    'prompt_text': string;
    /**
     * 
     * @type {string}
     * @memberof PromptResponse
     */
    'prompt_url'?: string | null;
}
/**
 * 
 * @export
 * @interface PromptSearchRequest
 */
export interface PromptSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptSearchRequest
     */
    'prompt_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptSearchRequest
     */
    'cat_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptSearchRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptSearchRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptSearchRequest
     */
    'prompt_text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptSearchRequest
     */
    'prompt_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PromptSearchRequest
     */
    'limit'?: number | null;
}
/**
 * 
 * @export
 * @interface PromptUpdateRequest
 */
export interface PromptUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptUpdateRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptUpdateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptUpdateRequest
     */
    'prompt_text'?: string | null;
    /**
     * 
     * @type {AppUrlInput}
     * @memberof PromptUpdateRequest
     */
    'prompt_url'?: AppUrlInput | null;
    /**
     * 
     * @type {string}
     * @memberof PromptUpdateRequest
     */
    'cat_id'?: string | null;
}
/**
 * 
 * @export
 * @interface QuerySimilarityRequest
 */
export interface QuerySimilarityRequest {
    /**
     * 
     * @type {VectorDocumentType}
     * @memberof QuerySimilarityRequest
     */
    'document_type'?: VectorDocumentType | null;
    /**
     * 
     * @type {PointerType}
     * @memberof QuerySimilarityRequest
     */
    'pointer_type'?: PointerType | null;
    /**
     * 
     * @type {string}
     * @memberof QuerySimilarityRequest
     */
    'schema_type'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityRequest
     */
    'score_trheshold'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof QuerySimilarityRequest
     */
    'with_vectors'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityRequest
     */
    'pointer_position_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityRequest
     */
    'pointer_position_to'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityRequest
     */
    'vector_id_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityRequest
     */
    'vector_id_to'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof QuerySimilarityRequest
     */
    'filter_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuerySimilarityRequest
     */
    'filter_domains'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof QuerySimilarityRequest
     */
    'query'?: string;
}


/**
 * 
 * @export
 * @interface QuerySimilarityTaskRequest
 */
export interface QuerySimilarityTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof QuerySimilarityTaskRequest
     */
    'post_back_url'?: string | null;
    /**
     * 
     * @type {VectorDocumentType}
     * @memberof QuerySimilarityTaskRequest
     */
    'document_type'?: VectorDocumentType | null;
    /**
     * 
     * @type {PointerType}
     * @memberof QuerySimilarityTaskRequest
     */
    'pointer_type'?: PointerType | null;
    /**
     * 
     * @type {string}
     * @memberof QuerySimilarityTaskRequest
     */
    'schema_type'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityTaskRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityTaskRequest
     */
    'score_trheshold'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof QuerySimilarityTaskRequest
     */
    'with_vectors'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityTaskRequest
     */
    'pointer_position_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityTaskRequest
     */
    'pointer_position_to'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityTaskRequest
     */
    'vector_id_from'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuerySimilarityTaskRequest
     */
    'vector_id_to'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof QuerySimilarityTaskRequest
     */
    'filter_url'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuerySimilarityTaskRequest
     */
    'filter_domains'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof QuerySimilarityTaskRequest
     */
    'query'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ReindexDataSource = {
    Documents: 'documents',
    Faqs: 'faqs',
    Schedules: 'schedules'
} as const;

export type ReindexDataSource = typeof ReindexDataSource[keyof typeof ReindexDataSource];


/**
 * 
 * @export
 * @interface ReindexProgress
 */
export interface ReindexProgress {
    /**
     * 
     * @type {string}
     * @memberof ReindexProgress
     */
    'workspace_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReindexProgress
     */
    'embedding_model': string;
    /**
     * 
     * @type {ReindexStatus}
     * @memberof ReindexProgress
     */
    'status': ReindexStatus;
    /**
     * 
     * @type {ReindexDataSource}
     * @memberof ReindexProgress
     */
    'data_source': ReindexDataSource;
    /**
     * 
     * @type {number}
     * @memberof ReindexProgress
     */
    'total_items'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReindexProgress
     */
    'processed_items'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReindexProgress
     */
    'failed_items'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReindexProgress
     */
    'started_at': string;
    /**
     * 
     * @type {string}
     * @memberof ReindexProgress
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof ReindexProgress
     */
    'completed_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReindexProgress
     */
    'error_message'?: string | null;
}


/**
 * 
 * @export
 * @interface ReindexRequest
 */
export interface ReindexRequest {
    /**
     * 
     * @type {string}
     * @memberof ReindexRequest
     */
    'workspace_id'?: string | null;
    /**
     * Name of the embedding model to use
     * @type {string}
     * @memberof ReindexRequest
     */
    'embedding_model': string;
    /**
     * Number of items to process in each batch
     * @type {number}
     * @memberof ReindexRequest
     */
    'batch_size'?: number;
    /**
     * Force reindex even if the embedding model is already up-to-date
     * @type {boolean}
     * @memberof ReindexRequest
     */
    'force_reindex'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ReindexScope = {
    Installation: 'installation',
    Workspace: 'workspace'
} as const;

export type ReindexScope = typeof ReindexScope[keyof typeof ReindexScope];


/**
 * 
 * @export
 * @interface ReindexStartResponse
 */
export interface ReindexStartResponse {
    /**
     * 
     * @type {string}
     * @memberof ReindexStartResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ReindexStartResponse
     */
    'task_id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ReindexStatus = {
    Pending: 'pending',
    InProgress: 'in_progress',
    Completed: 'completed',
    Failed: 'failed',
    Cancelled: 'cancelled'
} as const;

export type ReindexStatus = typeof ReindexStatus[keyof typeof ReindexStatus];


/**
 * 
 * @export
 * @interface ReindexStatusResponse
 */
export interface ReindexStatusResponse {
    /**
     * 
     * @type {ReindexScope}
     * @memberof ReindexStatusResponse
     */
    'scope': ReindexScope;
    /**
     * 
     * @type {string}
     * @memberof ReindexStatusResponse
     */
    'workspace_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReindexStatusResponse
     */
    'embedding_model': string;
    /**
     * 
     * @type {ReindexStatus}
     * @memberof ReindexStatusResponse
     */
    'overall_status': ReindexStatus;
    /**
     * 
     * @type {{ [key: string]: ReindexProgress; }}
     * @memberof ReindexStatusResponse
     */
    'sources': { [key: string]: ReindexProgress; };
    /**
     * 
     * @type {string}
     * @memberof ReindexStatusResponse
     */
    'collection_name': string;
    /**
     * 
     * @type {string}
     * @memberof ReindexStatusResponse
     */
    'new_collection_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReindexStatusResponse
     */
    'started_at': string;
    /**
     * 
     * @type {string}
     * @memberof ReindexStatusResponse
     */
    'completed_at'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const Role = {
    O: 'O',
    A: 'A',
    E: 'E',
    M: 'M',
    G: 'G'
} as const;

export type Role = typeof Role[keyof typeof Role];


/**
 * 
 * @export
 * @enum {string}
 */

export const SamlLoginMethod = {
    F: 'f',
    A: 'a'
} as const;

export type SamlLoginMethod = typeof SamlLoginMethod[keyof typeof SamlLoginMethod];


/**
 * 
 * @export
 * @interface ScheduleCreateRequest
 */
export interface ScheduleCreateRequest {
    /**
     * 
     * @type {AppUrlInput}
     * @memberof ScheduleCreateRequest
     */
    'url': AppUrlInput;
    /**
     * 
     * @type {ScheduleFrequency}
     * @memberof ScheduleCreateRequest
     */
    'frequency': ScheduleFrequency;
    /**
     * 
     * @type {ScheduleType}
     * @memberof ScheduleCreateRequest
     */
    'schedule_type': ScheduleType;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleCreateRequest
     */
    'with_screenshot'?: BoolChar | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleCreateRequest
     */
    'with_browser'?: BoolChar | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleCreateRequest
     */
    'follow_links'?: BoolChar | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'with_proxy_rotation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'disallow_urls'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'filter_urls'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'custom_headers'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'urls_extra_config'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ScheduleFrequency = {
    D: 'D',
    W: 'W',
    M: 'M',
    Y: 'Y'
} as const;

export type ScheduleFrequency = typeof ScheduleFrequency[keyof typeof ScheduleFrequency];


/**
 * 
 * @export
 * @interface ScheduleResponse
 */
export interface ScheduleResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof ScheduleResponse
     */
    'workspace_id': string;
    /**
     * Schedule ID
     * @type {string}
     * @memberof ScheduleResponse
     */
    'schedule_id': string;
    /**
     * URL to be scheduled
     * @type {string}
     * @memberof ScheduleResponse
     */
    'url': string;
    /**
     * Frequency of the schedule D - Daily, W - Weekly, M - Monthly, Y - Yearly
     * @type {ScheduleFrequency}
     * @memberof ScheduleResponse
     */
    'frequency': ScheduleFrequency;
    /**
     * Type of the schedule (U - URL, D - Domain, S - Sitemap)
     * @type {ScheduleType}
     * @memberof ScheduleResponse
     */
    'schedule_type': ScheduleType;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'start_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'end_time'?: string | null;
    /**
     * Status of the schedule (N - New, F - Finished, P - Pending, E - Error, C - Cancelled
     * @type {ScheduleStatus}
     * @memberof ScheduleResponse
     */
    'status': ScheduleStatus;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'status_message'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ScheduleResponse
     */
    'cnt_scheduled': number | null;
    /**
     * 
     * @type {number}
     * @memberof ScheduleResponse
     */
    'cnt_completed': number | null;
    /**
     * 
     * @type {number}
     * @memberof ScheduleResponse
     */
    'cnt_failed': number | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleResponse
     */
    'with_screenshot': BoolChar | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleResponse
     */
    'with_browser': BoolChar | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleResponse
     */
    'follow_links': BoolChar | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'with_proxy_rotation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'disallow_urls'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'filter_urls'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'custom_headers'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponse
     */
    'urls_extra_config'?: string | null;
}


/**
 * 
 * @export
 * @interface ScheduleSearchRequest
 */
export interface ScheduleSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof ScheduleSearchRequest
     */
    'domain_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleSearchRequest
     */
    'url'?: string | null;
    /**
     * 
     * @type {ScheduleStatus}
     * @memberof ScheduleSearchRequest
     */
    'status'?: ScheduleStatus | null;
    /**
     * 
     * @type {ScheduleType}
     * @memberof ScheduleSearchRequest
     */
    'schedule_type'?: ScheduleType | null;
    /**
     * Limit of the search
     * @type {number}
     * @memberof ScheduleSearchRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {Pagination}
     * @memberof ScheduleSearchRequest
     */
    'pagination'?: Pagination | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ScheduleStatus = {
    N: 'N',
    F: 'F',
    P: 'P',
    E: 'E',
    C: 'C'
} as const;

export type ScheduleStatus = typeof ScheduleStatus[keyof typeof ScheduleStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const ScheduleType = {
    U: 'U',
    D: 'D',
    S: 'S',
    Y: 'Y',
    L: 'L'
} as const;

export type ScheduleType = typeof ScheduleType[keyof typeof ScheduleType];


/**
 * 
 * @export
 * @interface ScheduleUpdateRequest
 */
export interface ScheduleUpdateRequest {
    /**
     * 
     * @type {ScheduleFrequency}
     * @memberof ScheduleUpdateRequest
     */
    'frequency'?: ScheduleFrequency | null;
    /**
     * 
     * @type {ScheduleStatus}
     * @memberof ScheduleUpdateRequest
     */
    'status'?: ScheduleStatus | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleUpdateRequest
     */
    'with_screenshot'?: BoolChar | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleUpdateRequest
     */
    'with_browser'?: BoolChar | null;
    /**
     * 
     * @type {BoolChar}
     * @memberof ScheduleUpdateRequest
     */
    'follow_links'?: BoolChar | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'with_proxy_rotation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'disallow_urls'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'filter_urls'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'custom_headers'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'urls_extra_config'?: string | null;
}


/**
 * 
 * @export
 * @interface ScheduleUrlDetailResponse
 */
export interface ScheduleUrlDetailResponse {
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'schedule_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'domain_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'url_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'last_text_timestamp': string | null;
    /**
     * 
     * @type {UrlScreenshotResponse}
     * @memberof ScheduleUrlDetailResponse
     */
    'page_screenshot': UrlScreenshotResponse | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'url_title': string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'url_meta_description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'url_og_image': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ScheduleUrlDetailResponse
     */
    'is_original_url': boolean;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'dest_url_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlDetailResponse
     */
    'created_at': string;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof ScheduleUrlDetailResponse
     */
    'url_text': Array<{ [key: string]: string; }> | null;
}
/**
 * 
 * @export
 * @interface ScheduleUrlResponse
 */
export interface ScheduleUrlResponse {
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'schedule_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'domain_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'url_id': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'last_text_timestamp': string | null;
    /**
     * 
     * @type {UrlScreenshotResponse}
     * @memberof ScheduleUrlResponse
     */
    'page_screenshot': UrlScreenshotResponse | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'url_title': string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'url_meta_description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'url_og_image': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ScheduleUrlResponse
     */
    'is_original_url': boolean;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'dest_url_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlResponse
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface ScheduleUrlSearchRequest
 */
export interface ScheduleUrlSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'schedule_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'domain_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'url_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'text_timestamp_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'text_timestamp_to'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'url_title'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ScheduleUrlSearchRequest
     */
    'is_original_url'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'created_at_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScheduleUrlSearchRequest
     */
    'created_at_to'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ScheduleUrlSearchRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {Pagination}
     * @memberof ScheduleUrlSearchRequest
     */
    'pagination'?: Pagination | null;
}
/**
 * 
 * @export
 * @interface ScreenshotRequest
 */
export interface ScreenshotRequest {
    /**
     * 
     * @type {string}
     * @memberof ScreenshotRequest
     */
    'post_back_url'?: string | null;
    /**
     * URL to take screenshot
     * @type {string}
     * @memberof ScreenshotRequest
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ScreenshotRequest
     */
    'validity'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenshotRequest
     */
    'use_proxy'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ScreenshotResponse
 */
export interface ScreenshotResponse {
    /**
     * Task ID
     * @type {string}
     * @memberof ScreenshotResponse
     */
    'id': string;
    /**
     * Task status
     * @type {TaskStatus}
     * @memberof ScreenshotResponse
     */
    'status': TaskStatus;
    /**
     * 
     * @type {string}
     * @memberof ScreenshotResponse
     */
    'result'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScreenshotResponse
     */
    'error_message'?: string | null;
    /**
     * 
     * @type {AppUrlOutput}
     * @memberof ScreenshotResponse
     */
    'original_size_url'?: AppUrlOutput | null;
    /**
     * 
     * @type {AppUrlOutput}
     * @memberof ScreenshotResponse
     */
    'thumbnail_url'?: AppUrlOutput | null;
    /**
     * 
     * @type {AppUrlOutput}
     * @memberof ScreenshotResponse
     */
    'original_size_url_full_page'?: AppUrlOutput | null;
    /**
     * 
     * @type {AppUrlOutput}
     * @memberof ScreenshotResponse
     */
    'thumbnail_url_full_page'?: AppUrlOutput | null;
    /**
     * 
     * @type {number}
     * @memberof ScreenshotResponse
     */
    'timestamp'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ScreenshotResponse
     */
    'domain_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ScreenshotResponse
     */
    'url_id'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SearchType = {
    Text: 'text',
    Vector: 'vector',
    Hybrid: 'hybrid'
} as const;

export type SearchType = typeof SearchType[keyof typeof SearchType];


/**
 * 
 * @export
 * @interface SecretCreateRequest
 */
export interface SecretCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof SecretCreateRequest
     */
    'secret_display_name': string;
    /**
     * 
     * @type {string}
     * @memberof SecretCreateRequest
     */
    'secret_value': string;
}
/**
 * 
 * @export
 * @interface SecretResponse
 */
export interface SecretResponse {
    /**
     * 
     * @type {string}
     * @memberof SecretResponse
     */
    'secret_id': string;
    /**
     * 
     * @type {string}
     * @memberof SecretResponse
     */
    'secret_display_name': string;
    /**
     * 
     * @type {string}
     * @memberof SecretResponse
     */
    'secret_value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SecretResponse
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface SecretSearchRequest
 */
export interface SecretSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SecretSearchRequest
     */
    'secret_display_name'?: string | null;
}
/**
 * 
 * @export
 * @interface SecretUpdateRequest
 */
export interface SecretUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof SecretUpdateRequest
     */
    'secret_display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SecretUpdateRequest
     */
    'secret_value'?: string | null;
}
/**
 * 
 * @export
 * @interface SerpClusterAddQueryRequest
 */
export interface SerpClusterAddQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof SerpClusterAddQueryRequest
     */
    'post_back_url'?: string | null;
    /**
     * List of queries
     * @type {Array<SerpKeyword>}
     * @memberof SerpClusterAddQueryRequest
     */
    'queries': Array<SerpKeyword>;
    /**
     * Customer ID of cluster
     * @type {string}
     * @memberof SerpClusterAddQueryRequest
     */
    'customer_id'?: string;
    /**
     * Campaign ID of cluster
     * @type {string}
     * @memberof SerpClusterAddQueryRequest
     */
    'campaign_id'?: string;
    /**
     * Group ID of cluster - will be generated if not provided
     * @type {string}
     * @memberof SerpClusterAddQueryRequest
     */
    'group_id'?: string;
    /**
     * Group name of cluster
     * @type {string}
     * @memberof SerpClusterAddQueryRequest
     */
    'group_name'?: string;
}
/**
 * 
 * @export
 * @interface SerpClusterAddQueryRequests
 */
export interface SerpClusterAddQueryRequests {
    /**
     * List of serp requests
     * @type {Array<SerpClusterAddQueryRequest>}
     * @memberof SerpClusterAddQueryRequests
     */
    'requests': Array<SerpClusterAddQueryRequest>;
}
/**
 * 
 * @export
 * @interface SerpClusterBestGroupsRequest
 */
export interface SerpClusterBestGroupsRequest {
    /**
     * 
     * @type {string}
     * @memberof SerpClusterBestGroupsRequest
     */
    'keyword_id'?: string | null;
    /**
     * Keyword to search
     * @type {string}
     * @memberof SerpClusterBestGroupsRequest
     */
    'keyword': string;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterBestGroupsRequest
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterBestGroupsRequest
     */
    'country'?: string | null;
    /**
     * 
     * @type {SerpSearchEngineType}
     * @memberof SerpClusterBestGroupsRequest
     */
    'search_engine'?: SerpSearchEngineType | null;
    /**
     * Customer ID of cluster
     * @type {string}
     * @memberof SerpClusterBestGroupsRequest
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterBestGroupsRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SerpClusterBestGroupsRequest
     */
    'min_cluster_strength'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SerpClusterBestGroupsRequest
     */
    'min_queries_count'?: number | null;
}


/**
 * 
 * @export
 * @interface SerpClusterGroupIntersectionsRequest
 */
export interface SerpClusterGroupIntersectionsRequest {
    /**
     * Customer ID of cluster
     * @type {string}
     * @memberof SerpClusterGroupIntersectionsRequest
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupIntersectionsRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupIntersectionsRequest
     */
    'group_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SerpClusterGroupIntersectionsRequest
     */
    'min_cluster_strength'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupIntersectionsRequest
     */
    'suggest_other_matching_keywords'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupIntersectionsRequest
     */
    'include_negative_keywords'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupIntersectionsRequest
     */
    'include_all_members'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SerpClusterGroupSearchRequest
 */
export interface SerpClusterGroupSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupSearchRequest
     */
    'search'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupSearchRequest
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupSearchRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupSearchRequest
     */
    'group_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupSearchRequest
     */
    'include_negative_keywords'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SerpClusterGroupSubClustersRequest
 */
export interface SerpClusterGroupSubClustersRequest {
    /**
     * Customer ID of cluster
     * @type {string}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'group_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'min_cluster_strength'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'suggest_other_matching_keywords'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'include_negative_keywords'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'include_all_members'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterGroupSubClustersRequest
     */
    'include_group_keywords'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SerpClusterKeywordIntersectionsRequest
 */
export interface SerpClusterKeywordIntersectionsRequest {
    /**
     * 
     * @type {string}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'keyword_id'?: string | null;
    /**
     * Keyword to search
     * @type {string}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'keyword': string;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'country'?: string | null;
    /**
     * 
     * @type {SerpSearchEngineType}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'search_engine'?: SerpSearchEngineType | null;
    /**
     * Customer ID of cluster
     * @type {string}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'campaign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'group_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SerpClusterKeywordIntersectionsRequest
     */
    'min_cluster_strength'?: number | null;
}


/**
 * 
 * @export
 * @interface SerpClusterKeywordResponse
 */
export interface SerpClusterKeywordResponse {
    /**
     * Unique ID
     * @type {string}
     * @memberof SerpClusterKeywordResponse
     */
    'unique_id': string;
    /**
     * Query ID
     * @type {string}
     * @memberof SerpClusterKeywordResponse
     */
    'keyword_id': string;
    /**
     * Query
     * @type {string}
     * @memberof SerpClusterKeywordResponse
     */
    'keyword': string;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterKeywordResponse
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpClusterKeywordResponse
     */
    'language'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpClusterKeywordResponse
     */
    'is_negative'?: boolean | null;
    /**
     * 
     * @type {GoogleAdsMatchType}
     * @memberof SerpClusterKeywordResponse
     */
    'match_type': GoogleAdsMatchType | null;
    /**
     * Campaign ID
     * @type {string}
     * @memberof SerpClusterKeywordResponse
     */
    'campaign_id': string;
    /**
     * Group ID
     * @type {string}
     * @memberof SerpClusterKeywordResponse
     */
    'group_id': string;
    /**
     * 
     * @type {SerpSearchEngineType}
     * @memberof SerpClusterKeywordResponse
     */
    'search_engine': SerpSearchEngineType | null;
}


/**
 * 
 * @export
 * @interface SerpGroupIntersection
 */
export interface SerpGroupIntersection {
    /**
     * 
     * @type {string}
     * @memberof SerpGroupIntersection
     */
    'workspace_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpGroupIntersection
     */
    'customer_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpGroupIntersection
     */
    'campaign_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpGroupIntersection
     */
    'group_id': string;
    /**
     * 
     * @type {string}
     * @memberof SerpGroupIntersection
     */
    'unique_group_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SerpGroupIntersection
     */
    'intersections_count': number;
}
/**
 * 
 * @export
 * @interface SerpKeyword
 */
export interface SerpKeyword {
    /**
     * 
     * @type {string}
     * @memberof SerpKeyword
     */
    'keyword_id'?: string | null;
    /**
     * Keyword to search
     * @type {string}
     * @memberof SerpKeyword
     */
    'keyword': string;
    /**
     * 
     * @type {string}
     * @memberof SerpKeyword
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpKeyword
     */
    'country'?: string | null;
    /**
     * 
     * @type {SerpSearchEngineType}
     * @memberof SerpKeyword
     */
    'search_engine'?: SerpSearchEngineType | null;
}


/**
 * 
 * @export
 * @interface SerpKeywordRelation
 */
export interface SerpKeywordRelation {
    /**
     * The keyword id
     * @type {string}
     * @memberof SerpKeywordRelation
     */
    'keyword_id_1': string;
    /**
     * The keyword
     * @type {string}
     * @memberof SerpKeywordRelation
     */
    'keyword_1': string;
    /**
     * The related keyword id
     * @type {string}
     * @memberof SerpKeywordRelation
     */
    'keyword_id_2': string;
    /**
     * The related keyword
     * @type {string}
     * @memberof SerpKeywordRelation
     */
    'keyword_2': string;
    /**
     * The count of cluster strength
     * @type {number}
     * @memberof SerpKeywordRelation
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface SerpQueryRequest
 */
export interface SerpQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof SerpQueryRequest
     */
    'post_back_url'?: string | null;
    /**
     * List of queries
     * @type {Array<SerpKeyword>}
     * @memberof SerpQueryRequest
     */
    'queries': Array<SerpKeyword>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SerpSearchEngineType = {
    G: 'G',
    D: 'D'
} as const;

export type SerpSearchEngineType = typeof SerpSearchEngineType[keyof typeof SerpSearchEngineType];


/**
 * 
 * @export
 * @interface SerpSearchRequest
 */
export interface SerpSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SerpSearchRequest
     */
    'post_back_url'?: string | null;
    /**
     * Query to search
     * @type {string}
     * @memberof SerpSearchRequest
     */
    'query': string;
    /**
     * 
     * @type {string}
     * @memberof SerpSearchRequest
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpSearchRequest
     */
    'location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpSearchRequest
     */
    'language'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SerpSearchRequest
     */
    'count_urls'?: number | null;
}
/**
 * 
 * @export
 * @interface SerpSearchRequests
 */
export interface SerpSearchRequests {
    /**
     * List of serp requests
     * @type {Array<SerpSearchRequest>}
     * @memberof SerpSearchRequests
     */
    'requests': Array<SerpSearchRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof SerpSearchRequests
     */
    'live_mode'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SerpSubclusterKeywordsResponse
 */
export interface SerpSubclusterKeywordsResponse {
    /**
     * List of keywords not assigned yet
     * @type {Array<string>}
     * @memberof SerpSubclusterKeywordsResponse
     */
    'missing_keywords': Array<string>;
    /**
     * List of keywords already assigned
     * @type {Array<string>}
     * @memberof SerpSubclusterKeywordsResponse
     */
    'keywords': Array<string>;
    /**
     * Count of keywords in subcluster
     * @type {number}
     * @memberof SerpSubclusterKeywordsResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface SerpVolumeRequest
 */
export interface SerpVolumeRequest {
    /**
     * 
     * @type {string}
     * @memberof SerpVolumeRequest
     */
    'post_back_url'?: string | null;
    /**
     * List of queries
     * @type {Array<string>}
     * @memberof SerpVolumeRequest
     */
    'keywords': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SerpVolumeRequest
     */
    'language_code'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpVolumeRequest
     */
    'location_name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SerpVolumeRequest
     */
    'include_adult_keywords'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof SerpVolumeRequest
     */
    'date_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SerpVolumeRequest
     */
    'date_to'?: string | null;
}
/**
 * 
 * @export
 * @interface ShopRedactPayload
 */
export interface ShopRedactPayload {
    /**
     * 
     * @type {number}
     * @memberof ShopRedactPayload
     */
    'shop_id': number;
    /**
     * 
     * @type {string}
     * @memberof ShopRedactPayload
     */
    'shop_domain': string;
}
/**
 * 
 * @export
 * @interface ShopifyIntegrationResponse
 */
export interface ShopifyIntegrationResponse {
    /**
     * 
     * @type {string}
     * @memberof ShopifyIntegrationResponse
     */
    'shop_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopifyIntegrationResponse
     */
    'shopify_client_id'?: string | null;
}
/**
 * 
 * @export
 * @interface ShopifySubscriptionConfirmResponse
 */
export interface ShopifySubscriptionConfirmResponse {
    /**
     * 
     * @type {string}
     * @memberof ShopifySubscriptionConfirmResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ShopifySubscriptionConfirmResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ShopifySubscriptionConfirmResponse
     */
    'subscription_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopifySubscriptionConfirmResponse
     */
    'subscription_status'?: string | null;
}
/**
 * 
 * @export
 * @interface SlackChannelResponse
 */
export interface SlackChannelResponse {
    /**
     * 
     * @type {string}
     * @memberof SlackChannelResponse
     */
    'channel_id': string;
    /**
     * 
     * @type {string}
     * @memberof SlackChannelResponse
     */
    'channel_name': string;
}
/**
 * 
 * @export
 * @interface SlackWorkspaceResponse
 */
export interface SlackWorkspaceResponse {
    /**
     * 
     * @type {string}
     * @memberof SlackWorkspaceResponse
     */
    'team_id': string;
    /**
     * 
     * @type {string}
     * @memberof SlackWorkspaceResponse
     */
    'workspace_name': string;
    /**
     * 
     * @type {string}
     * @memberof SlackWorkspaceResponse
     */
    'integration_id': string;
}
/**
 * Enum for sort direction options.
 * @export
 * @enum {string}
 */

export const SortDirection = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortDirection = typeof SortDirection[keyof typeof SortDirection];


/**
 * Model for memory source information.
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'source_id': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'source_type': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'source_url'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Source
     */
    'metadata'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SubscriptionPlan = {
    S: 'S',
    P: 'P',
    A: 'A',
    T: 'T',
    C: 'C',
    E: 'E'
} as const;

export type SubscriptionPlan = typeof SubscriptionPlan[keyof typeof SubscriptionPlan];


/**
 * 
 * @export
 * @interface SystemMessageMetadata
 */
export interface SystemMessageMetadata {
    /**
     * Message ID
     * @type {string}
     * @memberof SystemMessageMetadata
     */
    'message_id': string;
    /**
     * Message
     * @type {string}
     * @memberof SystemMessageMetadata
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface TagCreateRequest
 */
export interface TagCreateRequest {
    /**
     * Tag name
     * @type {string}
     * @memberof TagCreateRequest
     */
    'tag_name': string;
    /**
     * Tag color
     * @type {string}
     * @memberof TagCreateRequest
     */
    'tag_color': string;
}
/**
 * 
 * @export
 * @interface TagResponse
 */
export interface TagResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof TagResponse
     */
    'workspace_id': string;
    /**
     * Tag ID
     * @type {string}
     * @memberof TagResponse
     */
    'tag_id': string;
    /**
     * Tag name
     * @type {string}
     * @memberof TagResponse
     */
    'tag_name': string;
    /**
     * Tag color
     * @type {string}
     * @memberof TagResponse
     */
    'tag_color': string;
}
/**
 * 
 * @export
 * @interface TagSearchRequest
 */
export interface TagSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof TagSearchRequest
     */
    'tag_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TagSearchRequest
     */
    'tag_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TagSearchRequest
     */
    'limit'?: number | null;
}
/**
 * 
 * @export
 * @interface TagUpdateRequest
 */
export interface TagUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof TagUpdateRequest
     */
    'tag_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TagUpdateRequest
     */
    'tag_color'?: string | null;
}
/**
 * 
 * @export
 * @interface TaskResponse
 */
export interface TaskResponse {
    /**
     * Task ID
     * @type {string}
     * @memberof TaskResponse
     */
    'id': string;
    /**
     * Task status
     * @type {TaskStatus}
     * @memberof TaskResponse
     */
    'status': TaskStatus;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    'result'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    'error_message'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TaskStatus = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Retry: 'RETRY',
    Revoked: 'REVOKED',
    Received: 'RECEIVED',
    Started: 'STARTED',
    Ignored: 'IGNORED',
    Rejected: 'REJECTED'
} as const;

export type TaskStatus = typeof TaskStatus[keyof typeof TaskStatus];


/**
 * 
 * @export
 * @interface ToolCallFeedbackResponse
 */
export interface ToolCallFeedbackResponse {
    /**
     * Date in YYYY-MM-DD format
     * @type {string}
     * @memberof ToolCallFeedbackResponse
     */
    'date': string;
    /**
     * Tool call count
     * @type {number}
     * @memberof ToolCallFeedbackResponse
     */
    'tool_calling_count'?: number;
    /**
     * 
     * @type {Array<ToolFeedback>}
     * @memberof ToolCallFeedbackResponse
     */
    'tools'?: Array<ToolFeedback> | null;
}
/**
 * 
 * @export
 * @interface ToolFeedback
 */
export interface ToolFeedback {
    /**
     * Tool name
     * @type {string}
     * @memberof ToolFeedback
     */
    'tool_name': string;
    /**
     * Tool call count
     * @type {number}
     * @memberof ToolFeedback
     */
    'tool_call_count': number;
}
/**
 * 
 * @export
 * @interface TotalFeedback
 */
export interface TotalFeedback {
    /**
     * Total count of positive feedback
     * @type {number}
     * @memberof TotalFeedback
     */
    'positive'?: number;
    /**
     * Total count of negative feedback
     * @type {number}
     * @memberof TotalFeedback
     */
    'negative'?: number;
    /**
     * Total count of unique sessions (visitor count)
     * @type {number}
     * @memberof TotalFeedback
     */
    'session_count'?: number;
    /**
     * Average human messages per session
     * @type {number}
     * @memberof TotalFeedback
     */
    'human_message_count'?: number;
    /**
     * Average tool calls per session
     * @type {number}
     * @memberof TotalFeedback
     */
    'tool_calling_count'?: number;
}
/**
 * Enum for tracking click ID names
 * @export
 * @enum {string}
 */

export const TrackingClickIdNames = {
    Gclid: 'gclid',
    Gbraid: 'gbraid',
    Wbraid: 'wbraid',
    Dclid: 'dclid',
    Fbclid: 'fbclid',
    Msclkid: 'msclkid',
    Other: 'other'
} as const;

export type TrackingClickIdNames = typeof TrackingClickIdNames[keyof typeof TrackingClickIdNames];


/**
 * 
 * @export
 * @interface TrackingEventCreateRequest
 */
export interface TrackingEventCreateRequest {
    /**
     * The name of the event
     * @type {string}
     * @memberof TrackingEventCreateRequest
     */
    'event_name': string;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequest
     */
    'unique_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingEventCreateRequest
     */
    'event_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequest
     */
    'currency'?: string | null;
    /**
     * 
     * @type {Array<TrackingEventData>}
     * @memberof TrackingEventCreateRequest
     */
    'event_data'?: Array<TrackingEventData> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingEventCreateRequest
     */
    'link_ids'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequest
     */
    'valid_until'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequest
     */
    'conversion_action_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingEventCreateRequest
     */
    'include_in_conversions_metric'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequest
     */
    'url'?: string | null;
}
/**
 * 
 * @export
 * @interface TrackingEventCreateRequests
 */
export interface TrackingEventCreateRequests {
    /**
     * The list of events to be created
     * @type {Array<TrackingEventCreateRequest>}
     * @memberof TrackingEventCreateRequests
     */
    'events': Array<TrackingEventCreateRequest>;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequests
     */
    'unique_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequests
     */
    'fp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequests
     */
    'session_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingEventCreateRequests
     */
    'with_address'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventCreateRequests
     */
    'ga'?: string | null;
}
/**
 * Value object for tracking event data
 * @export
 * @interface TrackingEventData
 */
export interface TrackingEventData {
    /**
     * 
     * @type {string}
     * @memberof TrackingEventData
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventData
     */
    'value_text'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingEventData
     */
    'value_number'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingEventData
     */
    'value_boolean'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventData
     */
    'value_datetime'?: string | null;
}
/**
 * 
 * @export
 * @interface TrackingEventResponse
 */
export interface TrackingEventResponse {
    /**
     * 
     * @type {string}
     * @memberof TrackingEventResponse
     */
    'event_id': string;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventResponse
     */
    'unique_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventResponse
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventResponse
     */
    'event_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingEventResponse
     */
    'event_value'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventResponse
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventResponse
     */
    'valid_until'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingEventResponse
     */
    'include_in_conversions_metric'?: boolean | null;
    /**
     * 
     * @type {Array<TrackingEventData>}
     * @memberof TrackingEventResponse
     */
    'event_data'?: Array<TrackingEventData> | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof TrackingEventResponse
     */
    'link_ids'?: Array<any> | null;
}
/**
 * 
 * @export
 * @interface TrackingEventSearchRequest
 */
export interface TrackingEventSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingEventSearchRequest
     */
    'event_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventSearchRequest
     */
    'from_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingEventSearchRequest
     */
    'to_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingEventSearchRequest
     */
    'include_expired'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingEventSearchRequest
     */
    'page'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingEventSearchRequest
     */
    'page_size'?: number | null;
}
/**
 * 
 * @export
 * @interface TrackingEventsResponse
 */
export interface TrackingEventsResponse {
    /**
     * 
     * @type {Array<TrackingEventResponse>}
     * @memberof TrackingEventsResponse
     */
    'events': Array<TrackingEventResponse>;
}
/**
 * 
 * @export
 * @interface TrackingLinkCreateRequest
 */
export interface TrackingLinkCreateRequest {
    /**
     * The source link ID
     * @type {string}
     * @memberof TrackingLinkCreateRequest
     */
    'src_link_id': string;
    /**
     * The destination link ID
     * @type {string}
     * @memberof TrackingLinkCreateRequest
     */
    'dst_link_id': string;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkCreateRequest
     */
    'valid_until'?: string | null;
}
/**
 * 
 * @export
 * @interface TrackingLinkResponse
 */
export interface TrackingLinkResponse {
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkResponse
     */
    'src_link_id': string;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkResponse
     */
    'dst_link_id': string;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkResponse
     */
    'valid_until'?: string | null;
}
/**
 * 
 * @export
 * @interface TrackingLinkSearchRequest
 */
export interface TrackingLinkSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkSearchRequest
     */
    'src_link_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkSearchRequest
     */
    'dst_link_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkSearchRequest
     */
    'from_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinkSearchRequest
     */
    'to_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingLinkSearchRequest
     */
    'include_expired'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingLinkSearchRequest
     */
    'page'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingLinkSearchRequest
     */
    'page_size'?: number | null;
}
/**
 * 
 * @export
 * @interface TrackingLinksCreateRequest
 */
export interface TrackingLinksCreateRequest {
    /**
     * The list of links to be created
     * @type {Array<TrackingLinkCreateRequest>}
     * @memberof TrackingLinksCreateRequest
     */
    'links': Array<TrackingLinkCreateRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingLinksCreateRequest
     */
    'with_address'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinksCreateRequest
     */
    'unique_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinksCreateRequest
     */
    'fp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinksCreateRequest
     */
    'session_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingLinksCreateRequest
     */
    'ga'?: string | null;
}
/**
 * 
 * @export
 * @interface TrackingLinksResponse
 */
export interface TrackingLinksResponse {
    /**
     * 
     * @type {Array<TrackingLinkResponse>}
     * @memberof TrackingLinksResponse
     */
    'links': Array<TrackingLinkResponse>;
}
/**
 * 
 * @export
 * @interface TrackingSourceCreateRequest
 */
export interface TrackingSourceCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'click_id'?: string | null;
    /**
     * 
     * @type {TrackingClickIdNames}
     * @memberof TrackingSourceCreateRequest
     */
    'click_id_name'?: TrackingClickIdNames | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'utm_source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'utm_medium'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'utm_campaign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'utm_term'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'utm_content'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'utm_channel'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'ga'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'url'?: string | null;
    /**
     * The links of the traffic source
     * @type {Array<string>}
     * @memberof TrackingSourceCreateRequest
     */
    'links'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof TrackingSourceCreateRequest
     */
    'valid_days'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingSourceCreateRequest
     */
    'with_address'?: boolean | null;
    /**
     * 
     * @type {Array<TrackingEventData>}
     * @memberof TrackingSourceCreateRequest
     */
    'event_data'?: Array<TrackingEventData> | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'unique_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'fp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceCreateRequest
     */
    'session_id'?: string | null;
}


/**
 * 
 * @export
 * @interface TrackingSourceResponse
 */
export interface TrackingSourceResponse {
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'link_id'?: string | null;
    /**
     * 
     * @type {TrackingSourceTypes}
     * @memberof TrackingSourceResponse
     */
    'source_type': TrackingSourceTypes;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'click_id'?: string | null;
    /**
     * 
     * @type {TrackingClickIdNames}
     * @memberof TrackingSourceResponse
     */
    'click_id_name'?: TrackingClickIdNames | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'utm_source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'utm_medium'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'utm_campaign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'utm_term'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'utm_content'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'utm_channel'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'ga'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceResponse
     */
    'valid_until'?: string | null;
    /**
     * 
     * @type {Array<TrackingEventData>}
     * @memberof TrackingSourceResponse
     */
    'event_data'?: Array<TrackingEventData> | null;
}


/**
 * 
 * @export
 * @interface TrackingSourceSearchRequest
 */
export interface TrackingSourceSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'customer_id'?: string | null;
    /**
     * 
     * @type {TrackingSourceTypes}
     * @memberof TrackingSourceSearchRequest
     */
    'source_type'?: TrackingSourceTypes | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'click_id'?: string | null;
    /**
     * 
     * @type {TrackingClickIdNames}
     * @memberof TrackingSourceSearchRequest
     */
    'click_id_name'?: TrackingClickIdNames | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'utm_source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'utm_medium'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'utm_campaign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'utm_channel'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'from_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackingSourceSearchRequest
     */
    'to_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackingSourceSearchRequest
     */
    'include_expired'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingSourceSearchRequest
     */
    'page'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TrackingSourceSearchRequest
     */
    'page_size'?: number | null;
}


/**
 * Enum for tracking source types
 * @export
 * @enum {string}
 */

export const TrackingSourceTypes = {
    Ga: 'ga',
    Fb: 'fb',
    Li: 'li',
    Tw: 'tw',
    Ms: 'ms',
    Ot: 'ot'
} as const;

export type TrackingSourceTypes = typeof TrackingSourceTypes[keyof typeof TrackingSourceTypes];


/**
 * 
 * @export
 * @interface TrackingSourcesResponse
 */
export interface TrackingSourcesResponse {
    /**
     * 
     * @type {Array<TrackingSourceResponse>}
     * @memberof TrackingSourcesResponse
     */
    'sources': Array<TrackingSourceResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionType = {
    G: 'G',
    K: 'K',
    V: 'V',
    S: 'S',
    T: 'T',
    D: 'D',
    M: 'M',
    F: 'F',
    I: 'I',
    C: 'C',
    A: 'A',
    Y: 'Y',
    E: 'E',
    X: 'X',
    P: 'P',
    W: 'W',
    O: 'O',
    N: 'N',
    FtI: 'FT_I',
    Ddg: 'DDG',
    Cgd: 'CGD',
    Cgs: 'CGS',
    Rgs: 'RGS',
    Ugs: 'UGS',
    Igi: 'IGI',
    Tr: 'TR',
    FatGc: 'FAT_GC',
    CeGc: 'CE_GC',
    UeGc: 'UE_GC',
    VeGc: 'VE_GC',
    Cwp: 'CWP',
    DeGc: 'DE_GC',
    AcHs: 'AC_HS',
    LahaHs: 'LAHA_HS',
    LtHs: 'LT_HS',
    GcHs: 'GC_HS',
    UcHs: 'UC_HS',
    ScHs: 'SC_HS',
    EtaHs: 'ETA_HS',
    CnmHs: 'CNM_HS',
    Cne: 'CNE',
    Se: 'SE',
    Ge: 'GE',
    Ale: 'ALE',
    Rle: 'RLE',
    Cps: 'CPS',
    CsGs: 'CS_GS',
    IgApi: 'IG_API',
    Fa: 'FA',
    Hc: 'HC',
    Coe: 'COE',
    Mcp: 'MCP',
    SO: 'S_O',
    SP: 'S_P',
    YF: 'Y_F',
    XS: 'X_S',
    VT: 'V_T',
    SSm: 'S_SM',
    FVt: 'F_VT',
    RFt: 'R_FT',
    NEt: 'N_ET',
    LTm: 'L_TM',
    JSt: 'J_ST',
    DRt: 'D_RT',
    CdtT: 'CDT_T',
    CsvSt: 'CSV_ST',
    ClT: 'CL_T',
    ApiT: 'API_T',
    SequentialAgent: 'SEQUENTIAL_AGENT',
    SelfManagedAgent: 'SELF_MANAGED_AGENT',
    ToolArxiv: 'TOOL_ARXIV',
    ToolReddit: 'TOOL_REDDIT',
    ToolWikipedia: 'TOOL_WIKIPEDIA',
    ToolDallE: 'TOOL_DALL_E',
    ToolYoutubeSearch: 'TOOL_YOUTUBE_SEARCH',
    ToolIftttWebhook: 'TOOL_IFTTT_WEBHOOK',
    ToolPubmed: 'TOOL_PUBMED',
    ToolStackExchange: 'TOOL_STACK_EXCHANGE',
    MT: 'M_T'
} as const;

export type TransactionType = typeof TransactionType[keyof typeof TransactionType];


/**
 * 
 * @export
 * @interface TranscriptTaskRequest
 */
export interface TranscriptTaskRequest {
    /**
     * The task ID to get the transcript from
     * @type {string}
     * @memberof TranscriptTaskRequest
     */
    'task_id': string;
}
/**
 * 
 * @export
 * @interface TriggerResponse
 */
export interface TriggerResponse {
    /**
     * Trigger types
     * @type {{ [key: string]: string; }}
     * @memberof TriggerResponse
     */
    'triggers': { [key: string]: string; };
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TriggerType = {
    OnChatOpen: 'on_chat_open',
    CustomTrigger: 'custom_trigger',
    ChatInput: 'chat_input',
    SlackMessageReceived: 'slack_message_received',
    SlackShortcuts: 'slack_shortcuts',
    OnHubspotMessage: 'on_hubspot_message',
    OnGmailMessage: 'on_gmail_message',
    OnEmailMessage: 'on_email_message',
    OnOutlookMessage: 'on_outlook_message',
    OnCalendarEventCreated: 'on_calendar_event_created'
} as const;

export type TriggerType = typeof TriggerType[keyof typeof TriggerType];


/**
 * Request schema for updating user settings.
 * @export
 * @interface UpdateUserSettingsRequest
 */
export interface UpdateUserSettingsRequest {
    /**
     * User settings to update
     * @type {{ [key: string]: any; }}
     * @memberof UpdateUserSettingsRequest
     */
    'settings': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UrlScreenshotResponse
 */
export interface UrlScreenshotResponse {
    /**
     * 
     * @type {string}
     * @memberof UrlScreenshotResponse
     */
    'original_image': string;
    /**
     * 
     * @type {string}
     * @memberof UrlScreenshotResponse
     */
    'thumbnail_image': string;
    /**
     * 
     * @type {string}
     * @memberof UrlScreenshotResponse
     */
    'original_image_full_page': string;
    /**
     * 
     * @type {string}
     * @memberof UrlScreenshotResponse
     */
    'thumbnail_image_full_page': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UserDocumentStatus = {
    E: 'E',
    D: 'D'
} as const;

export type UserDocumentStatus = typeof UserDocumentStatus[keyof typeof UserDocumentStatus];


/**
 * 
 * @export
 * @interface UserPlanResponse
 */
export interface UserPlanResponse {
    /**
     * 
     * @type {number}
     * @memberof UserPlanResponse
     */
    'price_amount': number;
    /**
     * 
     * @type {string}
     * @memberof UserPlanResponse
     */
    'price_currency': string;
    /**
     * 
     * @type {number}
     * @memberof UserPlanResponse
     */
    'monthly_topup_credits': number;
    /**
     * 
     * @type {string}
     * @memberof UserPlanResponse
     */
    'current_period_end': string | null;
    /**
     * 
     * @type {{ [key: string]: SubscriptionPlan; }}
     * @memberof UserPlanResponse
     */
    'subscription_plans': { [key: string]: SubscriptionPlan; };
    /**
     * 
     * @type {boolean}
     * @memberof UserPlanResponse
     */
    'can_remove_branding': boolean;
    /**
     * 
     * @type {number}
     * @memberof UserPlanResponse
     */
    'extra_workspaces_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UserPlanResponse
     */
    'extra_credits_count'?: number | null;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * User ID
     * @type {string}
     * @memberof UserResponse
     */
    'user_id': string;
    /**
     * Email of the user
     * @type {string}
     * @memberof UserResponse
     */
    'email': string;
    /**
     * Name of the user
     * @type {string}
     * @memberof UserResponse
     */
    'username': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponse
     */
    'is_active'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'avatar_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'api_key_workspace_id'?: string | null;
    /**
     * 
     * @type {{ [key: string]: SubscriptionPlan; }}
     * @memberof UserResponse
     */
    'product_plans'?: { [key: string]: SubscriptionPlan; } | null;
    /**
     * 
     * @type {BillingProvider}
     * @memberof UserResponse
     */
    'billing_provider'?: BillingProvider | null;
}


/**
 * Response schema for user settings.
 * @export
 * @interface UserSettingsResponse
 */
export interface UserSettingsResponse {
    /**
     * User settings with defaults applied
     * @type {{ [key: string]: any; }}
     * @memberof UserSettingsResponse
     */
    'settings': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}
/**
 * 
 * @export
 * @interface VectorDocumentResponse
 */
export interface VectorDocumentResponse {
    /**
     * Document ID
     * @type {string}
     * @memberof VectorDocumentResponse
     */
    'document_id': string;
    /**
     * Workspace ID
     * @type {string}
     * @memberof VectorDocumentResponse
     */
    'workspace_id': string;
    /**
     * Document type
     * @type {VectorDocumentType}
     * @memberof VectorDocumentResponse
     */
    'document_type': VectorDocumentType;
    /**
     * Point ID
     * @type {string}
     * @memberof VectorDocumentResponse
     */
    'point_id': string;
    /**
     * Pointer position
     * @type {number}
     * @memberof VectorDocumentResponse
     */
    'pointer_position': number;
    /**
     * Pointer type
     * @type {PointerType}
     * @memberof VectorDocumentResponse
     */
    'pointer_type': PointerType;
    /**
     * 
     * @type {string}
     * @memberof VectorDocumentResponse
     */
    'schema_type'?: string | null;
    /**
     * Knowledge key - schedule id or category id
     * @type {string}
     * @memberof VectorDocumentResponse
     */
    'kb_key': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof VectorDocumentResponse
     */
    'vector': Array<number> | null;
    /**
     * Vector ID
     * @type {number}
     * @memberof VectorDocumentResponse
     */
    'vector_id': number;
    /**
     * 
     * @type {Data}
     * @memberof VectorDocumentResponse
     */
    'data'?: Data | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const VectorDocumentType = {
    U: 'U',
    P: 'P',
    Q: 'Q'
} as const;

export type VectorDocumentType = typeof VectorDocumentType[keyof typeof VectorDocumentType];


/**
 * 
 * @export
 * @interface VectorDocumentsTaskResponse
 */
export interface VectorDocumentsTaskResponse {
    /**
     * Task ID
     * @type {string}
     * @memberof VectorDocumentsTaskResponse
     */
    'id': string;
    /**
     * Task status
     * @type {TaskStatus}
     * @memberof VectorDocumentsTaskResponse
     */
    'status': TaskStatus;
    /**
     * 
     * @type {Array<VectorDocumentResponse>}
     * @memberof VectorDocumentsTaskResponse
     */
    'result'?: Array<VectorDocumentResponse> | null;
    /**
     * 
     * @type {string}
     * @memberof VectorDocumentsTaskResponse
     */
    'error_message'?: string | null;
}


/**
 * 
 * @export
 * @interface WordPressCategoryResponse
 */
export interface WordPressCategoryResponse {
    /**
     * 
     * @type {number}
     * @memberof WordPressCategoryResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof WordPressCategoryResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WordPressCategoryResponse
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof WordPressCategoryResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof WordPressCategoryResponse
     */
    'link': string;
    /**
     * 
     * @type {number}
     * @memberof WordPressCategoryResponse
     */
    'parent': number;
    /**
     * 
     * @type {number}
     * @memberof WordPressCategoryResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface WordPressSiteResponse
 */
export interface WordPressSiteResponse {
    /**
     * Integration ID
     * @type {string}
     * @memberof WordPressSiteResponse
     */
    'integration_id': string;
    /**
     * Site URL
     * @type {string}
     * @memberof WordPressSiteResponse
     */
    'site_url': string;
    /**
     * 
     * @type {string}
     * @memberof WordPressSiteResponse
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof WordPressSiteResponse
     */
    'home': string | null;
}
/**
 * 
 * @export
 * @interface WordPressTagsResponse
 */
export interface WordPressTagsResponse {
    /**
     * 
     * @type {number}
     * @memberof WordPressTagsResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof WordPressTagsResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WordPressTagsResponse
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof WordPressTagsResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof WordPressTagsResponse
     */
    'link': string;
    /**
     * 
     * @type {number}
     * @memberof WordPressTagsResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface WorkspaceCreateRequest
 */
export interface WorkspaceCreateRequest {
    /**
     * Name of the workspace
     * @type {string}
     * @memberof WorkspaceCreateRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface WorkspaceResponse
 */
export interface WorkspaceResponse {
    /**
     * Workspace ID
     * @type {string}
     * @memberof WorkspaceResponse
     */
    'workspace_id': string;
    /**
     * Name of the workspace
     * @type {string}
     * @memberof WorkspaceResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface WorkspaceRole
 */
export interface WorkspaceRole {
    /**
     * Workspace ID
     * @type {string}
     * @memberof WorkspaceRole
     */
    'workspace_id': string;
    /**
     * Workspace Name
     * @type {string}
     * @memberof WorkspaceRole
     */
    'workspace_name': string;
    /**
     * Name of the owner of the workspace
     * @type {string}
     * @memberof WorkspaceRole
     */
    'owner_name': string;
    /**
     * Email of the owner of the workspace
     * @type {string}
     * @memberof WorkspaceRole
     */
    'owner_email': string;
    /**
     * Role of the user in the workspace (A - Admin, E - Editor, M - Member, G - Guest)
     * @type {string}
     * @memberof WorkspaceRole
     */
    'role': string;
}
/**
 * Request DTO for creating workspace SSO settings.
 * @export
 * @interface WorkspaceSSOCreateRequest
 */
export interface WorkspaceSSOCreateRequest {
    /**
     * SSO provider (e.g., \'microsoft\')
     * @type {string}
     * @memberof WorkspaceSSOCreateRequest
     */
    'provider': string;
    /**
     * Whether SSO is enabled
     * @type {boolean}
     * @memberof WorkspaceSSOCreateRequest
     */
    'enabled'?: boolean;
    /**
     * Identity Provider SSO URL
     * @type {string}
     * @memberof WorkspaceSSOCreateRequest
     */
    'idp_sso_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceSSOCreateRequest
     */
    'jit_provisioning_enabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOCreateRequest
     */
    'email_attribute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOCreateRequest
     */
    'name_id_format'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOCreateRequest
     */
    'first_name_attribute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOCreateRequest
     */
    'last_name_attribute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOCreateRequest
     */
    'role_attribute'?: string | null;
    /**
     * 
     * @type {SamlLoginMethod}
     * @memberof WorkspaceSSOCreateRequest
     */
    'login_method'?: SamlLoginMethod | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOCreateRequest
     */
    'idp_metadata_xml'?: string | null;
}


/**
 * Request model for creating a new domain verification record.
 * @export
 * @interface WorkspaceSSODomainVerificationCreateRequest
 */
export interface WorkspaceSSODomainVerificationCreateRequest {
    /**
     * Domain name to verify (e.g., example.com)
     * @type {string}
     * @memberof WorkspaceSSODomainVerificationCreateRequest
     */
    'domain': string;
}
/**
 * Response model for domain verification records.
 * @export
 * @interface WorkspaceSSODomainVerificationResponse
 */
export interface WorkspaceSSODomainVerificationResponse {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSODomainVerificationResponse
     */
    'workspace_id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSODomainVerificationResponse
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSODomainVerificationResponse
     */
    'nonce': string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceSSODomainVerificationResponse
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSODomainVerificationResponse
     */
    'verification_hash': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSODomainVerificationResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSODomainVerificationResponse
     */
    'last_verified_at'?: string | null;
}
/**
 * Response DTO for list of workspace SSO settings.
 * @export
 * @interface WorkspaceSSOListResponse
 */
export interface WorkspaceSSOListResponse {
    /**
     * 
     * @type {Array<WorkspaceSSOResponse>}
     * @memberof WorkspaceSSOListResponse
     */
    'items': Array<WorkspaceSSOResponse>;
}
/**
 * Response DTO for workspace SSO settings.
 * @export
 * @interface WorkspaceSSOResponse
 */
export interface WorkspaceSSOResponse {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'workspace_id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'domain': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceSSOResponse
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'idp_sso_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'idp_metadata_xml'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'idp_entity_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'idp_x509_cert'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'login_method'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceSSOResponse
     */
    'jit_provisioning_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'email_attribute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'name_id_format'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'assertion_consumer_service_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'first_name_attribute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'last_name_attribute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOResponse
     */
    'role_attribute'?: string | null;
}
/**
 * Request DTO for updating workspace SSO settings.
 * @export
 * @interface WorkspaceSSOUpdateRequest
 */
export interface WorkspaceSSOUpdateRequest {
    /**
     * Whether SSO is enabled
     * @type {boolean}
     * @memberof WorkspaceSSOUpdateRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOUpdateRequest
     */
    'idp_sso_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOUpdateRequest
     */
    'idp_entity_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOUpdateRequest
     */
    'idp_x509_cert'?: string | null;
    /**
     * Enable Just-In-Time user provisioning
     * @type {boolean}
     * @memberof WorkspaceSSOUpdateRequest
     */
    'jit_provisioning_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOUpdateRequest
     */
    'email_attribute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOUpdateRequest
     */
    'name_id_format'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOUpdateRequest
     */
    'first_name_attribute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOUpdateRequest
     */
    'last_name_attribute'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOUpdateRequest
     */
    'role_attribute'?: string | null;
    /**
     * 
     * @type {SamlLoginMethod}
     * @memberof WorkspaceSSOUpdateRequest
     */
    'login_method'?: SamlLoginMethod | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSSOUpdateRequest
     */
    'idp_metadata_xml'?: string | null;
}


/**
 * 
 * @export
 * @interface WorkspaceSearchRequest
 */
export interface WorkspaceSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSearchRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSearchRequest
     */
    'workspace_id'?: string | null;
}
/**
 * 
 * @export
 * @interface WorkspaceUpdateRequest
 */
export interface WorkspaceUpdateRequest {
    /**
     * Name of the workspace
     * @type {string}
     * @memberof WorkspaceUpdateRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface WorkspaceUserCreateRequest
 */
export interface WorkspaceUserCreateRequest {
    /**
     * Email of the user to add to the workspace
     * @type {string}
     * @memberof WorkspaceUserCreateRequest
     */
    'email': string;
    /**
     * Role of the user in the workspace
     * @type {Role}
     * @memberof WorkspaceUserCreateRequest
     */
    'role': Role;
}


/**
 * 
 * @export
 * @interface WorkspaceUserResponse
 */
export interface WorkspaceUserResponse {
    /**
     * User ID
     * @type {string}
     * @memberof WorkspaceUserResponse
     */
    'user_id': string;
    /**
     * Email of the user
     * @type {string}
     * @memberof WorkspaceUserResponse
     */
    'email': string;
    /**
     * Name of the user
     * @type {string}
     * @memberof WorkspaceUserResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceUserResponse
     */
    'avatar_url'?: string | null;
    /**
     * Role of the user (A - Admin, E - Editor, M - member, G - Guest)
     * @type {Role}
     * @memberof WorkspaceUserResponse
     */
    'role': Role;
}


/**
 * 
 * @export
 * @interface WorkspaceUserUpdateRequest
 */
export interface WorkspaceUserUpdateRequest {
    /**
     * Role of the user in the workspace
     * @type {Role}
     * @memberof WorkspaceUserUpdateRequest
     */
    'role'?: Role;
}


/**
 * 
 * @export
 * @interface WorkspaceUsersSearchRequest
 */
export interface WorkspaceUsersSearchRequest {
    /**
     * 
     * @type {Role}
     * @memberof WorkspaceUsersSearchRequest
     */
    'role'?: Role | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceUsersSearchRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceUsersSearchRequest
     */
    'email'?: string | null;
}


/**
 * 
 * @export
 * @interface YoutubeContent
 */
export interface YoutubeContent {
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'img_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof YoutubeContent
     */
    'status_code'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof YoutubeContent
     */
    'created_at'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof YoutubeContent
     */
    'published_at'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'doc_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'lang'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'content_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'encoding'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'apparent_encoding'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'content'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof YoutubeContent
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof YoutubeContent
     */
    'alt_content'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'content_hash'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'author'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'channel_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'channel_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeContent
     */
    'channel_title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof YoutubeContent
     */
    'duration'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof YoutubeContent
     */
    'keywords'?: Array<string> | null;
    /**
     * 
     * @type {DocumentType}
     * @memberof YoutubeContent
     */
    'doc_type'?: DocumentType | null;
    /**
     * 
     * @type {number}
     * @memberof YoutubeContent
     */
    'credits'?: number | null;
}


/**
 * 
 * @export
 * @interface YoutubeTranscriptRequest
 */
export interface YoutubeTranscriptRequest {
    /**
     * 
     * @type {string}
     * @memberof YoutubeTranscriptRequest
     */
    'post_back_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeTranscriptRequest
     */
    'video_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeTranscriptRequest
     */
    'video_url'?: string | null;
}
/**
 * 
 * @export
 * @interface YoutubeTranscriptResponse
 */
export interface YoutubeTranscriptResponse {
    /**
     * Task ID
     * @type {string}
     * @memberof YoutubeTranscriptResponse
     */
    'id': string;
    /**
     * Task status
     * @type {TaskStatus}
     * @memberof YoutubeTranscriptResponse
     */
    'status': TaskStatus;
    /**
     * 
     * @type {YoutubeContent}
     * @memberof YoutubeTranscriptResponse
     */
    'result'?: YoutubeContent | null;
    /**
     * 
     * @type {string}
     * @memberof YoutubeTranscriptResponse
     */
    'error_message'?: string | null;
}



/**
 * ApiKeysApi - axios parameter creator
 * @export
 */
export const ApiKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {string} workspaceId 
         * @param {ApiKeyCreateRequest} apiKeyCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey: async (workspaceId: string, apiKeyCreateRequest: ApiKeyCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createApiKey', 'workspaceId', workspaceId)
            // verify required parameter 'apiKeyCreateRequest' is not null or undefined
            assertParamExists('createApiKey', 'apiKeyCreateRequest', apiKeyCreateRequest)
            const localVarPath = `/v2/api_keys/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} apiKeyId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey: async (apiKeyId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyId' is not null or undefined
            assertParamExists('deleteApiKey', 'apiKeyId', apiKeyId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteApiKey', 'workspaceId', workspaceId)
            const localVarPath = `/v2/api_keys/{api_key_id}`
                .replace(`{${"api_key_id"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Api Key
         * @param {string} workspaceId 
         * @param {ApiKeySearchRequest} apiKeySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchApiKey: async (workspaceId: string, apiKeySearchRequest: ApiKeySearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchApiKey', 'workspaceId', workspaceId)
            // verify required parameter 'apiKeySearchRequest' is not null or undefined
            assertParamExists('searchApiKey', 'apiKeySearchRequest', apiKeySearchRequest)
            const localVarPath = `/v2/api_keys/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeySearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Api Key
         * @param {string} apiKeyId 
         * @param {string} workspaceId 
         * @param {ApiKeyUpdateRequest} apiKeyUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey: async (apiKeyId: string, workspaceId: string, apiKeyUpdateRequest: ApiKeyUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyId' is not null or undefined
            assertParamExists('updateApiKey', 'apiKeyId', apiKeyId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateApiKey', 'workspaceId', workspaceId)
            // verify required parameter 'apiKeyUpdateRequest' is not null or undefined
            assertParamExists('updateApiKey', 'apiKeyUpdateRequest', apiKeyUpdateRequest)
            const localVarPath = `/v2/api_keys/{api_key_id}`
                .replace(`{${"api_key_id"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeysApi - functional programming interface
 * @export
 */
export const ApiKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {string} workspaceId 
         * @param {ApiKeyCreateRequest} apiKeyCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKey(workspaceId: string, apiKeyCreateRequest: ApiKeyCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(workspaceId, apiKeyCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.createApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {string} apiKeyId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKey(apiKeyId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey(apiKeyId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.deleteApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Api Key
         * @param {string} workspaceId 
         * @param {ApiKeySearchRequest} apiKeySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchApiKey(workspaceId: string, apiKeySearchRequest: ApiKeySearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchApiKey(workspaceId, apiKeySearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.searchApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Api Key
         * @param {string} apiKeyId 
         * @param {string} workspaceId 
         * @param {ApiKeyUpdateRequest} apiKeyUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApiKey(apiKeyId: string, workspaceId: string, apiKeyUpdateRequest: ApiKeyUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApiKey(apiKeyId, workspaceId, apiKeyUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.updateApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiKeysApi - factory interface
 * @export
 */
export const ApiKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiKeysApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Api Key
         * @param {ApiKeysApiCreateApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(requestParameters: ApiKeysApiCreateApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyResponse> {
            return localVarFp.createApiKey(requestParameters.workspaceId, requestParameters.apiKeyCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Api Key
         * @param {ApiKeysApiDeleteApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(requestParameters: ApiKeysApiDeleteApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteApiKey(requestParameters.apiKeyId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Api Key
         * @param {ApiKeysApiSearchApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchApiKey(requestParameters: ApiKeysApiSearchApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiKeyResponse>> {
            return localVarFp.searchApiKey(requestParameters.workspaceId, requestParameters.apiKeySearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Api Key
         * @param {ApiKeysApiUpdateApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey(requestParameters: ApiKeysApiUpdateApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyResponse> {
            return localVarFp.updateApiKey(requestParameters.apiKeyId, requestParameters.workspaceId, requestParameters.apiKeyUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeysApi - interface
 * @export
 * @interface ApiKeysApi
 */
export interface ApiKeysApiInterface {
    /**
     * 
     * @summary Create Api Key
     * @param {ApiKeysApiCreateApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApiInterface
     */
    createApiKey(requestParameters: ApiKeysApiCreateApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyResponse>;

    /**
     * 
     * @summary Delete Api Key
     * @param {ApiKeysApiDeleteApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApiInterface
     */
    deleteApiKey(requestParameters: ApiKeysApiDeleteApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Search Api Key
     * @param {ApiKeysApiSearchApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApiInterface
     */
    searchApiKey(requestParameters: ApiKeysApiSearchApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiKeyResponse>>;

    /**
     * 
     * @summary Update Api Key
     * @param {ApiKeysApiUpdateApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApiInterface
     */
    updateApiKey(requestParameters: ApiKeysApiUpdateApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyResponse>;

}

/**
 * Request parameters for createApiKey operation in ApiKeysApi.
 * @export
 * @interface ApiKeysApiCreateApiKeyRequest
 */
export interface ApiKeysApiCreateApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeysApiCreateApiKey
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ApiKeyCreateRequest}
     * @memberof ApiKeysApiCreateApiKey
     */
    readonly apiKeyCreateRequest: ApiKeyCreateRequest
}

/**
 * Request parameters for deleteApiKey operation in ApiKeysApi.
 * @export
 * @interface ApiKeysApiDeleteApiKeyRequest
 */
export interface ApiKeysApiDeleteApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeysApiDeleteApiKey
     */
    readonly apiKeyId: string

    /**
     * 
     * @type {string}
     * @memberof ApiKeysApiDeleteApiKey
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchApiKey operation in ApiKeysApi.
 * @export
 * @interface ApiKeysApiSearchApiKeyRequest
 */
export interface ApiKeysApiSearchApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeysApiSearchApiKey
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ApiKeySearchRequest}
     * @memberof ApiKeysApiSearchApiKey
     */
    readonly apiKeySearchRequest: ApiKeySearchRequest
}

/**
 * Request parameters for updateApiKey operation in ApiKeysApi.
 * @export
 * @interface ApiKeysApiUpdateApiKeyRequest
 */
export interface ApiKeysApiUpdateApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeysApiUpdateApiKey
     */
    readonly apiKeyId: string

    /**
     * 
     * @type {string}
     * @memberof ApiKeysApiUpdateApiKey
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ApiKeyUpdateRequest}
     * @memberof ApiKeysApiUpdateApiKey
     */
    readonly apiKeyUpdateRequest: ApiKeyUpdateRequest
}

/**
 * ApiKeysApi - object-oriented interface
 * @export
 * @class ApiKeysApi
 * @extends {BaseAPI}
 */
export class ApiKeysApi extends BaseAPI implements ApiKeysApiInterface {
    /**
     * 
     * @summary Create Api Key
     * @param {ApiKeysApiCreateApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public createApiKey(requestParameters: ApiKeysApiCreateApiKeyRequest, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).createApiKey(requestParameters.workspaceId, requestParameters.apiKeyCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Api Key
     * @param {ApiKeysApiDeleteApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public deleteApiKey(requestParameters: ApiKeysApiDeleteApiKeyRequest, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).deleteApiKey(requestParameters.apiKeyId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Api Key
     * @param {ApiKeysApiSearchApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public searchApiKey(requestParameters: ApiKeysApiSearchApiKeyRequest, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).searchApiKey(requestParameters.workspaceId, requestParameters.apiKeySearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Api Key
     * @param {ApiKeysApiUpdateApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public updateApiKey(requestParameters: ApiKeysApiUpdateApiKeyRequest, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).updateApiKey(requestParameters.apiKeyId, requestParameters.workspaceId, requestParameters.apiKeyUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Addon To Subscription
         * @param {string} productId 
         * @param {string} workspaceId 
         * @param {AddOnAddRequest} addOnAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAddonToSubscription: async (productId: string, workspaceId: string, addOnAddRequest: AddOnAddRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('addAddonToSubscription', 'productId', productId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addAddonToSubscription', 'workspaceId', workspaceId)
            // verify required parameter 'addOnAddRequest' is not null or undefined
            assertParamExists('addAddonToSubscription', 'addOnAddRequest', addOnAddRequest)
            const localVarPath = `/v2/billing/addons/{product_id}/add`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOnAddRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle Shopify subscription confirmation redirect. This is the redirect URI after successful purchase of any Shopify plan.  Args:     charge_id: The charge ID from Shopify (query parameter)     shop: The shop domain (query parameter)  Returns:     ShopifySubscriptionConfirmResponse with subscription details
         * @summary Confirm Shopify Subscription
         * @param {string} chargeId 
         * @param {string} shop 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmShopifySubscription: async (chargeId: string, shop: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chargeId' is not null or undefined
            assertParamExists('confirmShopifySubscription', 'chargeId', chargeId)
            // verify required parameter 'shop' is not null or undefined
            assertParamExists('confirmShopifySubscription', 'shop', shop)
            const localVarPath = `/v2/billing/shopify/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chargeId !== undefined) {
                localVarQueryParameter['charge_id'] = chargeId;
            }

            if (shop !== undefined) {
                localVarQueryParameter['shop'] = shop;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Change Plan Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChangePlanPortal: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/billing/portal/change-plan/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Checkout
         * @param {CheckoutCreateRequest} checkoutCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckout: async (checkoutCreateRequest: CheckoutCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutCreateRequest' is not null or undefined
            assertParamExists('createCheckout', 'checkoutCreateRequest', checkoutCreateRequest)
            const localVarPath = `/v2/billing/checkout/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Update Info Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpdateInfoPortal: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/billing/portal/update-info/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Pricing Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingPlans: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/billing/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User Plan
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPlan: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getUserPlan', 'workspaceId', workspaceId)
            const localVarPath = `/v2/billing/plans/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stripe Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeWebhook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/billing/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Addon To Subscription
         * @param {string} productId 
         * @param {string} workspaceId 
         * @param {AddOnAddRequest} addOnAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAddonToSubscription(productId: string, workspaceId: string, addOnAddRequest: AddOnAddRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAddonToSubscription(productId, workspaceId, addOnAddRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.addAddonToSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle Shopify subscription confirmation redirect. This is the redirect URI after successful purchase of any Shopify plan.  Args:     charge_id: The charge ID from Shopify (query parameter)     shop: The shop domain (query parameter)  Returns:     ShopifySubscriptionConfirmResponse with subscription details
         * @summary Confirm Shopify Subscription
         * @param {string} chargeId 
         * @param {string} shop 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmShopifySubscription(chargeId: string, shop: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopifySubscriptionConfirmResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmShopifySubscription(chargeId, shop, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.confirmShopifySubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Change Plan Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChangePlanPortal(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChangePlanPortal(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.createChangePlanPortal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Checkout
         * @param {CheckoutCreateRequest} checkoutCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckout(checkoutCreateRequest: CheckoutCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckout(checkoutCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.createCheckout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Update Info Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUpdateInfoPortal(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUpdateInfoPortal(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.createUpdateInfoPortal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Pricing Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricingPlans(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricingPlans(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getPricingPlans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get User Plan
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPlan(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPlanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPlan(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.getUserPlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stripe Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeWebhook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeWebhook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.stripeWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Addon To Subscription
         * @param {BillingApiAddAddonToSubscriptionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAddonToSubscription(requestParameters: BillingApiAddAddonToSubscriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.addAddonToSubscription(requestParameters.productId, requestParameters.workspaceId, requestParameters.addOnAddRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle Shopify subscription confirmation redirect. This is the redirect URI after successful purchase of any Shopify plan.  Args:     charge_id: The charge ID from Shopify (query parameter)     shop: The shop domain (query parameter)  Returns:     ShopifySubscriptionConfirmResponse with subscription details
         * @summary Confirm Shopify Subscription
         * @param {BillingApiConfirmShopifySubscriptionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmShopifySubscription(requestParameters: BillingApiConfirmShopifySubscriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ShopifySubscriptionConfirmResponse> {
            return localVarFp.confirmShopifySubscription(requestParameters.chargeId, requestParameters.shop, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Change Plan Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChangePlanPortal(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.createChangePlanPortal(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Checkout
         * @param {BillingApiCreateCheckoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckout(requestParameters: BillingApiCreateCheckoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createCheckout(requestParameters.checkoutCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Update Info Portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpdateInfoPortal(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createUpdateInfoPortal(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Pricing Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingPlans(options?: RawAxiosRequestConfig): AxiosPromise<PlanResponse> {
            return localVarFp.getPricingPlans(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User Plan
         * @param {BillingApiGetUserPlanRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPlan(requestParameters: BillingApiGetUserPlanRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserPlanResponse> {
            return localVarFp.getUserPlan(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stripe Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeWebhook(options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.stripeWebhook(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - interface
 * @export
 * @interface BillingApi
 */
export interface BillingApiInterface {
    /**
     * 
     * @summary Add Addon To Subscription
     * @param {BillingApiAddAddonToSubscriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    addAddonToSubscription(requestParameters: BillingApiAddAddonToSubscriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<string>;

    /**
     * Handle Shopify subscription confirmation redirect. This is the redirect URI after successful purchase of any Shopify plan.  Args:     charge_id: The charge ID from Shopify (query parameter)     shop: The shop domain (query parameter)  Returns:     ShopifySubscriptionConfirmResponse with subscription details
     * @summary Confirm Shopify Subscription
     * @param {BillingApiConfirmShopifySubscriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    confirmShopifySubscription(requestParameters: BillingApiConfirmShopifySubscriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ShopifySubscriptionConfirmResponse>;

    /**
     * 
     * @summary Create Change Plan Portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    createChangePlanPortal(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Create Checkout
     * @param {BillingApiCreateCheckoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    createCheckout(requestParameters: BillingApiCreateCheckoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Create Update Info Portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    createUpdateInfoPortal(options?: RawAxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Get Pricing Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    getPricingPlans(options?: RawAxiosRequestConfig): AxiosPromise<PlanResponse>;

    /**
     * 
     * @summary Get User Plan
     * @param {BillingApiGetUserPlanRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    getUserPlan(requestParameters: BillingApiGetUserPlanRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserPlanResponse>;

    /**
     * 
     * @summary Stripe Webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApiInterface
     */
    stripeWebhook(options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

}

/**
 * Request parameters for addAddonToSubscription operation in BillingApi.
 * @export
 * @interface BillingApiAddAddonToSubscriptionRequest
 */
export interface BillingApiAddAddonToSubscriptionRequest {
    /**
     * 
     * @type {string}
     * @memberof BillingApiAddAddonToSubscription
     */
    readonly productId: string

    /**
     * 
     * @type {string}
     * @memberof BillingApiAddAddonToSubscription
     */
    readonly workspaceId: string

    /**
     * 
     * @type {AddOnAddRequest}
     * @memberof BillingApiAddAddonToSubscription
     */
    readonly addOnAddRequest: AddOnAddRequest
}

/**
 * Request parameters for confirmShopifySubscription operation in BillingApi.
 * @export
 * @interface BillingApiConfirmShopifySubscriptionRequest
 */
export interface BillingApiConfirmShopifySubscriptionRequest {
    /**
     * 
     * @type {string}
     * @memberof BillingApiConfirmShopifySubscription
     */
    readonly chargeId: string

    /**
     * 
     * @type {string}
     * @memberof BillingApiConfirmShopifySubscription
     */
    readonly shop: string
}

/**
 * Request parameters for createCheckout operation in BillingApi.
 * @export
 * @interface BillingApiCreateCheckoutRequest
 */
export interface BillingApiCreateCheckoutRequest {
    /**
     * 
     * @type {CheckoutCreateRequest}
     * @memberof BillingApiCreateCheckout
     */
    readonly checkoutCreateRequest: CheckoutCreateRequest
}

/**
 * Request parameters for getUserPlan operation in BillingApi.
 * @export
 * @interface BillingApiGetUserPlanRequest
 */
export interface BillingApiGetUserPlanRequest {
    /**
     * 
     * @type {string}
     * @memberof BillingApiGetUserPlan
     */
    readonly workspaceId: string
}

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI implements BillingApiInterface {
    /**
     * 
     * @summary Add Addon To Subscription
     * @param {BillingApiAddAddonToSubscriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public addAddonToSubscription(requestParameters: BillingApiAddAddonToSubscriptionRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).addAddonToSubscription(requestParameters.productId, requestParameters.workspaceId, requestParameters.addOnAddRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle Shopify subscription confirmation redirect. This is the redirect URI after successful purchase of any Shopify plan.  Args:     charge_id: The charge ID from Shopify (query parameter)     shop: The shop domain (query parameter)  Returns:     ShopifySubscriptionConfirmResponse with subscription details
     * @summary Confirm Shopify Subscription
     * @param {BillingApiConfirmShopifySubscriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public confirmShopifySubscription(requestParameters: BillingApiConfirmShopifySubscriptionRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).confirmShopifySubscription(requestParameters.chargeId, requestParameters.shop, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Change Plan Portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public createChangePlanPortal(options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).createChangePlanPortal(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Checkout
     * @param {BillingApiCreateCheckoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public createCheckout(requestParameters: BillingApiCreateCheckoutRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).createCheckout(requestParameters.checkoutCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Update Info Portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public createUpdateInfoPortal(options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).createUpdateInfoPortal(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Pricing Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getPricingPlans(options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getPricingPlans(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User Plan
     * @param {BillingApiGetUserPlanRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public getUserPlan(requestParameters: BillingApiGetUserPlanRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).getUserPlan(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stripe Webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public stripeWebhook(options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).stripeWebhook(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatbotsApi - axios parameter creator
 * @export
 */
export const ChatbotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Chatbot
         * @param {string} workspaceId 
         * @param {ChatbotCreateRequest} chatbotCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatbot: async (workspaceId: string, chatbotCreateRequest: ChatbotCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createChatbot', 'workspaceId', workspaceId)
            // verify required parameter 'chatbotCreateRequest' is not null or undefined
            assertParamExists('createChatbot', 'chatbotCreateRequest', chatbotCreateRequest)
            const localVarPath = `/v2/chatbots/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatbotCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Chatbot
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChatbot: async (chatbotId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatbotId' is not null or undefined
            assertParamExists('deleteChatbot', 'chatbotId', chatbotId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteChatbot', 'workspaceId', workspaceId)
            const localVarPath = `/v2/chatbots/{chatbot_id}`
                .replace(`{${"chatbot_id"}}`, encodeURIComponent(String(chatbotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Chatbot
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatbot: async (chatbotId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatbotId' is not null or undefined
            assertParamExists('getChatbot', 'chatbotId', chatbotId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getChatbot', 'workspaceId', workspaceId)
            const localVarPath = `/v2/chatbots/{chatbot_id}`
                .replace(`{${"chatbot_id"}}`, encodeURIComponent(String(chatbotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Chatbots
         * @param {string} workspaceId 
         * @param {ChatbotSearchRequest} chatbotSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChatbots: async (workspaceId: string, chatbotSearchRequest: ChatbotSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchChatbots', 'workspaceId', workspaceId)
            // verify required parameter 'chatbotSearchRequest' is not null or undefined
            assertParamExists('searchChatbots', 'chatbotSearchRequest', chatbotSearchRequest)
            const localVarPath = `/v2/chatbots/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatbotSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Chatbot
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {ChatbotUpdateRequest} chatbotUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatbot: async (chatbotId: string, workspaceId: string, chatbotUpdateRequest: ChatbotUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatbotId' is not null or undefined
            assertParamExists('updateChatbot', 'chatbotId', chatbotId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateChatbot', 'workspaceId', workspaceId)
            // verify required parameter 'chatbotUpdateRequest' is not null or undefined
            assertParamExists('updateChatbot', 'chatbotUpdateRequest', chatbotUpdateRequest)
            const localVarPath = `/v2/chatbots/{chatbot_id}`
                .replace(`{${"chatbot_id"}}`, encodeURIComponent(String(chatbotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatbotUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatbotsApi - functional programming interface
 * @export
 */
export const ChatbotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatbotsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Chatbot
         * @param {string} workspaceId 
         * @param {ChatbotCreateRequest} chatbotCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChatbot(workspaceId: string, chatbotCreateRequest: ChatbotCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatbotResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChatbot(workspaceId, chatbotCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotsApi.createChatbot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Chatbot
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChatbot(chatbotId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChatbot(chatbotId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotsApi.deleteChatbot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Chatbot
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatbot(chatbotId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatbotResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatbot(chatbotId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotsApi.getChatbot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Chatbots
         * @param {string} workspaceId 
         * @param {ChatbotSearchRequest} chatbotSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchChatbots(workspaceId: string, chatbotSearchRequest: ChatbotSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChatbotResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchChatbots(workspaceId, chatbotSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotsApi.searchChatbots']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Chatbot
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {ChatbotUpdateRequest} chatbotUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChatbot(chatbotId: string, workspaceId: string, chatbotUpdateRequest: ChatbotUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatbotResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChatbot(chatbotId, workspaceId, chatbotUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotsApi.updateChatbot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatbotsApi - factory interface
 * @export
 */
export const ChatbotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatbotsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Chatbot
         * @param {ChatbotsApiCreateChatbotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatbot(requestParameters: ChatbotsApiCreateChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatbotResponse> {
            return localVarFp.createChatbot(requestParameters.workspaceId, requestParameters.chatbotCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Chatbot
         * @param {ChatbotsApiDeleteChatbotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChatbot(requestParameters: ChatbotsApiDeleteChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteChatbot(requestParameters.chatbotId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Chatbot
         * @param {ChatbotsApiGetChatbotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatbot(requestParameters: ChatbotsApiGetChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatbotResponse> {
            return localVarFp.getChatbot(requestParameters.chatbotId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Chatbots
         * @param {ChatbotsApiSearchChatbotsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChatbots(requestParameters: ChatbotsApiSearchChatbotsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ChatbotResponse>> {
            return localVarFp.searchChatbots(requestParameters.workspaceId, requestParameters.chatbotSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Chatbot
         * @param {ChatbotsApiUpdateChatbotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatbot(requestParameters: ChatbotsApiUpdateChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatbotResponse> {
            return localVarFp.updateChatbot(requestParameters.chatbotId, requestParameters.workspaceId, requestParameters.chatbotUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatbotsApi - interface
 * @export
 * @interface ChatbotsApi
 */
export interface ChatbotsApiInterface {
    /**
     * 
     * @summary Create Chatbot
     * @param {ChatbotsApiCreateChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApiInterface
     */
    createChatbot(requestParameters: ChatbotsApiCreateChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatbotResponse>;

    /**
     * 
     * @summary Delete Chatbot
     * @param {ChatbotsApiDeleteChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApiInterface
     */
    deleteChatbot(requestParameters: ChatbotsApiDeleteChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Get Chatbot
     * @param {ChatbotsApiGetChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApiInterface
     */
    getChatbot(requestParameters: ChatbotsApiGetChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatbotResponse>;

    /**
     * 
     * @summary Search Chatbots
     * @param {ChatbotsApiSearchChatbotsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApiInterface
     */
    searchChatbots(requestParameters: ChatbotsApiSearchChatbotsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ChatbotResponse>>;

    /**
     * 
     * @summary Update Chatbot
     * @param {ChatbotsApiUpdateChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApiInterface
     */
    updateChatbot(requestParameters: ChatbotsApiUpdateChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatbotResponse>;

}

/**
 * Request parameters for createChatbot operation in ChatbotsApi.
 * @export
 * @interface ChatbotsApiCreateChatbotRequest
 */
export interface ChatbotsApiCreateChatbotRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiCreateChatbot
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ChatbotCreateRequest}
     * @memberof ChatbotsApiCreateChatbot
     */
    readonly chatbotCreateRequest: ChatbotCreateRequest
}

/**
 * Request parameters for deleteChatbot operation in ChatbotsApi.
 * @export
 * @interface ChatbotsApiDeleteChatbotRequest
 */
export interface ChatbotsApiDeleteChatbotRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiDeleteChatbot
     */
    readonly chatbotId: string

    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiDeleteChatbot
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getChatbot operation in ChatbotsApi.
 * @export
 * @interface ChatbotsApiGetChatbotRequest
 */
export interface ChatbotsApiGetChatbotRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiGetChatbot
     */
    readonly chatbotId: string

    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiGetChatbot
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchChatbots operation in ChatbotsApi.
 * @export
 * @interface ChatbotsApiSearchChatbotsRequest
 */
export interface ChatbotsApiSearchChatbotsRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiSearchChatbots
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ChatbotSearchRequest}
     * @memberof ChatbotsApiSearchChatbots
     */
    readonly chatbotSearchRequest: ChatbotSearchRequest
}

/**
 * Request parameters for updateChatbot operation in ChatbotsApi.
 * @export
 * @interface ChatbotsApiUpdateChatbotRequest
 */
export interface ChatbotsApiUpdateChatbotRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiUpdateChatbot
     */
    readonly chatbotId: string

    /**
     * 
     * @type {string}
     * @memberof ChatbotsApiUpdateChatbot
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ChatbotUpdateRequest}
     * @memberof ChatbotsApiUpdateChatbot
     */
    readonly chatbotUpdateRequest: ChatbotUpdateRequest
}

/**
 * ChatbotsApi - object-oriented interface
 * @export
 * @class ChatbotsApi
 * @extends {BaseAPI}
 */
export class ChatbotsApi extends BaseAPI implements ChatbotsApiInterface {
    /**
     * 
     * @summary Create Chatbot
     * @param {ChatbotsApiCreateChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApi
     */
    public createChatbot(requestParameters: ChatbotsApiCreateChatbotRequest, options?: RawAxiosRequestConfig) {
        return ChatbotsApiFp(this.configuration).createChatbot(requestParameters.workspaceId, requestParameters.chatbotCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Chatbot
     * @param {ChatbotsApiDeleteChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApi
     */
    public deleteChatbot(requestParameters: ChatbotsApiDeleteChatbotRequest, options?: RawAxiosRequestConfig) {
        return ChatbotsApiFp(this.configuration).deleteChatbot(requestParameters.chatbotId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Chatbot
     * @param {ChatbotsApiGetChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApi
     */
    public getChatbot(requestParameters: ChatbotsApiGetChatbotRequest, options?: RawAxiosRequestConfig) {
        return ChatbotsApiFp(this.configuration).getChatbot(requestParameters.chatbotId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Chatbots
     * @param {ChatbotsApiSearchChatbotsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApi
     */
    public searchChatbots(requestParameters: ChatbotsApiSearchChatbotsRequest, options?: RawAxiosRequestConfig) {
        return ChatbotsApiFp(this.configuration).searchChatbots(requestParameters.workspaceId, requestParameters.chatbotSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Chatbot
     * @param {ChatbotsApiUpdateChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotsApi
     */
    public updateChatbot(requestParameters: ChatbotsApiUpdateChatbotRequest, options?: RawAxiosRequestConfig) {
        return ChatbotsApiFp(this.configuration).updateChatbot(requestParameters.chatbotId, requestParameters.workspaceId, requestParameters.chatbotUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CreditsApi - axios parameter creator
 * @export
 */
export const CreditsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the credit balance for the current user.
         * @summary Get Credit Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditBalance: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the credit balance for a workspace.
         * @summary Get Workspace Credit Balance
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceCreditBalance: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceCreditBalance', 'workspaceId', workspaceId)
            const localVarPath = `/v2/credits/workspace_balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for credit transactions based on criteria.
         * @summary Search Credit Transactions
         * @param {string} workspaceId 
         * @param {CreditTransactionSearchRequest} creditTransactionSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCreditTransactions: async (workspaceId: string, creditTransactionSearchRequest: CreditTransactionSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchCreditTransactions', 'workspaceId', workspaceId)
            // verify required parameter 'creditTransactionSearchRequest' is not null or undefined
            assertParamExists('searchCreditTransactions', 'creditTransactionSearchRequest', creditTransactionSearchRequest)
            const localVarPath = `/v2/credits/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditTransactionSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for daily credit transactions based on criteria.
         * @summary Search Daily Credit Transactions
         * @param {string} workspaceId 
         * @param {CreditDailyTransactionSearchRequest} creditDailyTransactionSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDailyCreditTransactions: async (workspaceId: string, creditDailyTransactionSearchRequest: CreditDailyTransactionSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchDailyCreditTransactions', 'workspaceId', workspaceId)
            // verify required parameter 'creditDailyTransactionSearchRequest' is not null or undefined
            assertParamExists('searchDailyCreditTransactions', 'creditDailyTransactionSearchRequest', creditDailyTransactionSearchRequest)
            const localVarPath = `/v2/credits/search_daily`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditDailyTransactionSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditsApi - functional programming interface
 * @export
 */
export const CreditsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the credit balance for the current user.
         * @summary Get Credit Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCreditBalance(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCreditBalance(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.getCreditBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the credit balance for a workspace.
         * @summary Get Workspace Credit Balance
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceCreditBalance(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceCreditBalance(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.getWorkspaceCreditBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for credit transactions based on criteria.
         * @summary Search Credit Transactions
         * @param {string} workspaceId 
         * @param {CreditTransactionSearchRequest} creditTransactionSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCreditTransactions(workspaceId: string, creditTransactionSearchRequest: CreditTransactionSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreditTransactionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCreditTransactions(workspaceId, creditTransactionSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.searchCreditTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for daily credit transactions based on criteria.
         * @summary Search Daily Credit Transactions
         * @param {string} workspaceId 
         * @param {CreditDailyTransactionSearchRequest} creditDailyTransactionSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDailyCreditTransactions(workspaceId: string, creditDailyTransactionSearchRequest: CreditDailyTransactionSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreditDailyTransactionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDailyCreditTransactions(workspaceId, creditDailyTransactionSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.searchDailyCreditTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CreditsApi - factory interface
 * @export
 */
export const CreditsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditsApiFp(configuration)
    return {
        /**
         * Get the credit balance for the current user.
         * @summary Get Credit Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreditBalance(options?: RawAxiosRequestConfig): AxiosPromise<CreditBalanceResponse> {
            return localVarFp.getCreditBalance(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the credit balance for a workspace.
         * @summary Get Workspace Credit Balance
         * @param {CreditsApiGetWorkspaceCreditBalanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceCreditBalance(requestParameters: CreditsApiGetWorkspaceCreditBalanceRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreditBalanceResponse> {
            return localVarFp.getWorkspaceCreditBalance(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for credit transactions based on criteria.
         * @summary Search Credit Transactions
         * @param {CreditsApiSearchCreditTransactionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCreditTransactions(requestParameters: CreditsApiSearchCreditTransactionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreditTransactionResponse>> {
            return localVarFp.searchCreditTransactions(requestParameters.workspaceId, requestParameters.creditTransactionSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for daily credit transactions based on criteria.
         * @summary Search Daily Credit Transactions
         * @param {CreditsApiSearchDailyCreditTransactionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDailyCreditTransactions(requestParameters: CreditsApiSearchDailyCreditTransactionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreditDailyTransactionResponse>> {
            return localVarFp.searchDailyCreditTransactions(requestParameters.workspaceId, requestParameters.creditDailyTransactionSearchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditsApi - interface
 * @export
 * @interface CreditsApi
 */
export interface CreditsApiInterface {
    /**
     * Get the credit balance for the current user.
     * @summary Get Credit Balance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApiInterface
     */
    getCreditBalance(options?: RawAxiosRequestConfig): AxiosPromise<CreditBalanceResponse>;

    /**
     * Get the credit balance for a workspace.
     * @summary Get Workspace Credit Balance
     * @param {CreditsApiGetWorkspaceCreditBalanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApiInterface
     */
    getWorkspaceCreditBalance(requestParameters: CreditsApiGetWorkspaceCreditBalanceRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreditBalanceResponse>;

    /**
     * Search for credit transactions based on criteria.
     * @summary Search Credit Transactions
     * @param {CreditsApiSearchCreditTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApiInterface
     */
    searchCreditTransactions(requestParameters: CreditsApiSearchCreditTransactionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreditTransactionResponse>>;

    /**
     * Search for daily credit transactions based on criteria.
     * @summary Search Daily Credit Transactions
     * @param {CreditsApiSearchDailyCreditTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApiInterface
     */
    searchDailyCreditTransactions(requestParameters: CreditsApiSearchDailyCreditTransactionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreditDailyTransactionResponse>>;

}

/**
 * Request parameters for getWorkspaceCreditBalance operation in CreditsApi.
 * @export
 * @interface CreditsApiGetWorkspaceCreditBalanceRequest
 */
export interface CreditsApiGetWorkspaceCreditBalanceRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditsApiGetWorkspaceCreditBalance
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchCreditTransactions operation in CreditsApi.
 * @export
 * @interface CreditsApiSearchCreditTransactionsRequest
 */
export interface CreditsApiSearchCreditTransactionsRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditsApiSearchCreditTransactions
     */
    readonly workspaceId: string

    /**
     * 
     * @type {CreditTransactionSearchRequest}
     * @memberof CreditsApiSearchCreditTransactions
     */
    readonly creditTransactionSearchRequest: CreditTransactionSearchRequest
}

/**
 * Request parameters for searchDailyCreditTransactions operation in CreditsApi.
 * @export
 * @interface CreditsApiSearchDailyCreditTransactionsRequest
 */
export interface CreditsApiSearchDailyCreditTransactionsRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditsApiSearchDailyCreditTransactions
     */
    readonly workspaceId: string

    /**
     * 
     * @type {CreditDailyTransactionSearchRequest}
     * @memberof CreditsApiSearchDailyCreditTransactions
     */
    readonly creditDailyTransactionSearchRequest: CreditDailyTransactionSearchRequest
}

/**
 * CreditsApi - object-oriented interface
 * @export
 * @class CreditsApi
 * @extends {BaseAPI}
 */
export class CreditsApi extends BaseAPI implements CreditsApiInterface {
    /**
     * Get the credit balance for the current user.
     * @summary Get Credit Balance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public getCreditBalance(options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).getCreditBalance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the credit balance for a workspace.
     * @summary Get Workspace Credit Balance
     * @param {CreditsApiGetWorkspaceCreditBalanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public getWorkspaceCreditBalance(requestParameters: CreditsApiGetWorkspaceCreditBalanceRequest, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).getWorkspaceCreditBalance(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for credit transactions based on criteria.
     * @summary Search Credit Transactions
     * @param {CreditsApiSearchCreditTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public searchCreditTransactions(requestParameters: CreditsApiSearchCreditTransactionsRequest, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).searchCreditTransactions(requestParameters.workspaceId, requestParameters.creditTransactionSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for daily credit transactions based on criteria.
     * @summary Search Daily Credit Transactions
     * @param {CreditsApiSearchDailyCreditTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public searchDailyCreditTransactions(requestParameters: CreditsApiSearchDailyCreditTransactionsRequest, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).searchDailyCreditTransactions(requestParameters.workspaceId, requestParameters.creditDailyTransactionSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Document Category
         * @param {string} workspaceId 
         * @param {DocumentCategoryCreateRequest} documentCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentCategory: async (workspaceId: string, documentCategoryCreateRequest: DocumentCategoryCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createDocumentCategory', 'workspaceId', workspaceId)
            // verify required parameter 'documentCategoryCreateRequest' is not null or undefined
            assertParamExists('createDocumentCategory', 'documentCategoryCreateRequest', documentCategoryCreateRequest)
            const localVarPath = `/v2/documents/categories/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentCategoryCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Faq
         * @param {string} workspaceId 
         * @param {FaqCreateRequest} faqCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFaq: async (workspaceId: string, faqCreateRequest: FaqCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createFaq', 'workspaceId', workspaceId)
            // verify required parameter 'faqCreateRequest' is not null or undefined
            assertParamExists('createFaq', 'faqCreateRequest', faqCreateRequest)
            const localVarPath = `/v2/documents/faqs/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(faqCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument: async (docId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('deleteDocument', 'docId', docId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteDocument', 'workspaceId', workspaceId)
            const localVarPath = `/v2/documents/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Document Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentCategory: async (catId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('deleteDocumentCategory', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteDocumentCategory', 'workspaceId', workspaceId)
            const localVarPath = `/v2/documents/categories/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Faq
         * @param {string} faqId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFaq: async (faqId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'faqId' is not null or undefined
            assertParamExists('deleteFaq', 'faqId', faqId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteFaq', 'workspaceId', workspaceId)
            const localVarPath = `/v2/documents/faqs/{faq_id}`
                .replace(`{${"faq_id"}}`, encodeURIComponent(String(faqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Binary Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBinaryDocument: async (docId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('downloadBinaryDocument', 'docId', docId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('downloadBinaryDocument', 'workspaceId', workspaceId)
            const localVarPath = `/v2/documents/download/binary/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Text Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTextDocument: async (docId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('downloadTextDocument', 'docId', docId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('downloadTextDocument', 'workspaceId', workspaceId)
            const localVarPath = `/v2/documents/download/text/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Faq
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFaq: async (workspaceId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('importFaq', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('importFaq', 'file', file)
            const localVarPath = `/v2/documents/faqs/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Document Categories
         * @param {string} workspaceId 
         * @param {DocumentCategorySearchRequest} documentCategorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocumentCategories: async (workspaceId: string, documentCategorySearchRequest: DocumentCategorySearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchDocumentCategories', 'workspaceId', workspaceId)
            // verify required parameter 'documentCategorySearchRequest' is not null or undefined
            assertParamExists('searchDocumentCategories', 'documentCategorySearchRequest', documentCategorySearchRequest)
            const localVarPath = `/v2/documents/categories/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentCategorySearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Documents
         * @param {string} workspaceId 
         * @param {DocumentSearchRequest} documentSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocuments: async (workspaceId: string, documentSearchRequest: DocumentSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchDocuments', 'workspaceId', workspaceId)
            // verify required parameter 'documentSearchRequest' is not null or undefined
            assertParamExists('searchDocuments', 'documentSearchRequest', documentSearchRequest)
            const localVarPath = `/v2/documents/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Faqs
         * @param {string} workspaceId 
         * @param {FaqSearchRequest} faqSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFaqs: async (workspaceId: string, faqSearchRequest: FaqSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchFaqs', 'workspaceId', workspaceId)
            // verify required parameter 'faqSearchRequest' is not null or undefined
            assertParamExists('searchFaqs', 'faqSearchRequest', faqSearchRequest)
            const localVarPath = `/v2/documents/faqs/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(faqSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {DocumentUpdateRequest} documentUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocument: async (docId: string, workspaceId: string, documentUpdateRequest: DocumentUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'docId' is not null or undefined
            assertParamExists('updateDocument', 'docId', docId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateDocument', 'workspaceId', workspaceId)
            // verify required parameter 'documentUpdateRequest' is not null or undefined
            assertParamExists('updateDocument', 'documentUpdateRequest', documentUpdateRequest)
            const localVarPath = `/v2/documents/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Document Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {DocumentCategoryUpdateRequest} documentCategoryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentCategory: async (catId: string, workspaceId: string, documentCategoryUpdateRequest: DocumentCategoryUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('updateDocumentCategory', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateDocumentCategory', 'workspaceId', workspaceId)
            // verify required parameter 'documentCategoryUpdateRequest' is not null or undefined
            assertParamExists('updateDocumentCategory', 'documentCategoryUpdateRequest', documentCategoryUpdateRequest)
            const localVarPath = `/v2/documents/categories/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentCategoryUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Faq
         * @param {string} faqId 
         * @param {string} workspaceId 
         * @param {FaqUpdateRequest} faqUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFaq: async (faqId: string, workspaceId: string, faqUpdateRequest: FaqUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'faqId' is not null or undefined
            assertParamExists('updateFaq', 'faqId', faqId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateFaq', 'workspaceId', workspaceId)
            // verify required parameter 'faqUpdateRequest' is not null or undefined
            assertParamExists('updateFaq', 'faqUpdateRequest', faqUpdateRequest)
            const localVarPath = `/v2/documents/faqs/{faq_id}`
                .replace(`{${"faq_id"}}`, encodeURIComponent(String(faqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(faqUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload From Url Document
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {AppUrlInput} appUrlInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFromUrlDocument: async (catId: string, workspaceId: string, appUrlInput: AppUrlInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('uploadFromUrlDocument', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('uploadFromUrlDocument', 'workspaceId', workspaceId)
            // verify required parameter 'appUrlInput' is not null or undefined
            assertParamExists('uploadFromUrlDocument', 'appUrlInput', appUrlInput)
            const localVarPath = `/v2/documents/upload-from-url/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appUrlInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Memory Document
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMemoryDocument: async (catId: string, workspaceId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('uploadMemoryDocument', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('uploadMemoryDocument', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadMemoryDocument', 'file', file)
            const localVarPath = `/v2/documents/upload/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Document Category
         * @param {string} workspaceId 
         * @param {DocumentCategoryCreateRequest} documentCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDocumentCategory(workspaceId: string, documentCategoryCreateRequest: DocumentCategoryCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDocumentCategory(workspaceId, documentCategoryCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.createDocumentCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Faq
         * @param {string} workspaceId 
         * @param {FaqCreateRequest} faqCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFaq(workspaceId: string, faqCreateRequest: FaqCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FaqResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFaq(workspaceId, faqCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.createFaq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocument(docId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocument(docId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.deleteDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Document Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocumentCategory(catId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocumentCategory(catId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.deleteDocumentCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Faq
         * @param {string} faqId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFaq(faqId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFaq(faqId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.deleteFaq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download Binary Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadBinaryDocument(docId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadBinaryDocument(docId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.downloadBinaryDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download Text Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTextDocument(docId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTextDocument(docId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.downloadTextDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Import Faq
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importFaq(workspaceId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaqImportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importFaq(workspaceId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.importFaq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Document Categories
         * @param {string} workspaceId 
         * @param {DocumentCategorySearchRequest} documentCategorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDocumentCategories(workspaceId: string, documentCategorySearchRequest: DocumentCategorySearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentCategoryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDocumentCategories(workspaceId, documentCategorySearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.searchDocumentCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Documents
         * @param {string} workspaceId 
         * @param {DocumentSearchRequest} documentSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDocuments(workspaceId: string, documentSearchRequest: DocumentSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDocuments(workspaceId, documentSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.searchDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Faqs
         * @param {string} workspaceId 
         * @param {FaqSearchRequest} faqSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchFaqs(workspaceId: string, faqSearchRequest: FaqSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FaqResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFaqs(workspaceId, faqSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.searchFaqs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Document
         * @param {string} docId 
         * @param {string} workspaceId 
         * @param {DocumentUpdateRequest} documentUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDocument(docId: string, workspaceId: string, documentUpdateRequest: DocumentUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDocument(docId, workspaceId, documentUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.updateDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Document Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {DocumentCategoryUpdateRequest} documentCategoryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDocumentCategory(catId: string, workspaceId: string, documentCategoryUpdateRequest: DocumentCategoryUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDocumentCategory(catId, workspaceId, documentCategoryUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.updateDocumentCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Faq
         * @param {string} faqId 
         * @param {string} workspaceId 
         * @param {FaqUpdateRequest} faqUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFaq(faqId: string, workspaceId: string, faqUpdateRequest: FaqUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FaqResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFaq(faqId, workspaceId, faqUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.updateFaq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload From Url Document
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {AppUrlInput} appUrlInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFromUrlDocument(catId: string, workspaceId: string, appUrlInput: AppUrlInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFromUrlDocument(catId, workspaceId, appUrlInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.uploadFromUrlDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Memory Document
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadMemoryDocument(catId: string, workspaceId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadMemoryDocument(catId, workspaceId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.uploadMemoryDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Document Category
         * @param {DocumentsApiCreateDocumentCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentCategory(requestParameters: DocumentsApiCreateDocumentCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentCategoryResponse> {
            return localVarFp.createDocumentCategory(requestParameters.workspaceId, requestParameters.documentCategoryCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Faq
         * @param {DocumentsApiCreateFaqRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFaq(requestParameters: DocumentsApiCreateFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FaqResponse>> {
            return localVarFp.createFaq(requestParameters.workspaceId, requestParameters.faqCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Document
         * @param {DocumentsApiDeleteDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument(requestParameters: DocumentsApiDeleteDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteDocument(requestParameters.docId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Document Category
         * @param {DocumentsApiDeleteDocumentCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentCategory(requestParameters: DocumentsApiDeleteDocumentCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteDocumentCategory(requestParameters.catId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Faq
         * @param {DocumentsApiDeleteFaqRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFaq(requestParameters: DocumentsApiDeleteFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteFaq(requestParameters.faqId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Binary Document
         * @param {DocumentsApiDownloadBinaryDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBinaryDocument(requestParameters: DocumentsApiDownloadBinaryDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.downloadBinaryDocument(requestParameters.docId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Text Document
         * @param {DocumentsApiDownloadTextDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTextDocument(requestParameters: DocumentsApiDownloadTextDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentContent> {
            return localVarFp.downloadTextDocument(requestParameters.docId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import Faq
         * @param {DocumentsApiImportFaqRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFaq(requestParameters: DocumentsApiImportFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<FaqImportResponse> {
            return localVarFp.importFaq(requestParameters.workspaceId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Document Categories
         * @param {DocumentsApiSearchDocumentCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocumentCategories(requestParameters: DocumentsApiSearchDocumentCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<DocumentCategoryResponse>> {
            return localVarFp.searchDocumentCategories(requestParameters.workspaceId, requestParameters.documentCategorySearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Documents
         * @param {DocumentsApiSearchDocumentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocuments(requestParameters: DocumentsApiSearchDocumentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<DocumentResponse>> {
            return localVarFp.searchDocuments(requestParameters.workspaceId, requestParameters.documentSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Faqs
         * @param {DocumentsApiSearchFaqsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFaqs(requestParameters: DocumentsApiSearchFaqsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FaqResponse>> {
            return localVarFp.searchFaqs(requestParameters.workspaceId, requestParameters.faqSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Document
         * @param {DocumentsApiUpdateDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocument(requestParameters: DocumentsApiUpdateDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse> {
            return localVarFp.updateDocument(requestParameters.docId, requestParameters.workspaceId, requestParameters.documentUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Document Category
         * @param {DocumentsApiUpdateDocumentCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentCategory(requestParameters: DocumentsApiUpdateDocumentCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentCategoryResponse> {
            return localVarFp.updateDocumentCategory(requestParameters.catId, requestParameters.workspaceId, requestParameters.documentCategoryUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Faq
         * @param {DocumentsApiUpdateFaqRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFaq(requestParameters: DocumentsApiUpdateFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FaqResponse>> {
            return localVarFp.updateFaq(requestParameters.faqId, requestParameters.workspaceId, requestParameters.faqUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload From Url Document
         * @param {DocumentsApiUploadFromUrlDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFromUrlDocument(requestParameters: DocumentsApiUploadFromUrlDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse> {
            return localVarFp.uploadFromUrlDocument(requestParameters.catId, requestParameters.workspaceId, requestParameters.appUrlInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Memory Document
         * @param {DocumentsApiUploadMemoryDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMemoryDocument(requestParameters: DocumentsApiUploadMemoryDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse> {
            return localVarFp.uploadMemoryDocument(requestParameters.catId, requestParameters.workspaceId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - interface
 * @export
 * @interface DocumentsApi
 */
export interface DocumentsApiInterface {
    /**
     * 
     * @summary Create Document Category
     * @param {DocumentsApiCreateDocumentCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    createDocumentCategory(requestParameters: DocumentsApiCreateDocumentCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentCategoryResponse>;

    /**
     * 
     * @summary Create Faq
     * @param {DocumentsApiCreateFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    createFaq(requestParameters: DocumentsApiCreateFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FaqResponse>>;

    /**
     * 
     * @summary Delete Document
     * @param {DocumentsApiDeleteDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    deleteDocument(requestParameters: DocumentsApiDeleteDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Delete Document Category
     * @param {DocumentsApiDeleteDocumentCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    deleteDocumentCategory(requestParameters: DocumentsApiDeleteDocumentCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Delete Faq
     * @param {DocumentsApiDeleteFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    deleteFaq(requestParameters: DocumentsApiDeleteFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Download Binary Document
     * @param {DocumentsApiDownloadBinaryDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    downloadBinaryDocument(requestParameters: DocumentsApiDownloadBinaryDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Download Text Document
     * @param {DocumentsApiDownloadTextDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    downloadTextDocument(requestParameters: DocumentsApiDownloadTextDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentContent>;

    /**
     * 
     * @summary Import Faq
     * @param {DocumentsApiImportFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    importFaq(requestParameters: DocumentsApiImportFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<FaqImportResponse>;

    /**
     * 
     * @summary Search Document Categories
     * @param {DocumentsApiSearchDocumentCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    searchDocumentCategories(requestParameters: DocumentsApiSearchDocumentCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<DocumentCategoryResponse>>;

    /**
     * 
     * @summary Search Documents
     * @param {DocumentsApiSearchDocumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    searchDocuments(requestParameters: DocumentsApiSearchDocumentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<DocumentResponse>>;

    /**
     * 
     * @summary Search Faqs
     * @param {DocumentsApiSearchFaqsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    searchFaqs(requestParameters: DocumentsApiSearchFaqsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FaqResponse>>;

    /**
     * 
     * @summary Update Document
     * @param {DocumentsApiUpdateDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    updateDocument(requestParameters: DocumentsApiUpdateDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse>;

    /**
     * 
     * @summary Update Document Category
     * @param {DocumentsApiUpdateDocumentCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    updateDocumentCategory(requestParameters: DocumentsApiUpdateDocumentCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentCategoryResponse>;

    /**
     * 
     * @summary Update Faq
     * @param {DocumentsApiUpdateFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    updateFaq(requestParameters: DocumentsApiUpdateFaqRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FaqResponse>>;

    /**
     * 
     * @summary Upload From Url Document
     * @param {DocumentsApiUploadFromUrlDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    uploadFromUrlDocument(requestParameters: DocumentsApiUploadFromUrlDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse>;

    /**
     * 
     * @summary Upload Memory Document
     * @param {DocumentsApiUploadMemoryDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    uploadMemoryDocument(requestParameters: DocumentsApiUploadMemoryDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse>;

}

/**
 * Request parameters for createDocumentCategory operation in DocumentsApi.
 * @export
 * @interface DocumentsApiCreateDocumentCategoryRequest
 */
export interface DocumentsApiCreateDocumentCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiCreateDocumentCategory
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DocumentCategoryCreateRequest}
     * @memberof DocumentsApiCreateDocumentCategory
     */
    readonly documentCategoryCreateRequest: DocumentCategoryCreateRequest
}

/**
 * Request parameters for createFaq operation in DocumentsApi.
 * @export
 * @interface DocumentsApiCreateFaqRequest
 */
export interface DocumentsApiCreateFaqRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiCreateFaq
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FaqCreateRequest}
     * @memberof DocumentsApiCreateFaq
     */
    readonly faqCreateRequest: FaqCreateRequest
}

/**
 * Request parameters for deleteDocument operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDeleteDocumentRequest
 */
export interface DocumentsApiDeleteDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDeleteDocument
     */
    readonly docId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDeleteDocument
     */
    readonly workspaceId: string
}

/**
 * Request parameters for deleteDocumentCategory operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDeleteDocumentCategoryRequest
 */
export interface DocumentsApiDeleteDocumentCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDeleteDocumentCategory
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDeleteDocumentCategory
     */
    readonly workspaceId: string
}

/**
 * Request parameters for deleteFaq operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDeleteFaqRequest
 */
export interface DocumentsApiDeleteFaqRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDeleteFaq
     */
    readonly faqId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDeleteFaq
     */
    readonly workspaceId: string
}

/**
 * Request parameters for downloadBinaryDocument operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDownloadBinaryDocumentRequest
 */
export interface DocumentsApiDownloadBinaryDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDownloadBinaryDocument
     */
    readonly docId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDownloadBinaryDocument
     */
    readonly workspaceId: string
}

/**
 * Request parameters for downloadTextDocument operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDownloadTextDocumentRequest
 */
export interface DocumentsApiDownloadTextDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDownloadTextDocument
     */
    readonly docId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDownloadTextDocument
     */
    readonly workspaceId: string
}

/**
 * Request parameters for importFaq operation in DocumentsApi.
 * @export
 * @interface DocumentsApiImportFaqRequest
 */
export interface DocumentsApiImportFaqRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiImportFaq
     */
    readonly workspaceId: string

    /**
     * 
     * @type {File}
     * @memberof DocumentsApiImportFaq
     */
    readonly file: File
}

/**
 * Request parameters for searchDocumentCategories operation in DocumentsApi.
 * @export
 * @interface DocumentsApiSearchDocumentCategoriesRequest
 */
export interface DocumentsApiSearchDocumentCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiSearchDocumentCategories
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DocumentCategorySearchRequest}
     * @memberof DocumentsApiSearchDocumentCategories
     */
    readonly documentCategorySearchRequest: DocumentCategorySearchRequest
}

/**
 * Request parameters for searchDocuments operation in DocumentsApi.
 * @export
 * @interface DocumentsApiSearchDocumentsRequest
 */
export interface DocumentsApiSearchDocumentsRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiSearchDocuments
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DocumentSearchRequest}
     * @memberof DocumentsApiSearchDocuments
     */
    readonly documentSearchRequest: DocumentSearchRequest
}

/**
 * Request parameters for searchFaqs operation in DocumentsApi.
 * @export
 * @interface DocumentsApiSearchFaqsRequest
 */
export interface DocumentsApiSearchFaqsRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiSearchFaqs
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FaqSearchRequest}
     * @memberof DocumentsApiSearchFaqs
     */
    readonly faqSearchRequest: FaqSearchRequest
}

/**
 * Request parameters for updateDocument operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUpdateDocumentRequest
 */
export interface DocumentsApiUpdateDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUpdateDocument
     */
    readonly docId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUpdateDocument
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DocumentUpdateRequest}
     * @memberof DocumentsApiUpdateDocument
     */
    readonly documentUpdateRequest: DocumentUpdateRequest
}

/**
 * Request parameters for updateDocumentCategory operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUpdateDocumentCategoryRequest
 */
export interface DocumentsApiUpdateDocumentCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUpdateDocumentCategory
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUpdateDocumentCategory
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DocumentCategoryUpdateRequest}
     * @memberof DocumentsApiUpdateDocumentCategory
     */
    readonly documentCategoryUpdateRequest: DocumentCategoryUpdateRequest
}

/**
 * Request parameters for updateFaq operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUpdateFaqRequest
 */
export interface DocumentsApiUpdateFaqRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUpdateFaq
     */
    readonly faqId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUpdateFaq
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FaqUpdateRequest}
     * @memberof DocumentsApiUpdateFaq
     */
    readonly faqUpdateRequest: FaqUpdateRequest
}

/**
 * Request parameters for uploadFromUrlDocument operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUploadFromUrlDocumentRequest
 */
export interface DocumentsApiUploadFromUrlDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUploadFromUrlDocument
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUploadFromUrlDocument
     */
    readonly workspaceId: string

    /**
     * 
     * @type {AppUrlInput}
     * @memberof DocumentsApiUploadFromUrlDocument
     */
    readonly appUrlInput: AppUrlInput
}

/**
 * Request parameters for uploadMemoryDocument operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUploadMemoryDocumentRequest
 */
export interface DocumentsApiUploadMemoryDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUploadMemoryDocument
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUploadMemoryDocument
     */
    readonly workspaceId: string

    /**
     * 
     * @type {File}
     * @memberof DocumentsApiUploadMemoryDocument
     */
    readonly file: File
}

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI implements DocumentsApiInterface {
    /**
     * 
     * @summary Create Document Category
     * @param {DocumentsApiCreateDocumentCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public createDocumentCategory(requestParameters: DocumentsApiCreateDocumentCategoryRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).createDocumentCategory(requestParameters.workspaceId, requestParameters.documentCategoryCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Faq
     * @param {DocumentsApiCreateFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public createFaq(requestParameters: DocumentsApiCreateFaqRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).createFaq(requestParameters.workspaceId, requestParameters.faqCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Document
     * @param {DocumentsApiDeleteDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public deleteDocument(requestParameters: DocumentsApiDeleteDocumentRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).deleteDocument(requestParameters.docId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Document Category
     * @param {DocumentsApiDeleteDocumentCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public deleteDocumentCategory(requestParameters: DocumentsApiDeleteDocumentCategoryRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).deleteDocumentCategory(requestParameters.catId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Faq
     * @param {DocumentsApiDeleteFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public deleteFaq(requestParameters: DocumentsApiDeleteFaqRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).deleteFaq(requestParameters.faqId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Binary Document
     * @param {DocumentsApiDownloadBinaryDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public downloadBinaryDocument(requestParameters: DocumentsApiDownloadBinaryDocumentRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).downloadBinaryDocument(requestParameters.docId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Text Document
     * @param {DocumentsApiDownloadTextDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public downloadTextDocument(requestParameters: DocumentsApiDownloadTextDocumentRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).downloadTextDocument(requestParameters.docId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import Faq
     * @param {DocumentsApiImportFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public importFaq(requestParameters: DocumentsApiImportFaqRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).importFaq(requestParameters.workspaceId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Document Categories
     * @param {DocumentsApiSearchDocumentCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public searchDocumentCategories(requestParameters: DocumentsApiSearchDocumentCategoriesRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).searchDocumentCategories(requestParameters.workspaceId, requestParameters.documentCategorySearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Documents
     * @param {DocumentsApiSearchDocumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public searchDocuments(requestParameters: DocumentsApiSearchDocumentsRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).searchDocuments(requestParameters.workspaceId, requestParameters.documentSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Faqs
     * @param {DocumentsApiSearchFaqsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public searchFaqs(requestParameters: DocumentsApiSearchFaqsRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).searchFaqs(requestParameters.workspaceId, requestParameters.faqSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Document
     * @param {DocumentsApiUpdateDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public updateDocument(requestParameters: DocumentsApiUpdateDocumentRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).updateDocument(requestParameters.docId, requestParameters.workspaceId, requestParameters.documentUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Document Category
     * @param {DocumentsApiUpdateDocumentCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public updateDocumentCategory(requestParameters: DocumentsApiUpdateDocumentCategoryRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).updateDocumentCategory(requestParameters.catId, requestParameters.workspaceId, requestParameters.documentCategoryUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Faq
     * @param {DocumentsApiUpdateFaqRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public updateFaq(requestParameters: DocumentsApiUpdateFaqRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).updateFaq(requestParameters.faqId, requestParameters.workspaceId, requestParameters.faqUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload From Url Document
     * @param {DocumentsApiUploadFromUrlDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public uploadFromUrlDocument(requestParameters: DocumentsApiUploadFromUrlDocumentRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).uploadFromUrlDocument(requestParameters.catId, requestParameters.workspaceId, requestParameters.appUrlInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Memory Document
     * @param {DocumentsApiUploadMemoryDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public uploadMemoryDocument(requestParameters: DocumentsApiUploadMemoryDocumentRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).uploadMemoryDocument(requestParameters.catId, requestParameters.workspaceId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FineTuningsApi - axios parameter creator
 * @export
 */
export const FineTuningsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Image Ft
         * @param {string} workspaceId 
         * @param {ImageFTCreateRequest} imageFTCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageFt: async (workspaceId: string, imageFTCreateRequest: ImageFTCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createImageFt', 'workspaceId', workspaceId)
            // verify required parameter 'imageFTCreateRequest' is not null or undefined
            assertParamExists('createImageFt', 'imageFTCreateRequest', imageFTCreateRequest)
            const localVarPath = `/v2/photo_ai/images/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageFTCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete File Ft
         * @param {string} fileKey 
         * @param {string} workspaceId 
         * @param {InferenceFileType} fileType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileFt: async (fileKey: string, workspaceId: string, fileType: InferenceFileType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileKey' is not null or undefined
            assertParamExists('deleteFileFt', 'fileKey', fileKey)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteFileFt', 'workspaceId', workspaceId)
            // verify required parameter 'fileType' is not null or undefined
            assertParamExists('deleteFileFt', 'fileType', fileType)
            const localVarPath = `/v2/photo_ai/files/{file_key}`
                .replace(`{${"file_key"}}`, encodeURIComponent(String(fileKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (fileType !== undefined) {
                localVarQueryParameter['file_type'] = fileType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Image Ft
         * @param {string} ftId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImageFt: async (ftId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ftId' is not null or undefined
            assertParamExists('deleteImageFt', 'ftId', ftId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteImageFt', 'workspaceId', workspaceId)
            const localVarPath = `/v2/photo_ai/images/{ft_id}`
                .replace(`{${"ft_id"}}`, encodeURIComponent(String(ftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate Image Prompt
         * @param {string} workspaceId 
         * @param {ImagePromptGenerationRequest} imagePromptGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateImagePrompt: async (workspaceId: string, imagePromptGenerationRequest: ImagePromptGenerationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('generateImagePrompt', 'workspaceId', workspaceId)
            // verify required parameter 'imagePromptGenerationRequest' is not null or undefined
            assertParamExists('generateImagePrompt', 'imagePromptGenerationRequest', imagePromptGenerationRequest)
            const localVarPath = `/v2/photo_ai/inference/images/generate-prompt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imagePromptGenerationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate Images
         * @param {string} workspaceId 
         * @param {ImageInferenceRequest} imageInferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateImages: async (workspaceId: string, imageInferenceRequest: ImageInferenceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('generateImages', 'workspaceId', workspaceId)
            // verify required parameter 'imageInferenceRequest' is not null or undefined
            assertParamExists('generateImages', 'imageInferenceRequest', imageInferenceRequest)
            const localVarPath = `/v2/photo_ai/inference/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageInferenceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get File Ft
         * @param {string} fileKey 
         * @param {string} workspaceId 
         * @param {InferenceFileType} fileType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileFt: async (fileKey: string, workspaceId: string, fileType: InferenceFileType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileKey' is not null or undefined
            assertParamExists('getFileFt', 'fileKey', fileKey)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getFileFt', 'workspaceId', workspaceId)
            // verify required parameter 'fileType' is not null or undefined
            assertParamExists('getFileFt', 'fileType', fileType)
            const localVarPath = `/v2/photo_ai/files/{file_key}`
                .replace(`{${"file_key"}}`, encodeURIComponent(String(fileKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (fileType !== undefined) {
                localVarQueryParameter['file_type'] = fileType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Inference Results
         * @param {string} inferenceId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInferenceResults: async (inferenceId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inferenceId' is not null or undefined
            assertParamExists('getInferenceResults', 'inferenceId', inferenceId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getInferenceResults', 'workspaceId', workspaceId)
            const localVarPath = `/v2/photo_ai/inference/results/{inference_id}`
                .replace(`{${"inference_id"}}`, encodeURIComponent(String(inferenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Handle Replicate Webhook
         * @param {string} workspaceId 
         * @param {string} ftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleReplicateWebhook: async (workspaceId: string, ftId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('handleReplicateWebhook', 'workspaceId', workspaceId)
            // verify required parameter 'ftId' is not null or undefined
            assertParamExists('handleReplicateWebhook', 'ftId', ftId)
            const localVarPath = `/v2/photo_ai/webhooks/replicate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (ftId !== undefined) {
                localVarQueryParameter['ft_id'] = ftId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Image Fts
         * @param {string} workspaceId 
         * @param {ImageFTSearchRequest} imageFTSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchImageFts: async (workspaceId: string, imageFTSearchRequest: ImageFTSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchImageFts', 'workspaceId', workspaceId)
            // verify required parameter 'imageFTSearchRequest' is not null or undefined
            assertParamExists('searchImageFts', 'imageFTSearchRequest', imageFTSearchRequest)
            const localVarPath = `/v2/photo_ai/images/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageFTSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Inference History
         * @param {string} workspaceId 
         * @param {InferenceHistorySearchRequest} inferenceHistorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInferenceHistory: async (workspaceId: string, inferenceHistorySearchRequest: InferenceHistorySearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchInferenceHistory', 'workspaceId', workspaceId)
            // verify required parameter 'inferenceHistorySearchRequest' is not null or undefined
            assertParamExists('searchInferenceHistory', 'inferenceHistorySearchRequest', inferenceHistorySearchRequest)
            const localVarPath = `/v2/photo_ai/inference/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inferenceHistorySearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Image Ft
         * @param {string} ftId 
         * @param {string} workspaceId 
         * @param {ImageFTUpdateRequest} imageFTUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImageFt: async (ftId: string, workspaceId: string, imageFTUpdateRequest: ImageFTUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ftId' is not null or undefined
            assertParamExists('updateImageFt', 'ftId', ftId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateImageFt', 'workspaceId', workspaceId)
            // verify required parameter 'imageFTUpdateRequest' is not null or undefined
            assertParamExists('updateImageFt', 'imageFTUpdateRequest', imageFTUpdateRequest)
            const localVarPath = `/v2/photo_ai/images/{ft_id}`
                .replace(`{${"ft_id"}}`, encodeURIComponent(String(ftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageFTUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Image Ft
         * @param {FTType} ftType 
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImageFt: async (ftType: FTType, workspaceId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ftType' is not null or undefined
            assertParamExists('uploadImageFt', 'ftType', ftType)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('uploadImageFt', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadImageFt', 'file', file)
            const localVarPath = `/v2/photo_ai/files/{ft_type}/upload`
                .replace(`{${"ft_type"}}`, encodeURIComponent(String(ftType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FineTuningsApi - functional programming interface
 * @export
 */
export const FineTuningsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FineTuningsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Image Ft
         * @param {string} workspaceId 
         * @param {ImageFTCreateRequest} imageFTCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImageFt(workspaceId: string, imageFTCreateRequest: ImageFTCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageFTResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImageFt(workspaceId, imageFTCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.createImageFt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete File Ft
         * @param {string} fileKey 
         * @param {string} workspaceId 
         * @param {InferenceFileType} fileType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileFt(fileKey: string, workspaceId: string, fileType: InferenceFileType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileFt(fileKey, workspaceId, fileType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.deleteFileFt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Image Ft
         * @param {string} ftId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteImageFt(ftId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImageFt(ftId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.deleteImageFt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate Image Prompt
         * @param {string} workspaceId 
         * @param {ImagePromptGenerationRequest} imagePromptGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateImagePrompt(workspaceId: string, imagePromptGenerationRequest: ImagePromptGenerationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImagePromptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateImagePrompt(workspaceId, imagePromptGenerationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.generateImagePrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate Images
         * @param {string} workspaceId 
         * @param {ImageInferenceRequest} imageInferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateImages(workspaceId: string, imageInferenceRequest: ImageInferenceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageInferenceScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateImages(workspaceId, imageInferenceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.generateImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get File Ft
         * @param {string} fileKey 
         * @param {string} workspaceId 
         * @param {InferenceFileType} fileType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileFt(fileKey: string, workspaceId: string, fileType: InferenceFileType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileFt(fileKey, workspaceId, fileType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.getFileFt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Inference Results
         * @param {string} inferenceId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInferenceResults(inferenceId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageInferenceResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInferenceResults(inferenceId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.getInferenceResults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Handle Replicate Webhook
         * @param {string} workspaceId 
         * @param {string} ftId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleReplicateWebhook(workspaceId: string, ftId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleReplicateWebhook(workspaceId, ftId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.handleReplicateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Image Fts
         * @param {string} workspaceId 
         * @param {ImageFTSearchRequest} imageFTSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchImageFts(workspaceId: string, imageFTSearchRequest: ImageFTSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageFTResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchImageFts(workspaceId, imageFTSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.searchImageFts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Inference History
         * @param {string} workspaceId 
         * @param {InferenceHistorySearchRequest} inferenceHistorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInferenceHistory(workspaceId: string, inferenceHistorySearchRequest: InferenceHistorySearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageInferenceScrollResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInferenceHistory(workspaceId, inferenceHistorySearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.searchInferenceHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Image Ft
         * @param {string} ftId 
         * @param {string} workspaceId 
         * @param {ImageFTUpdateRequest} imageFTUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateImageFt(ftId: string, workspaceId: string, imageFTUpdateRequest: ImageFTUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageFTResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateImageFt(ftId, workspaceId, imageFTUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.updateImageFt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Image Ft
         * @param {FTType} ftType 
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadImageFt(ftType: FTType, workspaceId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadImageFt(ftType, workspaceId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningsApi.uploadImageFt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FineTuningsApi - factory interface
 * @export
 */
export const FineTuningsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FineTuningsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Image Ft
         * @param {FineTuningsApiCreateImageFtRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageFt(requestParameters: FineTuningsApiCreateImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageFTResponse> {
            return localVarFp.createImageFt(requestParameters.workspaceId, requestParameters.imageFTCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete File Ft
         * @param {FineTuningsApiDeleteFileFtRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileFt(requestParameters: FineTuningsApiDeleteFileFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteFileFt(requestParameters.fileKey, requestParameters.workspaceId, requestParameters.fileType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Image Ft
         * @param {FineTuningsApiDeleteImageFtRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImageFt(requestParameters: FineTuningsApiDeleteImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteImageFt(requestParameters.ftId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate Image Prompt
         * @param {FineTuningsApiGenerateImagePromptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateImagePrompt(requestParameters: FineTuningsApiGenerateImagePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImagePromptResponse> {
            return localVarFp.generateImagePrompt(requestParameters.workspaceId, requestParameters.imagePromptGenerationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate Images
         * @param {FineTuningsApiGenerateImagesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateImages(requestParameters: FineTuningsApiGenerateImagesRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageInferenceScheduleResponse> {
            return localVarFp.generateImages(requestParameters.workspaceId, requestParameters.imageInferenceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get File Ft
         * @param {FineTuningsApiGetFileFtRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileFt(requestParameters: FineTuningsApiGetFileFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getFileFt(requestParameters.fileKey, requestParameters.workspaceId, requestParameters.fileType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Inference Results
         * @param {FineTuningsApiGetInferenceResultsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInferenceResults(requestParameters: FineTuningsApiGetInferenceResultsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageInferenceResultResponse> {
            return localVarFp.getInferenceResults(requestParameters.inferenceId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Handle Replicate Webhook
         * @param {FineTuningsApiHandleReplicateWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleReplicateWebhook(requestParameters: FineTuningsApiHandleReplicateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.handleReplicateWebhook(requestParameters.workspaceId, requestParameters.ftId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Image Fts
         * @param {FineTuningsApiSearchImageFtsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchImageFts(requestParameters: FineTuningsApiSearchImageFtsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ImageFTResponse>> {
            return localVarFp.searchImageFts(requestParameters.workspaceId, requestParameters.imageFTSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Inference History
         * @param {FineTuningsApiSearchInferenceHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInferenceHistory(requestParameters: FineTuningsApiSearchInferenceHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageInferenceScrollResponse> {
            return localVarFp.searchInferenceHistory(requestParameters.workspaceId, requestParameters.inferenceHistorySearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Image Ft
         * @param {FineTuningsApiUpdateImageFtRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImageFt(requestParameters: FineTuningsApiUpdateImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageFTResponse> {
            return localVarFp.updateImageFt(requestParameters.ftId, requestParameters.workspaceId, requestParameters.imageFTUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Image Ft
         * @param {FineTuningsApiUploadImageFtRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImageFt(requestParameters: FineTuningsApiUploadImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadResponse> {
            return localVarFp.uploadImageFt(requestParameters.ftType, requestParameters.workspaceId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FineTuningsApi - interface
 * @export
 * @interface FineTuningsApi
 */
export interface FineTuningsApiInterface {
    /**
     * 
     * @summary Create Image Ft
     * @param {FineTuningsApiCreateImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    createImageFt(requestParameters: FineTuningsApiCreateImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageFTResponse>;

    /**
     * 
     * @summary Delete File Ft
     * @param {FineTuningsApiDeleteFileFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    deleteFileFt(requestParameters: FineTuningsApiDeleteFileFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Delete Image Ft
     * @param {FineTuningsApiDeleteImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    deleteImageFt(requestParameters: FineTuningsApiDeleteImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Generate Image Prompt
     * @param {FineTuningsApiGenerateImagePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    generateImagePrompt(requestParameters: FineTuningsApiGenerateImagePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImagePromptResponse>;

    /**
     * 
     * @summary Generate Images
     * @param {FineTuningsApiGenerateImagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    generateImages(requestParameters: FineTuningsApiGenerateImagesRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageInferenceScheduleResponse>;

    /**
     * 
     * @summary Get File Ft
     * @param {FineTuningsApiGetFileFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    getFileFt(requestParameters: FineTuningsApiGetFileFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Inference Results
     * @param {FineTuningsApiGetInferenceResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    getInferenceResults(requestParameters: FineTuningsApiGetInferenceResultsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageInferenceResultResponse>;

    /**
     * 
     * @summary Handle Replicate Webhook
     * @param {FineTuningsApiHandleReplicateWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    handleReplicateWebhook(requestParameters: FineTuningsApiHandleReplicateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Search Image Fts
     * @param {FineTuningsApiSearchImageFtsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    searchImageFts(requestParameters: FineTuningsApiSearchImageFtsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ImageFTResponse>>;

    /**
     * 
     * @summary Search Inference History
     * @param {FineTuningsApiSearchInferenceHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    searchInferenceHistory(requestParameters: FineTuningsApiSearchInferenceHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageInferenceScrollResponse>;

    /**
     * 
     * @summary Update Image Ft
     * @param {FineTuningsApiUpdateImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    updateImageFt(requestParameters: FineTuningsApiUpdateImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImageFTResponse>;

    /**
     * 
     * @summary Upload Image Ft
     * @param {FineTuningsApiUploadImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApiInterface
     */
    uploadImageFt(requestParameters: FineTuningsApiUploadImageFtRequest, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadResponse>;

}

/**
 * Request parameters for createImageFt operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiCreateImageFtRequest
 */
export interface FineTuningsApiCreateImageFtRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiCreateImageFt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ImageFTCreateRequest}
     * @memberof FineTuningsApiCreateImageFt
     */
    readonly imageFTCreateRequest: ImageFTCreateRequest
}

/**
 * Request parameters for deleteFileFt operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiDeleteFileFtRequest
 */
export interface FineTuningsApiDeleteFileFtRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiDeleteFileFt
     */
    readonly fileKey: string

    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiDeleteFileFt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {InferenceFileType}
     * @memberof FineTuningsApiDeleteFileFt
     */
    readonly fileType: InferenceFileType
}

/**
 * Request parameters for deleteImageFt operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiDeleteImageFtRequest
 */
export interface FineTuningsApiDeleteImageFtRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiDeleteImageFt
     */
    readonly ftId: string

    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiDeleteImageFt
     */
    readonly workspaceId: string
}

/**
 * Request parameters for generateImagePrompt operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiGenerateImagePromptRequest
 */
export interface FineTuningsApiGenerateImagePromptRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiGenerateImagePrompt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ImagePromptGenerationRequest}
     * @memberof FineTuningsApiGenerateImagePrompt
     */
    readonly imagePromptGenerationRequest: ImagePromptGenerationRequest
}

/**
 * Request parameters for generateImages operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiGenerateImagesRequest
 */
export interface FineTuningsApiGenerateImagesRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiGenerateImages
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ImageInferenceRequest}
     * @memberof FineTuningsApiGenerateImages
     */
    readonly imageInferenceRequest: ImageInferenceRequest
}

/**
 * Request parameters for getFileFt operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiGetFileFtRequest
 */
export interface FineTuningsApiGetFileFtRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiGetFileFt
     */
    readonly fileKey: string

    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiGetFileFt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {InferenceFileType}
     * @memberof FineTuningsApiGetFileFt
     */
    readonly fileType: InferenceFileType
}

/**
 * Request parameters for getInferenceResults operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiGetInferenceResultsRequest
 */
export interface FineTuningsApiGetInferenceResultsRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiGetInferenceResults
     */
    readonly inferenceId: string

    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiGetInferenceResults
     */
    readonly workspaceId: string
}

/**
 * Request parameters for handleReplicateWebhook operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiHandleReplicateWebhookRequest
 */
export interface FineTuningsApiHandleReplicateWebhookRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiHandleReplicateWebhook
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiHandleReplicateWebhook
     */
    readonly ftId: string
}

/**
 * Request parameters for searchImageFts operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiSearchImageFtsRequest
 */
export interface FineTuningsApiSearchImageFtsRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiSearchImageFts
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ImageFTSearchRequest}
     * @memberof FineTuningsApiSearchImageFts
     */
    readonly imageFTSearchRequest: ImageFTSearchRequest
}

/**
 * Request parameters for searchInferenceHistory operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiSearchInferenceHistoryRequest
 */
export interface FineTuningsApiSearchInferenceHistoryRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiSearchInferenceHistory
     */
    readonly workspaceId: string

    /**
     * 
     * @type {InferenceHistorySearchRequest}
     * @memberof FineTuningsApiSearchInferenceHistory
     */
    readonly inferenceHistorySearchRequest: InferenceHistorySearchRequest
}

/**
 * Request parameters for updateImageFt operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiUpdateImageFtRequest
 */
export interface FineTuningsApiUpdateImageFtRequest {
    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiUpdateImageFt
     */
    readonly ftId: string

    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiUpdateImageFt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ImageFTUpdateRequest}
     * @memberof FineTuningsApiUpdateImageFt
     */
    readonly imageFTUpdateRequest: ImageFTUpdateRequest
}

/**
 * Request parameters for uploadImageFt operation in FineTuningsApi.
 * @export
 * @interface FineTuningsApiUploadImageFtRequest
 */
export interface FineTuningsApiUploadImageFtRequest {
    /**
     * 
     * @type {FTType}
     * @memberof FineTuningsApiUploadImageFt
     */
    readonly ftType: FTType

    /**
     * 
     * @type {string}
     * @memberof FineTuningsApiUploadImageFt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {File}
     * @memberof FineTuningsApiUploadImageFt
     */
    readonly file: File
}

/**
 * FineTuningsApi - object-oriented interface
 * @export
 * @class FineTuningsApi
 * @extends {BaseAPI}
 */
export class FineTuningsApi extends BaseAPI implements FineTuningsApiInterface {
    /**
     * 
     * @summary Create Image Ft
     * @param {FineTuningsApiCreateImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public createImageFt(requestParameters: FineTuningsApiCreateImageFtRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).createImageFt(requestParameters.workspaceId, requestParameters.imageFTCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete File Ft
     * @param {FineTuningsApiDeleteFileFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public deleteFileFt(requestParameters: FineTuningsApiDeleteFileFtRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).deleteFileFt(requestParameters.fileKey, requestParameters.workspaceId, requestParameters.fileType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Image Ft
     * @param {FineTuningsApiDeleteImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public deleteImageFt(requestParameters: FineTuningsApiDeleteImageFtRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).deleteImageFt(requestParameters.ftId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate Image Prompt
     * @param {FineTuningsApiGenerateImagePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public generateImagePrompt(requestParameters: FineTuningsApiGenerateImagePromptRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).generateImagePrompt(requestParameters.workspaceId, requestParameters.imagePromptGenerationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate Images
     * @param {FineTuningsApiGenerateImagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public generateImages(requestParameters: FineTuningsApiGenerateImagesRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).generateImages(requestParameters.workspaceId, requestParameters.imageInferenceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get File Ft
     * @param {FineTuningsApiGetFileFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public getFileFt(requestParameters: FineTuningsApiGetFileFtRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).getFileFt(requestParameters.fileKey, requestParameters.workspaceId, requestParameters.fileType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Inference Results
     * @param {FineTuningsApiGetInferenceResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public getInferenceResults(requestParameters: FineTuningsApiGetInferenceResultsRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).getInferenceResults(requestParameters.inferenceId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Handle Replicate Webhook
     * @param {FineTuningsApiHandleReplicateWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public handleReplicateWebhook(requestParameters: FineTuningsApiHandleReplicateWebhookRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).handleReplicateWebhook(requestParameters.workspaceId, requestParameters.ftId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Image Fts
     * @param {FineTuningsApiSearchImageFtsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public searchImageFts(requestParameters: FineTuningsApiSearchImageFtsRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).searchImageFts(requestParameters.workspaceId, requestParameters.imageFTSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Inference History
     * @param {FineTuningsApiSearchInferenceHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public searchInferenceHistory(requestParameters: FineTuningsApiSearchInferenceHistoryRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).searchInferenceHistory(requestParameters.workspaceId, requestParameters.inferenceHistorySearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Image Ft
     * @param {FineTuningsApiUpdateImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public updateImageFt(requestParameters: FineTuningsApiUpdateImageFtRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).updateImageFt(requestParameters.ftId, requestParameters.workspaceId, requestParameters.imageFTUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Image Ft
     * @param {FineTuningsApiUploadImageFtRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FineTuningsApi
     */
    public uploadImageFt(requestParameters: FineTuningsApiUploadImageFtRequest, options?: RawAxiosRequestConfig) {
        return FineTuningsApiFp(this.configuration).uploadImageFt(requestParameters.ftType, requestParameters.workspaceId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FlowAssistantApi - axios parameter creator
 * @export
 */
export const FlowAssistantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply Flow Assistant Changes
         * @param {string} workspaceId 
         * @param {FlowAssistantApplyRejectChangesRequest} flowAssistantApplyRejectChangesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyFlowAssistantChanges: async (workspaceId: string, flowAssistantApplyRejectChangesRequest: FlowAssistantApplyRejectChangesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('applyFlowAssistantChanges', 'workspaceId', workspaceId)
            // verify required parameter 'flowAssistantApplyRejectChangesRequest' is not null or undefined
            assertParamExists('applyFlowAssistantChanges', 'flowAssistantApplyRejectChangesRequest', flowAssistantApplyRejectChangesRequest)
            const localVarPath = `/v2/flow_assistants/apply_changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowAssistantApplyRejectChangesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Flow Assistant Session
         * @param {string} workspaceId 
         * @param {FlowAssistantSessionCreateRequest} flowAssistantSessionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowAssistantSession: async (workspaceId: string, flowAssistantSessionCreateRequest: FlowAssistantSessionCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createFlowAssistantSession', 'workspaceId', workspaceId)
            // verify required parameter 'flowAssistantSessionCreateRequest' is not null or undefined
            assertParamExists('createFlowAssistantSession', 'flowAssistantSessionCreateRequest', flowAssistantSessionCreateRequest)
            const localVarPath = `/v2/flow_assistants/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowAssistantSessionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke Flow Assistant Response
         * @param {string} sessionId 
         * @param {FlowAssistantInvokeRequest} flowAssistantInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlowAssistantResponse: async (sessionId: string, flowAssistantInvokeRequest: FlowAssistantInvokeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('invokeFlowAssistantResponse', 'sessionId', sessionId)
            // verify required parameter 'flowAssistantInvokeRequest' is not null or undefined
            assertParamExists('invokeFlowAssistantResponse', 'flowAssistantInvokeRequest', flowAssistantInvokeRequest)
            const localVarPath = `/v2/flow_assistants/{session_id}/invoke`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowAssistantInvokeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Poll Flow Assistant Response
         * @param {string} sessionId 
         * @param {string} fromTimestamp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollFlowAssistantResponse: async (sessionId: string, fromTimestamp: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('pollFlowAssistantResponse', 'sessionId', sessionId)
            // verify required parameter 'fromTimestamp' is not null or undefined
            assertParamExists('pollFlowAssistantResponse', 'fromTimestamp', fromTimestamp)
            const localVarPath = `/v2/flow_assistants/{session_id}/invocation_response/{from_timestamp}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"from_timestamp"}}`, encodeURIComponent(String(fromTimestamp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reject Flow Assistant Changes
         * @param {string} workspaceId 
         * @param {FlowAssistantApplyRejectChangesRequest} flowAssistantApplyRejectChangesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectFlowAssistantChanges: async (workspaceId: string, flowAssistantApplyRejectChangesRequest: FlowAssistantApplyRejectChangesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('rejectFlowAssistantChanges', 'workspaceId', workspaceId)
            // verify required parameter 'flowAssistantApplyRejectChangesRequest' is not null or undefined
            assertParamExists('rejectFlowAssistantChanges', 'flowAssistantApplyRejectChangesRequest', flowAssistantApplyRejectChangesRequest)
            const localVarPath = `/v2/flow_assistants/reject_changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowAssistantApplyRejectChangesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlowAssistantApi - functional programming interface
 * @export
 */
export const FlowAssistantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlowAssistantApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Apply Flow Assistant Changes
         * @param {string} workspaceId 
         * @param {FlowAssistantApplyRejectChangesRequest} flowAssistantApplyRejectChangesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyFlowAssistantChanges(workspaceId: string, flowAssistantApplyRejectChangesRequest: FlowAssistantApplyRejectChangesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.applyFlowAssistantChanges(workspaceId, flowAssistantApplyRejectChangesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowAssistantApi.applyFlowAssistantChanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Flow Assistant Session
         * @param {string} workspaceId 
         * @param {FlowAssistantSessionCreateRequest} flowAssistantSessionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFlowAssistantSession(workspaceId: string, flowAssistantSessionCreateRequest: FlowAssistantSessionCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFlowAssistantSession(workspaceId, flowAssistantSessionCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowAssistantApi.createFlowAssistantSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke Flow Assistant Response
         * @param {string} sessionId 
         * @param {FlowAssistantInvokeRequest} flowAssistantInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invokeFlowAssistantResponse(sessionId: string, flowAssistantInvokeRequest: FlowAssistantInvokeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionInvocationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invokeFlowAssistantResponse(sessionId, flowAssistantInvokeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowAssistantApi.invokeFlowAssistantResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Poll Flow Assistant Response
         * @param {string} sessionId 
         * @param {string} fromTimestamp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pollFlowAssistantResponse(sessionId: string, fromTimestamp: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowSessionEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pollFlowAssistantResponse(sessionId, fromTimestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowAssistantApi.pollFlowAssistantResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reject Flow Assistant Changes
         * @param {string} workspaceId 
         * @param {FlowAssistantApplyRejectChangesRequest} flowAssistantApplyRejectChangesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectFlowAssistantChanges(workspaceId: string, flowAssistantApplyRejectChangesRequest: FlowAssistantApplyRejectChangesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectFlowAssistantChanges(workspaceId, flowAssistantApplyRejectChangesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowAssistantApi.rejectFlowAssistantChanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FlowAssistantApi - factory interface
 * @export
 */
export const FlowAssistantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlowAssistantApiFp(configuration)
    return {
        /**
         * 
         * @summary Apply Flow Assistant Changes
         * @param {FlowAssistantApiApplyFlowAssistantChangesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyFlowAssistantChanges(requestParameters: FlowAssistantApiApplyFlowAssistantChangesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse> {
            return localVarFp.applyFlowAssistantChanges(requestParameters.workspaceId, requestParameters.flowAssistantApplyRejectChangesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Flow Assistant Session
         * @param {FlowAssistantApiCreateFlowAssistantSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowAssistantSession(requestParameters: FlowAssistantApiCreateFlowAssistantSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionResponse> {
            return localVarFp.createFlowAssistantSession(requestParameters.workspaceId, requestParameters.flowAssistantSessionCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke Flow Assistant Response
         * @param {FlowAssistantApiInvokeFlowAssistantResponseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlowAssistantResponse(requestParameters: FlowAssistantApiInvokeFlowAssistantResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse> {
            return localVarFp.invokeFlowAssistantResponse(requestParameters.sessionId, requestParameters.flowAssistantInvokeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Poll Flow Assistant Response
         * @param {FlowAssistantApiPollFlowAssistantResponseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollFlowAssistantResponse(requestParameters: FlowAssistantApiPollFlowAssistantResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionEvent>> {
            return localVarFp.pollFlowAssistantResponse(requestParameters.sessionId, requestParameters.fromTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reject Flow Assistant Changes
         * @param {FlowAssistantApiRejectFlowAssistantChangesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectFlowAssistantChanges(requestParameters: FlowAssistantApiRejectFlowAssistantChangesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse> {
            return localVarFp.rejectFlowAssistantChanges(requestParameters.workspaceId, requestParameters.flowAssistantApplyRejectChangesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlowAssistantApi - interface
 * @export
 * @interface FlowAssistantApi
 */
export interface FlowAssistantApiInterface {
    /**
     * 
     * @summary Apply Flow Assistant Changes
     * @param {FlowAssistantApiApplyFlowAssistantChangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApiInterface
     */
    applyFlowAssistantChanges(requestParameters: FlowAssistantApiApplyFlowAssistantChangesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse>;

    /**
     * 
     * @summary Create Flow Assistant Session
     * @param {FlowAssistantApiCreateFlowAssistantSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApiInterface
     */
    createFlowAssistantSession(requestParameters: FlowAssistantApiCreateFlowAssistantSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionResponse>;

    /**
     * 
     * @summary Invoke Flow Assistant Response
     * @param {FlowAssistantApiInvokeFlowAssistantResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApiInterface
     */
    invokeFlowAssistantResponse(requestParameters: FlowAssistantApiInvokeFlowAssistantResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse>;

    /**
     * 
     * @summary Poll Flow Assistant Response
     * @param {FlowAssistantApiPollFlowAssistantResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApiInterface
     */
    pollFlowAssistantResponse(requestParameters: FlowAssistantApiPollFlowAssistantResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionEvent>>;

    /**
     * 
     * @summary Reject Flow Assistant Changes
     * @param {FlowAssistantApiRejectFlowAssistantChangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApiInterface
     */
    rejectFlowAssistantChanges(requestParameters: FlowAssistantApiRejectFlowAssistantChangesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse>;

}

/**
 * Request parameters for applyFlowAssistantChanges operation in FlowAssistantApi.
 * @export
 * @interface FlowAssistantApiApplyFlowAssistantChangesRequest
 */
export interface FlowAssistantApiApplyFlowAssistantChangesRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantApiApplyFlowAssistantChanges
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowAssistantApplyRejectChangesRequest}
     * @memberof FlowAssistantApiApplyFlowAssistantChanges
     */
    readonly flowAssistantApplyRejectChangesRequest: FlowAssistantApplyRejectChangesRequest
}

/**
 * Request parameters for createFlowAssistantSession operation in FlowAssistantApi.
 * @export
 * @interface FlowAssistantApiCreateFlowAssistantSessionRequest
 */
export interface FlowAssistantApiCreateFlowAssistantSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantApiCreateFlowAssistantSession
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowAssistantSessionCreateRequest}
     * @memberof FlowAssistantApiCreateFlowAssistantSession
     */
    readonly flowAssistantSessionCreateRequest: FlowAssistantSessionCreateRequest
}

/**
 * Request parameters for invokeFlowAssistantResponse operation in FlowAssistantApi.
 * @export
 * @interface FlowAssistantApiInvokeFlowAssistantResponseRequest
 */
export interface FlowAssistantApiInvokeFlowAssistantResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantApiInvokeFlowAssistantResponse
     */
    readonly sessionId: string

    /**
     * 
     * @type {FlowAssistantInvokeRequest}
     * @memberof FlowAssistantApiInvokeFlowAssistantResponse
     */
    readonly flowAssistantInvokeRequest: FlowAssistantInvokeRequest
}

/**
 * Request parameters for pollFlowAssistantResponse operation in FlowAssistantApi.
 * @export
 * @interface FlowAssistantApiPollFlowAssistantResponseRequest
 */
export interface FlowAssistantApiPollFlowAssistantResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantApiPollFlowAssistantResponse
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof FlowAssistantApiPollFlowAssistantResponse
     */
    readonly fromTimestamp: string
}

/**
 * Request parameters for rejectFlowAssistantChanges operation in FlowAssistantApi.
 * @export
 * @interface FlowAssistantApiRejectFlowAssistantChangesRequest
 */
export interface FlowAssistantApiRejectFlowAssistantChangesRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowAssistantApiRejectFlowAssistantChanges
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowAssistantApplyRejectChangesRequest}
     * @memberof FlowAssistantApiRejectFlowAssistantChanges
     */
    readonly flowAssistantApplyRejectChangesRequest: FlowAssistantApplyRejectChangesRequest
}

/**
 * FlowAssistantApi - object-oriented interface
 * @export
 * @class FlowAssistantApi
 * @extends {BaseAPI}
 */
export class FlowAssistantApi extends BaseAPI implements FlowAssistantApiInterface {
    /**
     * 
     * @summary Apply Flow Assistant Changes
     * @param {FlowAssistantApiApplyFlowAssistantChangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApi
     */
    public applyFlowAssistantChanges(requestParameters: FlowAssistantApiApplyFlowAssistantChangesRequest, options?: RawAxiosRequestConfig) {
        return FlowAssistantApiFp(this.configuration).applyFlowAssistantChanges(requestParameters.workspaceId, requestParameters.flowAssistantApplyRejectChangesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Flow Assistant Session
     * @param {FlowAssistantApiCreateFlowAssistantSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApi
     */
    public createFlowAssistantSession(requestParameters: FlowAssistantApiCreateFlowAssistantSessionRequest, options?: RawAxiosRequestConfig) {
        return FlowAssistantApiFp(this.configuration).createFlowAssistantSession(requestParameters.workspaceId, requestParameters.flowAssistantSessionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke Flow Assistant Response
     * @param {FlowAssistantApiInvokeFlowAssistantResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApi
     */
    public invokeFlowAssistantResponse(requestParameters: FlowAssistantApiInvokeFlowAssistantResponseRequest, options?: RawAxiosRequestConfig) {
        return FlowAssistantApiFp(this.configuration).invokeFlowAssistantResponse(requestParameters.sessionId, requestParameters.flowAssistantInvokeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Poll Flow Assistant Response
     * @param {FlowAssistantApiPollFlowAssistantResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApi
     */
    public pollFlowAssistantResponse(requestParameters: FlowAssistantApiPollFlowAssistantResponseRequest, options?: RawAxiosRequestConfig) {
        return FlowAssistantApiFp(this.configuration).pollFlowAssistantResponse(requestParameters.sessionId, requestParameters.fromTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reject Flow Assistant Changes
     * @param {FlowAssistantApiRejectFlowAssistantChangesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowAssistantApi
     */
    public rejectFlowAssistantChanges(requestParameters: FlowAssistantApiRejectFlowAssistantChangesRequest, options?: RawAxiosRequestConfig) {
        return FlowAssistantApiFp(this.configuration).rejectFlowAssistantChanges(requestParameters.workspaceId, requestParameters.flowAssistantApplyRejectChangesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FlowMessagesApi - axios parameter creator
 * @export
 */
export const FlowMessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Search Flow Messages
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlowMessages: async (sessionId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('searchFlowMessages', 'sessionId', sessionId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchFlowMessages', 'workspaceId', workspaceId)
            const localVarPath = `/v2/chatbots/search/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlowMessagesApi - functional programming interface
 * @export
 */
export const FlowMessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlowMessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Search Flow Messages
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchFlowMessages(sessionId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowSessionEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFlowMessages(sessionId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowMessagesApi.searchFlowMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FlowMessagesApi - factory interface
 * @export
 */
export const FlowMessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlowMessagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Search Flow Messages
         * @param {FlowMessagesApiSearchFlowMessagesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlowMessages(requestParameters: FlowMessagesApiSearchFlowMessagesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionEvent>> {
            return localVarFp.searchFlowMessages(requestParameters.sessionId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlowMessagesApi - interface
 * @export
 * @interface FlowMessagesApi
 */
export interface FlowMessagesApiInterface {
    /**
     * 
     * @summary Search Flow Messages
     * @param {FlowMessagesApiSearchFlowMessagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowMessagesApiInterface
     */
    searchFlowMessages(requestParameters: FlowMessagesApiSearchFlowMessagesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionEvent>>;

}

/**
 * Request parameters for searchFlowMessages operation in FlowMessagesApi.
 * @export
 * @interface FlowMessagesApiSearchFlowMessagesRequest
 */
export interface FlowMessagesApiSearchFlowMessagesRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowMessagesApiSearchFlowMessages
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof FlowMessagesApiSearchFlowMessages
     */
    readonly workspaceId: string
}

/**
 * FlowMessagesApi - object-oriented interface
 * @export
 * @class FlowMessagesApi
 * @extends {BaseAPI}
 */
export class FlowMessagesApi extends BaseAPI implements FlowMessagesApiInterface {
    /**
     * 
     * @summary Search Flow Messages
     * @param {FlowMessagesApiSearchFlowMessagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowMessagesApi
     */
    public searchFlowMessages(requestParameters: FlowMessagesApiSearchFlowMessagesRequest, options?: RawAxiosRequestConfig) {
        return FlowMessagesApiFp(this.configuration).searchFlowMessages(requestParameters.sessionId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FlowSessionsApi - axios parameter creator
 * @export
 */
export const FlowSessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Chatbot Session View
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChatbotSessionView: async (sessionId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deleteChatbotSessionView', 'sessionId', sessionId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteChatbotSessionView', 'workspaceId', workspaceId)
            const localVarPath = `/v2/chatbots/sessions/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Chart Feedback
         * @param {string} workspaceId 
         * @param {ChartsFeedbackRequest} chartsFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartFeedback: async (workspaceId: string, chartsFeedbackRequest: ChartsFeedbackRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getChartFeedback', 'workspaceId', workspaceId)
            // verify required parameter 'chartsFeedbackRequest' is not null or undefined
            assertParamExists('getChartFeedback', 'chartsFeedbackRequest', chartsFeedbackRequest)
            const localVarPath = `/v2/chatbots/sessions/charts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chartsFeedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Chart Session Duration
         * @param {string} workspaceId 
         * @param {ChartsFeedbackRequest} chartsFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartSessionDuration: async (workspaceId: string, chartsFeedbackRequest: ChartsFeedbackRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getChartSessionDuration', 'workspaceId', workspaceId)
            // verify required parameter 'chartsFeedbackRequest' is not null or undefined
            assertParamExists('getChartSessionDuration', 'chartsFeedbackRequest', chartsFeedbackRequest)
            const localVarPath = `/v2/chatbots/sessions/chart_session_duration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chartsFeedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Chatbot Session View
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatbotSessionView: async (sessionId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getChatbotSessionView', 'sessionId', sessionId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getChatbotSessionView', 'workspaceId', workspaceId)
            const localVarPath = `/v2/chatbots/sessions/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Tool Calls Chart Feedback
         * @param {string} workspaceId 
         * @param {ChartsFeedbackRequest} chartsFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolCallsChartFeedback: async (workspaceId: string, chartsFeedbackRequest: ChartsFeedbackRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getToolCallsChartFeedback', 'workspaceId', workspaceId)
            // verify required parameter 'chartsFeedbackRequest' is not null or undefined
            assertParamExists('getToolCallsChartFeedback', 'chartsFeedbackRequest', chartsFeedbackRequest)
            const localVarPath = `/v2/chatbots/sessions/chart_tool_calls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chartsFeedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Chatbot Sessions View
         * @param {string} workspaceId 
         * @param {FlowSessionViewSearchRequest} flowSessionViewSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChatbotSessionsView: async (workspaceId: string, flowSessionViewSearchRequest: FlowSessionViewSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchChatbotSessionsView', 'workspaceId', workspaceId)
            // verify required parameter 'flowSessionViewSearchRequest' is not null or undefined
            assertParamExists('searchChatbotSessionsView', 'flowSessionViewSearchRequest', flowSessionViewSearchRequest)
            const localVarPath = `/v2/chatbots/sessions/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowSessionViewSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Chatbot Session View
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {FlowSessionViewUpdateRequest} flowSessionViewUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatbotSessionView: async (sessionId: string, workspaceId: string, flowSessionViewUpdateRequest: FlowSessionViewUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('updateChatbotSessionView', 'sessionId', sessionId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateChatbotSessionView', 'workspaceId', workspaceId)
            // verify required parameter 'flowSessionViewUpdateRequest' is not null or undefined
            assertParamExists('updateChatbotSessionView', 'flowSessionViewUpdateRequest', flowSessionViewUpdateRequest)
            const localVarPath = `/v2/chatbots/sessions/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowSessionViewUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlowSessionsApi - functional programming interface
 * @export
 */
export const FlowSessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlowSessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Chatbot Session View
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChatbotSessionView(sessionId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChatbotSessionView(sessionId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowSessionsApi.deleteChatbotSessionView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Chart Feedback
         * @param {string} workspaceId 
         * @param {ChartsFeedbackRequest} chartsFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChartFeedback(workspaceId: string, chartsFeedbackRequest: ChartsFeedbackRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedbackChartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChartFeedback(workspaceId, chartsFeedbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowSessionsApi.getChartFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Chart Session Duration
         * @param {string} workspaceId 
         * @param {ChartsFeedbackRequest} chartsFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChartSessionDuration(workspaceId: string, chartsFeedbackRequest: ChartsFeedbackRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartSessionDurationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChartSessionDuration(workspaceId, chartsFeedbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowSessionsApi.getChartSessionDuration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Chatbot Session View
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatbotSessionView(sessionId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionViewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatbotSessionView(sessionId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowSessionsApi.getChatbotSessionView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Tool Calls Chart Feedback
         * @param {string} workspaceId 
         * @param {ChartsFeedbackRequest} chartsFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToolCallsChartFeedback(workspaceId: string, chartsFeedbackRequest: ChartsFeedbackRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ToolCallFeedbackResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToolCallsChartFeedback(workspaceId, chartsFeedbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowSessionsApi.getToolCallsChartFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Chatbot Sessions View
         * @param {string} workspaceId 
         * @param {FlowSessionViewSearchRequest} flowSessionViewSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchChatbotSessionsView(workspaceId: string, flowSessionViewSearchRequest: FlowSessionViewSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowSessionViewResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchChatbotSessionsView(workspaceId, flowSessionViewSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowSessionsApi.searchChatbotSessionsView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Chatbot Session View
         * @param {string} sessionId 
         * @param {string} workspaceId 
         * @param {FlowSessionViewUpdateRequest} flowSessionViewUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChatbotSessionView(sessionId: string, workspaceId: string, flowSessionViewUpdateRequest: FlowSessionViewUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionViewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChatbotSessionView(sessionId, workspaceId, flowSessionViewUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowSessionsApi.updateChatbotSessionView']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FlowSessionsApi - factory interface
 * @export
 */
export const FlowSessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlowSessionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Chatbot Session View
         * @param {FlowSessionsApiDeleteChatbotSessionViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChatbotSessionView(requestParameters: FlowSessionsApiDeleteChatbotSessionViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteChatbotSessionView(requestParameters.sessionId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Chart Feedback
         * @param {FlowSessionsApiGetChartFeedbackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartFeedback(requestParameters: FlowSessionsApiGetChartFeedbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeedbackChartResponse> {
            return localVarFp.getChartFeedback(requestParameters.workspaceId, requestParameters.chartsFeedbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Chart Session Duration
         * @param {FlowSessionsApiGetChartSessionDurationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartSessionDuration(requestParameters: FlowSessionsApiGetChartSessionDurationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChartSessionDurationResponse> {
            return localVarFp.getChartSessionDuration(requestParameters.workspaceId, requestParameters.chartsFeedbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Chatbot Session View
         * @param {FlowSessionsApiGetChatbotSessionViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatbotSessionView(requestParameters: FlowSessionsApiGetChatbotSessionViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionViewResponse> {
            return localVarFp.getChatbotSessionView(requestParameters.sessionId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Tool Calls Chart Feedback
         * @param {FlowSessionsApiGetToolCallsChartFeedbackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolCallsChartFeedback(requestParameters: FlowSessionsApiGetToolCallsChartFeedbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ToolCallFeedbackResponse>> {
            return localVarFp.getToolCallsChartFeedback(requestParameters.workspaceId, requestParameters.chartsFeedbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Chatbot Sessions View
         * @param {FlowSessionsApiSearchChatbotSessionsViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchChatbotSessionsView(requestParameters: FlowSessionsApiSearchChatbotSessionsViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionViewResponse>> {
            return localVarFp.searchChatbotSessionsView(requestParameters.workspaceId, requestParameters.flowSessionViewSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Chatbot Session View
         * @param {FlowSessionsApiUpdateChatbotSessionViewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatbotSessionView(requestParameters: FlowSessionsApiUpdateChatbotSessionViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionViewResponse> {
            return localVarFp.updateChatbotSessionView(requestParameters.sessionId, requestParameters.workspaceId, requestParameters.flowSessionViewUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlowSessionsApi - interface
 * @export
 * @interface FlowSessionsApi
 */
export interface FlowSessionsApiInterface {
    /**
     * 
     * @summary Delete Chatbot Session View
     * @param {FlowSessionsApiDeleteChatbotSessionViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApiInterface
     */
    deleteChatbotSessionView(requestParameters: FlowSessionsApiDeleteChatbotSessionViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Get Chart Feedback
     * @param {FlowSessionsApiGetChartFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApiInterface
     */
    getChartFeedback(requestParameters: FlowSessionsApiGetChartFeedbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeedbackChartResponse>;

    /**
     * 
     * @summary Get Chart Session Duration
     * @param {FlowSessionsApiGetChartSessionDurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApiInterface
     */
    getChartSessionDuration(requestParameters: FlowSessionsApiGetChartSessionDurationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChartSessionDurationResponse>;

    /**
     * 
     * @summary Get Chatbot Session View
     * @param {FlowSessionsApiGetChatbotSessionViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApiInterface
     */
    getChatbotSessionView(requestParameters: FlowSessionsApiGetChatbotSessionViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionViewResponse>;

    /**
     * 
     * @summary Get Tool Calls Chart Feedback
     * @param {FlowSessionsApiGetToolCallsChartFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApiInterface
     */
    getToolCallsChartFeedback(requestParameters: FlowSessionsApiGetToolCallsChartFeedbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ToolCallFeedbackResponse>>;

    /**
     * 
     * @summary Search Chatbot Sessions View
     * @param {FlowSessionsApiSearchChatbotSessionsViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApiInterface
     */
    searchChatbotSessionsView(requestParameters: FlowSessionsApiSearchChatbotSessionsViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionViewResponse>>;

    /**
     * 
     * @summary Update Chatbot Session View
     * @param {FlowSessionsApiUpdateChatbotSessionViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApiInterface
     */
    updateChatbotSessionView(requestParameters: FlowSessionsApiUpdateChatbotSessionViewRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionViewResponse>;

}

/**
 * Request parameters for deleteChatbotSessionView operation in FlowSessionsApi.
 * @export
 * @interface FlowSessionsApiDeleteChatbotSessionViewRequest
 */
export interface FlowSessionsApiDeleteChatbotSessionViewRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiDeleteChatbotSessionView
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiDeleteChatbotSessionView
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getChartFeedback operation in FlowSessionsApi.
 * @export
 * @interface FlowSessionsApiGetChartFeedbackRequest
 */
export interface FlowSessionsApiGetChartFeedbackRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiGetChartFeedback
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ChartsFeedbackRequest}
     * @memberof FlowSessionsApiGetChartFeedback
     */
    readonly chartsFeedbackRequest: ChartsFeedbackRequest
}

/**
 * Request parameters for getChartSessionDuration operation in FlowSessionsApi.
 * @export
 * @interface FlowSessionsApiGetChartSessionDurationRequest
 */
export interface FlowSessionsApiGetChartSessionDurationRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiGetChartSessionDuration
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ChartsFeedbackRequest}
     * @memberof FlowSessionsApiGetChartSessionDuration
     */
    readonly chartsFeedbackRequest: ChartsFeedbackRequest
}

/**
 * Request parameters for getChatbotSessionView operation in FlowSessionsApi.
 * @export
 * @interface FlowSessionsApiGetChatbotSessionViewRequest
 */
export interface FlowSessionsApiGetChatbotSessionViewRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiGetChatbotSessionView
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiGetChatbotSessionView
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getToolCallsChartFeedback operation in FlowSessionsApi.
 * @export
 * @interface FlowSessionsApiGetToolCallsChartFeedbackRequest
 */
export interface FlowSessionsApiGetToolCallsChartFeedbackRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiGetToolCallsChartFeedback
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ChartsFeedbackRequest}
     * @memberof FlowSessionsApiGetToolCallsChartFeedback
     */
    readonly chartsFeedbackRequest: ChartsFeedbackRequest
}

/**
 * Request parameters for searchChatbotSessionsView operation in FlowSessionsApi.
 * @export
 * @interface FlowSessionsApiSearchChatbotSessionsViewRequest
 */
export interface FlowSessionsApiSearchChatbotSessionsViewRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiSearchChatbotSessionsView
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowSessionViewSearchRequest}
     * @memberof FlowSessionsApiSearchChatbotSessionsView
     */
    readonly flowSessionViewSearchRequest: FlowSessionViewSearchRequest
}

/**
 * Request parameters for updateChatbotSessionView operation in FlowSessionsApi.
 * @export
 * @interface FlowSessionsApiUpdateChatbotSessionViewRequest
 */
export interface FlowSessionsApiUpdateChatbotSessionViewRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiUpdateChatbotSessionView
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof FlowSessionsApiUpdateChatbotSessionView
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowSessionViewUpdateRequest}
     * @memberof FlowSessionsApiUpdateChatbotSessionView
     */
    readonly flowSessionViewUpdateRequest: FlowSessionViewUpdateRequest
}

/**
 * FlowSessionsApi - object-oriented interface
 * @export
 * @class FlowSessionsApi
 * @extends {BaseAPI}
 */
export class FlowSessionsApi extends BaseAPI implements FlowSessionsApiInterface {
    /**
     * 
     * @summary Delete Chatbot Session View
     * @param {FlowSessionsApiDeleteChatbotSessionViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApi
     */
    public deleteChatbotSessionView(requestParameters: FlowSessionsApiDeleteChatbotSessionViewRequest, options?: RawAxiosRequestConfig) {
        return FlowSessionsApiFp(this.configuration).deleteChatbotSessionView(requestParameters.sessionId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Chart Feedback
     * @param {FlowSessionsApiGetChartFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApi
     */
    public getChartFeedback(requestParameters: FlowSessionsApiGetChartFeedbackRequest, options?: RawAxiosRequestConfig) {
        return FlowSessionsApiFp(this.configuration).getChartFeedback(requestParameters.workspaceId, requestParameters.chartsFeedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Chart Session Duration
     * @param {FlowSessionsApiGetChartSessionDurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApi
     */
    public getChartSessionDuration(requestParameters: FlowSessionsApiGetChartSessionDurationRequest, options?: RawAxiosRequestConfig) {
        return FlowSessionsApiFp(this.configuration).getChartSessionDuration(requestParameters.workspaceId, requestParameters.chartsFeedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Chatbot Session View
     * @param {FlowSessionsApiGetChatbotSessionViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApi
     */
    public getChatbotSessionView(requestParameters: FlowSessionsApiGetChatbotSessionViewRequest, options?: RawAxiosRequestConfig) {
        return FlowSessionsApiFp(this.configuration).getChatbotSessionView(requestParameters.sessionId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Tool Calls Chart Feedback
     * @param {FlowSessionsApiGetToolCallsChartFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApi
     */
    public getToolCallsChartFeedback(requestParameters: FlowSessionsApiGetToolCallsChartFeedbackRequest, options?: RawAxiosRequestConfig) {
        return FlowSessionsApiFp(this.configuration).getToolCallsChartFeedback(requestParameters.workspaceId, requestParameters.chartsFeedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Chatbot Sessions View
     * @param {FlowSessionsApiSearchChatbotSessionsViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApi
     */
    public searchChatbotSessionsView(requestParameters: FlowSessionsApiSearchChatbotSessionsViewRequest, options?: RawAxiosRequestConfig) {
        return FlowSessionsApiFp(this.configuration).searchChatbotSessionsView(requestParameters.workspaceId, requestParameters.flowSessionViewSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Chatbot Session View
     * @param {FlowSessionsApiUpdateChatbotSessionViewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowSessionsApi
     */
    public updateChatbotSessionView(requestParameters: FlowSessionsApiUpdateChatbotSessionViewRequest, options?: RawAxiosRequestConfig) {
        return FlowSessionsApiFp(this.configuration).updateChatbotSessionView(requestParameters.sessionId, requestParameters.workspaceId, requestParameters.flowSessionViewUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FlowWebhooksApi - axios parameter creator
 * @export
 */
export const FlowWebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Execute Third Party Webhook
         * @param {TriggerType} triggerType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeThirdPartyWebhook: async (triggerType: TriggerType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'triggerType' is not null or undefined
            assertParamExists('executeThirdPartyWebhook', 'triggerType', triggerType)
            const localVarPath = `/v2/flows/webhooks/third_party_integrations/{trigger_type}`
                .replace(`{${"trigger_type"}}`, encodeURIComponent(String(triggerType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute Webhook
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {TriggerType} triggerType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWebhook: async (chatbotId: string, workspaceId: string, triggerType: TriggerType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatbotId' is not null or undefined
            assertParamExists('executeWebhook', 'chatbotId', chatbotId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('executeWebhook', 'workspaceId', workspaceId)
            // verify required parameter 'triggerType' is not null or undefined
            assertParamExists('executeWebhook', 'triggerType', triggerType)
            const localVarPath = `/v2/flows/webhooks/{chatbot_id}`
                .replace(`{${"chatbot_id"}}`, encodeURIComponent(String(chatbotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (triggerType !== undefined) {
                localVarQueryParameter['trigger_type'] = triggerType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute Webhook From Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {TriggerType} triggerType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWebhookFromFlow: async (flowId: string, workspaceId: string, triggerType: TriggerType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('executeWebhookFromFlow', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('executeWebhookFromFlow', 'workspaceId', workspaceId)
            // verify required parameter 'triggerType' is not null or undefined
            assertParamExists('executeWebhookFromFlow', 'triggerType', triggerType)
            const localVarPath = `/v2/flows/webhooks/from_flow/{flow_id}`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (triggerType !== undefined) {
                localVarQueryParameter['trigger_type'] = triggerType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlowWebhooksApi - functional programming interface
 * @export
 */
export const FlowWebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlowWebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Execute Third Party Webhook
         * @param {TriggerType} triggerType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeThirdPartyWebhook(triggerType: TriggerType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeThirdPartyWebhook(triggerType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowWebhooksApi.executeThirdPartyWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Execute Webhook
         * @param {string} chatbotId 
         * @param {string} workspaceId 
         * @param {TriggerType} triggerType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeWebhook(chatbotId: string, workspaceId: string, triggerType: TriggerType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionInvocationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeWebhook(chatbotId, workspaceId, triggerType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowWebhooksApi.executeWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Execute Webhook From Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {TriggerType} triggerType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeWebhookFromFlow(flowId: string, workspaceId: string, triggerType: TriggerType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionInvocationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeWebhookFromFlow(flowId, workspaceId, triggerType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowWebhooksApi.executeWebhookFromFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FlowWebhooksApi - factory interface
 * @export
 */
export const FlowWebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlowWebhooksApiFp(configuration)
    return {
        /**
         * 
         * @summary Execute Third Party Webhook
         * @param {FlowWebhooksApiExecuteThirdPartyWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeThirdPartyWebhook(requestParameters: FlowWebhooksApiExecuteThirdPartyWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.executeThirdPartyWebhook(requestParameters.triggerType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute Webhook
         * @param {FlowWebhooksApiExecuteWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWebhook(requestParameters: FlowWebhooksApiExecuteWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse> {
            return localVarFp.executeWebhook(requestParameters.chatbotId, requestParameters.workspaceId, requestParameters.triggerType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute Webhook From Flow
         * @param {FlowWebhooksApiExecuteWebhookFromFlowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeWebhookFromFlow(requestParameters: FlowWebhooksApiExecuteWebhookFromFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse> {
            return localVarFp.executeWebhookFromFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.triggerType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlowWebhooksApi - interface
 * @export
 * @interface FlowWebhooksApi
 */
export interface FlowWebhooksApiInterface {
    /**
     * 
     * @summary Execute Third Party Webhook
     * @param {FlowWebhooksApiExecuteThirdPartyWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowWebhooksApiInterface
     */
    executeThirdPartyWebhook(requestParameters: FlowWebhooksApiExecuteThirdPartyWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Execute Webhook
     * @param {FlowWebhooksApiExecuteWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowWebhooksApiInterface
     */
    executeWebhook(requestParameters: FlowWebhooksApiExecuteWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse>;

    /**
     * 
     * @summary Execute Webhook From Flow
     * @param {FlowWebhooksApiExecuteWebhookFromFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowWebhooksApiInterface
     */
    executeWebhookFromFlow(requestParameters: FlowWebhooksApiExecuteWebhookFromFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse>;

}

/**
 * Request parameters for executeThirdPartyWebhook operation in FlowWebhooksApi.
 * @export
 * @interface FlowWebhooksApiExecuteThirdPartyWebhookRequest
 */
export interface FlowWebhooksApiExecuteThirdPartyWebhookRequest {
    /**
     * 
     * @type {TriggerType}
     * @memberof FlowWebhooksApiExecuteThirdPartyWebhook
     */
    readonly triggerType: TriggerType
}

/**
 * Request parameters for executeWebhook operation in FlowWebhooksApi.
 * @export
 * @interface FlowWebhooksApiExecuteWebhookRequest
 */
export interface FlowWebhooksApiExecuteWebhookRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowWebhooksApiExecuteWebhook
     */
    readonly chatbotId: string

    /**
     * 
     * @type {string}
     * @memberof FlowWebhooksApiExecuteWebhook
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TriggerType}
     * @memberof FlowWebhooksApiExecuteWebhook
     */
    readonly triggerType: TriggerType
}

/**
 * Request parameters for executeWebhookFromFlow operation in FlowWebhooksApi.
 * @export
 * @interface FlowWebhooksApiExecuteWebhookFromFlowRequest
 */
export interface FlowWebhooksApiExecuteWebhookFromFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowWebhooksApiExecuteWebhookFromFlow
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowWebhooksApiExecuteWebhookFromFlow
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TriggerType}
     * @memberof FlowWebhooksApiExecuteWebhookFromFlow
     */
    readonly triggerType: TriggerType
}

/**
 * FlowWebhooksApi - object-oriented interface
 * @export
 * @class FlowWebhooksApi
 * @extends {BaseAPI}
 */
export class FlowWebhooksApi extends BaseAPI implements FlowWebhooksApiInterface {
    /**
     * 
     * @summary Execute Third Party Webhook
     * @param {FlowWebhooksApiExecuteThirdPartyWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowWebhooksApi
     */
    public executeThirdPartyWebhook(requestParameters: FlowWebhooksApiExecuteThirdPartyWebhookRequest, options?: RawAxiosRequestConfig) {
        return FlowWebhooksApiFp(this.configuration).executeThirdPartyWebhook(requestParameters.triggerType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute Webhook
     * @param {FlowWebhooksApiExecuteWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowWebhooksApi
     */
    public executeWebhook(requestParameters: FlowWebhooksApiExecuteWebhookRequest, options?: RawAxiosRequestConfig) {
        return FlowWebhooksApiFp(this.configuration).executeWebhook(requestParameters.chatbotId, requestParameters.workspaceId, requestParameters.triggerType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute Webhook From Flow
     * @param {FlowWebhooksApiExecuteWebhookFromFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowWebhooksApi
     */
    public executeWebhookFromFlow(requestParameters: FlowWebhooksApiExecuteWebhookFromFlowRequest, options?: RawAxiosRequestConfig) {
        return FlowWebhooksApiFp(this.configuration).executeWebhookFromFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.triggerType, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FlowsApi - axios parameter creator
 * @export
 */
export const FlowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Chatbot Session
         * @param {string} workspaceId 
         * @param {FlowSessionCreateRequest} flowSessionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatbotSession: async (workspaceId: string, flowSessionCreateRequest: FlowSessionCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createChatbotSession', 'workspaceId', workspaceId)
            // verify required parameter 'flowSessionCreateRequest' is not null or undefined
            assertParamExists('createChatbotSession', 'flowSessionCreateRequest', flowSessionCreateRequest)
            const localVarPath = `/v2/flows/sessions/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowSessionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Flow
         * @param {string} workspaceId 
         * @param {FlowCreate} flowCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlow: async (workspaceId: string, flowCreate: FlowCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createFlow', 'workspaceId', workspaceId)
            // verify required parameter 'flowCreate' is not null or undefined
            assertParamExists('createFlow', 'flowCreate', flowCreate)
            const localVarPath = `/v2/flows/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Flow Category
         * @param {string} workspaceId 
         * @param {FlowCategoryCreateRequest} flowCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowCategory: async (workspaceId: string, flowCategoryCreateRequest: FlowCategoryCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createFlowCategory', 'workspaceId', workspaceId)
            // verify required parameter 'flowCategoryCreateRequest' is not null or undefined
            assertParamExists('createFlowCategory', 'flowCategoryCreateRequest', flowCategoryCreateRequest)
            const localVarPath = `/v2/flows/categories/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCategoryCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Flow Cron
         * @param {string} workspaceId 
         * @param {FlowCronCreateRequest} flowCronCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowCron: async (workspaceId: string, flowCronCreateRequest: FlowCronCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createFlowCron', 'workspaceId', workspaceId)
            // verify required parameter 'flowCronCreateRequest' is not null or undefined
            assertParamExists('createFlowCron', 'flowCronCreateRequest', flowCronCreateRequest)
            const localVarPath = `/v2/flows/crons/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCronCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Flow Session
         * @param {string} workspaceId 
         * @param {FlowSessionCreateFromFlowRequest} flowSessionCreateFromFlowRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowSession: async (workspaceId: string, flowSessionCreateFromFlowRequest: FlowSessionCreateFromFlowRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createFlowSession', 'workspaceId', workspaceId)
            // verify required parameter 'flowSessionCreateFromFlowRequest' is not null or undefined
            assertParamExists('createFlowSession', 'flowSessionCreateFromFlowRequest', flowSessionCreateFromFlowRequest)
            const localVarPath = `/v2/flows/sessions/from_flow/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowSessionCreateFromFlowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Message Feedback
         * @param {string} sessionId 
         * @param {FlowMessageFeedbackRequest} flowMessageFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageFeedback: async (sessionId: string, flowMessageFeedbackRequest: FlowMessageFeedbackRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('createMessageFeedback', 'sessionId', sessionId)
            // verify required parameter 'flowMessageFeedbackRequest' is not null or undefined
            assertParamExists('createMessageFeedback', 'flowMessageFeedbackRequest', flowMessageFeedbackRequest)
            const localVarPath = `/v2/flows/sessions/{session_id}/feedback`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowMessageFeedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Attachment
         * @param {string} sessionId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment: async (sessionId: string, fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deleteAttachment', 'sessionId', sessionId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('deleteAttachment', 'fileId', fileId)
            const localVarPath = `/v2/flows/sessions/{session_id}/attachments/{file_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlow: async (flowId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('deleteFlow', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteFlow', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/{flow_id}`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Flow Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlowCategory: async (catId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('deleteFlowCategory', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteFlowCategory', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/categories/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Flow Cron
         * @param {string} flowId 
         * @param {string} cronId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlowCron: async (flowId: string, cronId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('deleteFlowCron', 'flowId', flowId)
            // verify required parameter 'cronId' is not null or undefined
            assertParamExists('deleteFlowCron', 'cronId', cronId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteFlowCron', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/crons/{flow_id}/{cron_id}`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)))
                .replace(`{${"cron_id"}}`, encodeURIComponent(String(cronId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute Flow Cron
         * @param {string} cronId 
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeFlowCron: async (cronId: string, flowId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cronId' is not null or undefined
            assertParamExists('executeFlowCron', 'cronId', cronId)
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('executeFlowCron', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('executeFlowCron', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/crons/{flow_id}/{cron_id}/execute`
                .replace(`{${"cron_id"}}`, encodeURIComponent(String(cronId)))
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate Commit Message
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCommitMessage: async (flowId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('generateCommitMessage', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('generateCommitMessage', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/{flow_id}/generate-commit-msg`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {string} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (flowId: string, workspaceId: string, branch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('get', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('get', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/{flow_id}`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllComponents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/flows/components/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Attachments
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getAttachments', 'sessionId', sessionId)
            const localVarPath = `/v2/flows/sessions/{session_id}/attachments`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Flow Versions
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlowVersions: async (flowId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('getFlowVersions', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getFlowVersions', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/{flow_id}/version_history`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Invoked Flow Results
         * @param {string} flowId 
         * @param {string} taskId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvokedFlowResults: async (flowId: string, taskId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('getInvokedFlowResults', 'flowId', flowId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getInvokedFlowResults', 'taskId', taskId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getInvokedFlowResults', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/{flow_id}/{task_id}`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Public Flow
         * @param {string} flowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicFlow: async (flowId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('getPublicFlow', 'flowId', flowId)
            const localVarPath = `/v2/flows/public/{flow_id}`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Trigger Types
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerTypes: async (flowId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('getTriggerTypes', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getTriggerTypes', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/{flow_id}/triggers`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowInvokeRequest} flowInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlow: async (flowId: string, workspaceId: string, flowInvokeRequest: FlowInvokeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('invokeFlow', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('invokeFlow', 'workspaceId', workspaceId)
            // verify required parameter 'flowInvokeRequest' is not null or undefined
            assertParamExists('invokeFlow', 'flowInvokeRequest', flowInvokeRequest)
            const localVarPath = `/v2/flows/{flow_id}/invoke`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowInvokeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke Flow Response
         * @param {string} sessionId 
         * @param {FlowSessionInvokeRequest} flowSessionInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlowResponse: async (sessionId: string, flowSessionInvokeRequest: FlowSessionInvokeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('invokeFlowResponse', 'sessionId', sessionId)
            // verify required parameter 'flowSessionInvokeRequest' is not null or undefined
            assertParamExists('invokeFlowResponse', 'flowSessionInvokeRequest', flowSessionInvokeRequest)
            const localVarPath = `/v2/flows/sessions/{session_id}/invoke`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowSessionInvokeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invoke Flow Singleton
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowInvokeRequest} flowInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlowSingleton: async (flowId: string, workspaceId: string, flowInvokeRequest: FlowInvokeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('invokeFlowSingleton', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('invokeFlowSingleton', 'workspaceId', workspaceId)
            // verify required parameter 'flowInvokeRequest' is not null or undefined
            assertParamExists('invokeFlowSingleton', 'flowInvokeRequest', flowInvokeRequest)
            const localVarPath = `/v2/flows/{flow_id}/invoke_singleton`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowInvokeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Poll Flow Response
         * @param {string} sessionId 
         * @param {string} fromTimestamp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollFlowResponse: async (sessionId: string, fromTimestamp: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('pollFlowResponse', 'sessionId', sessionId)
            // verify required parameter 'fromTimestamp' is not null or undefined
            assertParamExists('pollFlowResponse', 'fromTimestamp', fromTimestamp)
            const localVarPath = `/v2/flows/sessions/{session_id}/invocation_response/{from_timestamp}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"from_timestamp"}}`, encodeURIComponent(String(fromTimestamp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowCommitRequest} flowCommitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishFlow: async (flowId: string, workspaceId: string, flowCommitRequest: FlowCommitRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('publishFlow', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('publishFlow', 'workspaceId', workspaceId)
            // verify required parameter 'flowCommitRequest' is not null or undefined
            assertParamExists('publishFlow', 'flowCommitRequest', flowCommitRequest)
            const localVarPath = `/v2/flows/{flow_id}/publish`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCommitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore Flow Version
         * @param {string} flowId 
         * @param {string} branch 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreFlowVersion: async (flowId: string, branch: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('restoreFlowVersion', 'flowId', flowId)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('restoreFlowVersion', 'branch', branch)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('restoreFlowVersion', 'workspaceId', workspaceId)
            const localVarPath = `/v2/flows/{flow_id}/version_history/{branch}/restore`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search
         * @param {string | null} workspaceId 
         * @param {FlowSearchRequest} flowSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (workspaceId: string | null, flowSearchRequest: FlowSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('search', 'workspaceId', workspaceId)
            // verify required parameter 'flowSearchRequest' is not null or undefined
            assertParamExists('search', 'flowSearchRequest', flowSearchRequest)
            const localVarPath = `/v2/flows/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search All
         * @param {string} workspaceId 
         * @param {AllFlowsSearchRequest} allFlowsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAll: async (workspaceId: string, allFlowsSearchRequest: AllFlowsSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchAll', 'workspaceId', workspaceId)
            // verify required parameter 'allFlowsSearchRequest' is not null or undefined
            assertParamExists('searchAll', 'allFlowsSearchRequest', allFlowsSearchRequest)
            const localVarPath = `/v2/flows/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(allFlowsSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Flow Categories
         * @param {string} workspaceId 
         * @param {FlowCategorySearchRequest} flowCategorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlowCategories: async (workspaceId: string, flowCategorySearchRequest: FlowCategorySearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchFlowCategories', 'workspaceId', workspaceId)
            // verify required parameter 'flowCategorySearchRequest' is not null or undefined
            assertParamExists('searchFlowCategories', 'flowCategorySearchRequest', flowCategorySearchRequest)
            const localVarPath = `/v2/flows/categories/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCategorySearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Flow Crons
         * @param {string} workspaceId 
         * @param {FlowCronSearchRequest} flowCronSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlowCrons: async (workspaceId: string, flowCronSearchRequest: FlowCronSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchFlowCrons', 'workspaceId', workspaceId)
            // verify required parameter 'flowCronSearchRequest' is not null or undefined
            assertParamExists('searchFlowCrons', 'flowCronSearchRequest', flowCronSearchRequest)
            const localVarPath = `/v2/flows/crons/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCronSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowUpdate} flowUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlow: async (flowId: string, workspaceId: string, flowUpdate: FlowUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('updateFlow', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateFlow', 'workspaceId', workspaceId)
            // verify required parameter 'flowUpdate' is not null or undefined
            assertParamExists('updateFlow', 'flowUpdate', flowUpdate)
            const localVarPath = `/v2/flows/{flow_id}`
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Flow Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {FlowCategoryCreateRequest} flowCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlowCategory: async (catId: string, workspaceId: string, flowCategoryCreateRequest: FlowCategoryCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('updateFlowCategory', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateFlowCategory', 'workspaceId', workspaceId)
            // verify required parameter 'flowCategoryCreateRequest' is not null or undefined
            assertParamExists('updateFlowCategory', 'flowCategoryCreateRequest', flowCategoryCreateRequest)
            const localVarPath = `/v2/flows/categories/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCategoryCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Flow Cron
         * @param {string} cronId 
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowCronUpdateRequest} flowCronUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlowCron: async (cronId: string, flowId: string, workspaceId: string, flowCronUpdateRequest: FlowCronUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cronId' is not null or undefined
            assertParamExists('updateFlowCron', 'cronId', cronId)
            // verify required parameter 'flowId' is not null or undefined
            assertParamExists('updateFlowCron', 'flowId', flowId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateFlowCron', 'workspaceId', workspaceId)
            // verify required parameter 'flowCronUpdateRequest' is not null or undefined
            assertParamExists('updateFlowCron', 'flowCronUpdateRequest', flowCronUpdateRequest)
            const localVarPath = `/v2/flows/crons/{flow_id}/{cron_id}`
                .replace(`{${"cron_id"}}`, encodeURIComponent(String(cronId)))
                .replace(`{${"flow_id"}}`, encodeURIComponent(String(flowId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flowCronUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Attachments
         * @param {string} sessionId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachments: async (sessionId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('uploadAttachments', 'sessionId', sessionId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadAttachments', 'file', file)
            const localVarPath = `/v2/flows/sessions/{session_id}/attachments`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlowsApi - functional programming interface
 * @export
 */
export const FlowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlowsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Chatbot Session
         * @param {string} workspaceId 
         * @param {FlowSessionCreateRequest} flowSessionCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChatbotSession(workspaceId: string, flowSessionCreateRequest: FlowSessionCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChatbotSession(workspaceId, flowSessionCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.createChatbotSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Flow
         * @param {string} workspaceId 
         * @param {FlowCreate} flowCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFlow(workspaceId: string, flowCreate: FlowCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFlow(workspaceId, flowCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.createFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Flow Category
         * @param {string} workspaceId 
         * @param {FlowCategoryCreateRequest} flowCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFlowCategory(workspaceId: string, flowCategoryCreateRequest: FlowCategoryCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFlowCategory(workspaceId, flowCategoryCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.createFlowCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Flow Cron
         * @param {string} workspaceId 
         * @param {FlowCronCreateRequest} flowCronCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFlowCron(workspaceId: string, flowCronCreateRequest: FlowCronCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowCronResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFlowCron(workspaceId, flowCronCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.createFlowCron']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Flow Session
         * @param {string} workspaceId 
         * @param {FlowSessionCreateFromFlowRequest} flowSessionCreateFromFlowRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFlowSession(workspaceId: string, flowSessionCreateFromFlowRequest: FlowSessionCreateFromFlowRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFlowSession(workspaceId, flowSessionCreateFromFlowRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.createFlowSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Message Feedback
         * @param {string} sessionId 
         * @param {FlowMessageFeedbackRequest} flowMessageFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessageFeedback(sessionId: string, flowMessageFeedbackRequest: FlowMessageFeedbackRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowMessageFeedbackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessageFeedback(sessionId, flowMessageFeedbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.createMessageFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Attachment
         * @param {string} sessionId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttachment(sessionId: string, fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttachment(sessionId, fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.deleteAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlow(flowId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlow(flowId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.deleteFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Flow Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlowCategory(catId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlowCategory(catId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.deleteFlowCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Flow Cron
         * @param {string} flowId 
         * @param {string} cronId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFlowCron(flowId: string, cronId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFlowCron(flowId, cronId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.deleteFlowCron']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Execute Flow Cron
         * @param {string} cronId 
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeFlowCron(cronId: string, flowId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeFlowCron(cronId, flowId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.executeFlowCron']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate Commit Message
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateCommitMessage(flowId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowCommitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateCommitMessage(flowId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.generateCommitMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {string} [branch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(flowId: string, workspaceId: string, branch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(flowId, workspaceId, branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllComponents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllComponents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.getAllComponents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Attachments
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachments(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowSessionAttachmentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachments(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.getAttachments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Flow Versions
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlowVersions(flowId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowVersionHistoryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlowVersions(flowId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.getFlowVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Invoked Flow Results
         * @param {string} flowId 
         * @param {string} taskId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvokedFlowResults(flowId: string, taskId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvokedFlowResults(flowId, taskId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.getInvokedFlowResults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Public Flow
         * @param {string} flowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicFlow(flowId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicFlow(flowId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.getPublicFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Trigger Types
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTriggerTypes(flowId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTriggerTypes(flowId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.getTriggerTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowInvokeRequest} flowInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invokeFlow(flowId: string, workspaceId: string, flowInvokeRequest: FlowInvokeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invokeFlow(flowId, workspaceId, flowInvokeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.invokeFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke Flow Response
         * @param {string} sessionId 
         * @param {FlowSessionInvokeRequest} flowSessionInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invokeFlowResponse(sessionId: string, flowSessionInvokeRequest: FlowSessionInvokeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionInvocationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invokeFlowResponse(sessionId, flowSessionInvokeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.invokeFlowResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invoke Flow Singleton
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowInvokeRequest} flowInvokeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invokeFlowSingleton(flowId: string, workspaceId: string, flowInvokeRequest: FlowInvokeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invokeFlowSingleton(flowId, workspaceId, flowInvokeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.invokeFlowSingleton']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Poll Flow Response
         * @param {string} sessionId 
         * @param {string} fromTimestamp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pollFlowResponse(sessionId: string, fromTimestamp: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowSessionEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pollFlowResponse(sessionId, fromTimestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.pollFlowResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Publish Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowCommitRequest} flowCommitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishFlow(flowId: string, workspaceId: string, flowCommitRequest: FlowCommitRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishFlow(flowId, workspaceId, flowCommitRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.publishFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore Flow Version
         * @param {string} flowId 
         * @param {string} branch 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreFlowVersion(flowId: string, branch: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreFlowVersion(flowId, branch, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.restoreFlowVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search
         * @param {string | null} workspaceId 
         * @param {FlowSearchRequest} flowSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(workspaceId: string | null, flowSearchRequest: FlowSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(workspaceId, flowSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.search']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search All
         * @param {string} workspaceId 
         * @param {AllFlowsSearchRequest} allFlowsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAll(workspaceId: string, allFlowsSearchRequest: AllFlowsSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAll(workspaceId, allFlowsSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.searchAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Flow Categories
         * @param {string} workspaceId 
         * @param {FlowCategorySearchRequest} flowCategorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchFlowCategories(workspaceId: string, flowCategorySearchRequest: FlowCategorySearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowCategoryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFlowCategories(workspaceId, flowCategorySearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.searchFlowCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Flow Crons
         * @param {string} workspaceId 
         * @param {FlowCronSearchRequest} flowCronSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchFlowCrons(workspaceId: string, flowCronSearchRequest: FlowCronSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlowCronResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFlowCrons(workspaceId, flowCronSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.searchFlowCrons']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Flow
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowUpdate} flowUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFlow(flowId: string, workspaceId: string, flowUpdate: FlowUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFlow(flowId, workspaceId, flowUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.updateFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Flow Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {FlowCategoryCreateRequest} flowCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFlowCategory(catId: string, workspaceId: string, flowCategoryCreateRequest: FlowCategoryCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFlowCategory(catId, workspaceId, flowCategoryCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.updateFlowCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Flow Cron
         * @param {string} cronId 
         * @param {string} flowId 
         * @param {string} workspaceId 
         * @param {FlowCronUpdateRequest} flowCronUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFlowCron(cronId: string, flowId: string, workspaceId: string, flowCronUpdateRequest: FlowCronUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowCronResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFlowCron(cronId, flowId, workspaceId, flowCronUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.updateFlowCron']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Attachments
         * @param {string} sessionId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadAttachments(sessionId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowSessionAttachmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadAttachments(sessionId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowsApi.uploadAttachments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FlowsApi - factory interface
 * @export
 */
export const FlowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlowsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Chatbot Session
         * @param {FlowsApiCreateChatbotSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatbotSession(requestParameters: FlowsApiCreateChatbotSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionResponse> {
            return localVarFp.createChatbotSession(requestParameters.workspaceId, requestParameters.flowSessionCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Flow
         * @param {FlowsApiCreateFlowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlow(requestParameters: FlowsApiCreateFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse> {
            return localVarFp.createFlow(requestParameters.workspaceId, requestParameters.flowCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Flow Category
         * @param {FlowsApiCreateFlowCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowCategory(requestParameters: FlowsApiCreateFlowCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCategoryResponse> {
            return localVarFp.createFlowCategory(requestParameters.workspaceId, requestParameters.flowCategoryCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Flow Cron
         * @param {FlowsApiCreateFlowCronRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowCron(requestParameters: FlowsApiCreateFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCronResponse> {
            return localVarFp.createFlowCron(requestParameters.workspaceId, requestParameters.flowCronCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Flow Session
         * @param {FlowsApiCreateFlowSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFlowSession(requestParameters: FlowsApiCreateFlowSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionResponse> {
            return localVarFp.createFlowSession(requestParameters.workspaceId, requestParameters.flowSessionCreateFromFlowRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Message Feedback
         * @param {FlowsApiCreateMessageFeedbackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageFeedback(requestParameters: FlowsApiCreateMessageFeedbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowMessageFeedbackResponse> {
            return localVarFp.createMessageFeedback(requestParameters.sessionId, requestParameters.flowMessageFeedbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Attachment
         * @param {FlowsApiDeleteAttachmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(requestParameters: FlowsApiDeleteAttachmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteAttachment(requestParameters.sessionId, requestParameters.fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Flow
         * @param {FlowsApiDeleteFlowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlow(requestParameters: FlowsApiDeleteFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteFlow(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Flow Category
         * @param {FlowsApiDeleteFlowCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlowCategory(requestParameters: FlowsApiDeleteFlowCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteFlowCategory(requestParameters.catId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Flow Cron
         * @param {FlowsApiDeleteFlowCronRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFlowCron(requestParameters: FlowsApiDeleteFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteFlowCron(requestParameters.flowId, requestParameters.cronId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute Flow Cron
         * @param {FlowsApiExecuteFlowCronRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeFlowCron(requestParameters: FlowsApiExecuteFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.executeFlowCron(requestParameters.cronId, requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate Commit Message
         * @param {FlowsApiGenerateCommitMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCommitMessage(requestParameters: FlowsApiGenerateCommitMessageRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCommitResponse> {
            return localVarFp.generateCommitMessage(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get
         * @param {FlowsApiGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(requestParameters: FlowsApiGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse> {
            return localVarFp.get(requestParameters.flowId, requestParameters.workspaceId, requestParameters.branch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllComponents(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getAllComponents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Attachments
         * @param {FlowsApiGetAttachmentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(requestParameters: FlowsApiGetAttachmentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionAttachmentResponse>> {
            return localVarFp.getAttachments(requestParameters.sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Flow Versions
         * @param {FlowsApiGetFlowVersionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlowVersions(requestParameters: FlowsApiGetFlowVersionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowVersionHistoryResponse>> {
            return localVarFp.getFlowVersions(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Invoked Flow Results
         * @param {FlowsApiGetInvokedFlowResultsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvokedFlowResults(requestParameters: FlowsApiGetInvokedFlowResultsRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.getInvokedFlowResults(requestParameters.flowId, requestParameters.taskId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Public Flow
         * @param {FlowsApiGetPublicFlowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicFlow(requestParameters: FlowsApiGetPublicFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse> {
            return localVarFp.getPublicFlow(requestParameters.flowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Trigger Types
         * @param {FlowsApiGetTriggerTypesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerTypes(requestParameters: FlowsApiGetTriggerTypesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TriggerResponse> {
            return localVarFp.getTriggerTypes(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke Flow
         * @param {FlowsApiInvokeFlowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlow(requestParameters: FlowsApiInvokeFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.invokeFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowInvokeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke Flow Response
         * @param {FlowsApiInvokeFlowResponseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlowResponse(requestParameters: FlowsApiInvokeFlowResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse> {
            return localVarFp.invokeFlowResponse(requestParameters.sessionId, requestParameters.flowSessionInvokeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invoke Flow Singleton
         * @param {FlowsApiInvokeFlowSingletonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeFlowSingleton(requestParameters: FlowsApiInvokeFlowSingletonRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.invokeFlowSingleton(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowInvokeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Poll Flow Response
         * @param {FlowsApiPollFlowResponseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollFlowResponse(requestParameters: FlowsApiPollFlowResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionEvent>> {
            return localVarFp.pollFlowResponse(requestParameters.sessionId, requestParameters.fromTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publish Flow
         * @param {FlowsApiPublishFlowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishFlow(requestParameters: FlowsApiPublishFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse> {
            return localVarFp.publishFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowCommitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore Flow Version
         * @param {FlowsApiRestoreFlowVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreFlowVersion(requestParameters: FlowsApiRestoreFlowVersionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.restoreFlowVersion(requestParameters.flowId, requestParameters.branch, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search
         * @param {FlowsApiSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(requestParameters: FlowsApiSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowResponse>> {
            return localVarFp.search(requestParameters.workspaceId, requestParameters.flowSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search All
         * @param {FlowsApiSearchAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAll(requestParameters: FlowsApiSearchAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowResponse>> {
            return localVarFp.searchAll(requestParameters.workspaceId, requestParameters.allFlowsSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Flow Categories
         * @param {FlowsApiSearchFlowCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlowCategories(requestParameters: FlowsApiSearchFlowCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowCategoryResponse>> {
            return localVarFp.searchFlowCategories(requestParameters.workspaceId, requestParameters.flowCategorySearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Flow Crons
         * @param {FlowsApiSearchFlowCronsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFlowCrons(requestParameters: FlowsApiSearchFlowCronsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowCronResponse>> {
            return localVarFp.searchFlowCrons(requestParameters.workspaceId, requestParameters.flowCronSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Flow
         * @param {FlowsApiUpdateFlowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlow(requestParameters: FlowsApiUpdateFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse> {
            return localVarFp.updateFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Flow Category
         * @param {FlowsApiUpdateFlowCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlowCategory(requestParameters: FlowsApiUpdateFlowCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCategoryResponse> {
            return localVarFp.updateFlowCategory(requestParameters.catId, requestParameters.workspaceId, requestParameters.flowCategoryCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Flow Cron
         * @param {FlowsApiUpdateFlowCronRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFlowCron(requestParameters: FlowsApiUpdateFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCronResponse> {
            return localVarFp.updateFlowCron(requestParameters.cronId, requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowCronUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Attachments
         * @param {FlowsApiUploadAttachmentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachments(requestParameters: FlowsApiUploadAttachmentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionAttachmentResponse> {
            return localVarFp.uploadAttachments(requestParameters.sessionId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlowsApi - interface
 * @export
 * @interface FlowsApi
 */
export interface FlowsApiInterface {
    /**
     * 
     * @summary Create Chatbot Session
     * @param {FlowsApiCreateChatbotSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    createChatbotSession(requestParameters: FlowsApiCreateChatbotSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionResponse>;

    /**
     * 
     * @summary Create Flow
     * @param {FlowsApiCreateFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    createFlow(requestParameters: FlowsApiCreateFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse>;

    /**
     * 
     * @summary Create Flow Category
     * @param {FlowsApiCreateFlowCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    createFlowCategory(requestParameters: FlowsApiCreateFlowCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCategoryResponse>;

    /**
     * 
     * @summary Create Flow Cron
     * @param {FlowsApiCreateFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    createFlowCron(requestParameters: FlowsApiCreateFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCronResponse>;

    /**
     * 
     * @summary Create Flow Session
     * @param {FlowsApiCreateFlowSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    createFlowSession(requestParameters: FlowsApiCreateFlowSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionResponse>;

    /**
     * 
     * @summary Create Message Feedback
     * @param {FlowsApiCreateMessageFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    createMessageFeedback(requestParameters: FlowsApiCreateMessageFeedbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowMessageFeedbackResponse>;

    /**
     * 
     * @summary Delete Attachment
     * @param {FlowsApiDeleteAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    deleteAttachment(requestParameters: FlowsApiDeleteAttachmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Delete Flow
     * @param {FlowsApiDeleteFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    deleteFlow(requestParameters: FlowsApiDeleteFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Delete Flow Category
     * @param {FlowsApiDeleteFlowCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    deleteFlowCategory(requestParameters: FlowsApiDeleteFlowCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Delete Flow Cron
     * @param {FlowsApiDeleteFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    deleteFlowCron(requestParameters: FlowsApiDeleteFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Execute Flow Cron
     * @param {FlowsApiExecuteFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    executeFlowCron(requestParameters: FlowsApiExecuteFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

    /**
     * 
     * @summary Generate Commit Message
     * @param {FlowsApiGenerateCommitMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    generateCommitMessage(requestParameters: FlowsApiGenerateCommitMessageRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCommitResponse>;

    /**
     * 
     * @summary Get
     * @param {FlowsApiGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    get(requestParameters: FlowsApiGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse>;

    /**
     * 
     * @summary Get All Components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    getAllComponents(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Attachments
     * @param {FlowsApiGetAttachmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    getAttachments(requestParameters: FlowsApiGetAttachmentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionAttachmentResponse>>;

    /**
     * 
     * @summary Get Flow Versions
     * @param {FlowsApiGetFlowVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    getFlowVersions(requestParameters: FlowsApiGetFlowVersionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowVersionHistoryResponse>>;

    /**
     * 
     * @summary Get Invoked Flow Results
     * @param {FlowsApiGetInvokedFlowResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    getInvokedFlowResults(requestParameters: FlowsApiGetInvokedFlowResultsRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

    /**
     * 
     * @summary Get Public Flow
     * @param {FlowsApiGetPublicFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    getPublicFlow(requestParameters: FlowsApiGetPublicFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse>;

    /**
     * 
     * @summary Get Trigger Types
     * @param {FlowsApiGetTriggerTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    getTriggerTypes(requestParameters: FlowsApiGetTriggerTypesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TriggerResponse>;

    /**
     * 
     * @summary Invoke Flow
     * @param {FlowsApiInvokeFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    invokeFlow(requestParameters: FlowsApiInvokeFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

    /**
     * 
     * @summary Invoke Flow Response
     * @param {FlowsApiInvokeFlowResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    invokeFlowResponse(requestParameters: FlowsApiInvokeFlowResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionInvocationResponse>;

    /**
     * 
     * @summary Invoke Flow Singleton
     * @param {FlowsApiInvokeFlowSingletonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    invokeFlowSingleton(requestParameters: FlowsApiInvokeFlowSingletonRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

    /**
     * 
     * @summary Poll Flow Response
     * @param {FlowsApiPollFlowResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    pollFlowResponse(requestParameters: FlowsApiPollFlowResponseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowSessionEvent>>;

    /**
     * 
     * @summary Publish Flow
     * @param {FlowsApiPublishFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    publishFlow(requestParameters: FlowsApiPublishFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse>;

    /**
     * 
     * @summary Restore Flow Version
     * @param {FlowsApiRestoreFlowVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    restoreFlowVersion(requestParameters: FlowsApiRestoreFlowVersionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Search
     * @param {FlowsApiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    search(requestParameters: FlowsApiSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowResponse>>;

    /**
     * 
     * @summary Search All
     * @param {FlowsApiSearchAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    searchAll(requestParameters: FlowsApiSearchAllRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowResponse>>;

    /**
     * 
     * @summary Search Flow Categories
     * @param {FlowsApiSearchFlowCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    searchFlowCategories(requestParameters: FlowsApiSearchFlowCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowCategoryResponse>>;

    /**
     * 
     * @summary Search Flow Crons
     * @param {FlowsApiSearchFlowCronsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    searchFlowCrons(requestParameters: FlowsApiSearchFlowCronsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FlowCronResponse>>;

    /**
     * 
     * @summary Update Flow
     * @param {FlowsApiUpdateFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    updateFlow(requestParameters: FlowsApiUpdateFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowDetailResponse>;

    /**
     * 
     * @summary Update Flow Category
     * @param {FlowsApiUpdateFlowCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    updateFlowCategory(requestParameters: FlowsApiUpdateFlowCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCategoryResponse>;

    /**
     * 
     * @summary Update Flow Cron
     * @param {FlowsApiUpdateFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    updateFlowCron(requestParameters: FlowsApiUpdateFlowCronRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowCronResponse>;

    /**
     * 
     * @summary Upload Attachments
     * @param {FlowsApiUploadAttachmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApiInterface
     */
    uploadAttachments(requestParameters: FlowsApiUploadAttachmentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowSessionAttachmentResponse>;

}

/**
 * Request parameters for createChatbotSession operation in FlowsApi.
 * @export
 * @interface FlowsApiCreateChatbotSessionRequest
 */
export interface FlowsApiCreateChatbotSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiCreateChatbotSession
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowSessionCreateRequest}
     * @memberof FlowsApiCreateChatbotSession
     */
    readonly flowSessionCreateRequest: FlowSessionCreateRequest
}

/**
 * Request parameters for createFlow operation in FlowsApi.
 * @export
 * @interface FlowsApiCreateFlowRequest
 */
export interface FlowsApiCreateFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiCreateFlow
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCreate}
     * @memberof FlowsApiCreateFlow
     */
    readonly flowCreate: FlowCreate
}

/**
 * Request parameters for createFlowCategory operation in FlowsApi.
 * @export
 * @interface FlowsApiCreateFlowCategoryRequest
 */
export interface FlowsApiCreateFlowCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiCreateFlowCategory
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCategoryCreateRequest}
     * @memberof FlowsApiCreateFlowCategory
     */
    readonly flowCategoryCreateRequest: FlowCategoryCreateRequest
}

/**
 * Request parameters for createFlowCron operation in FlowsApi.
 * @export
 * @interface FlowsApiCreateFlowCronRequest
 */
export interface FlowsApiCreateFlowCronRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiCreateFlowCron
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCronCreateRequest}
     * @memberof FlowsApiCreateFlowCron
     */
    readonly flowCronCreateRequest: FlowCronCreateRequest
}

/**
 * Request parameters for createFlowSession operation in FlowsApi.
 * @export
 * @interface FlowsApiCreateFlowSessionRequest
 */
export interface FlowsApiCreateFlowSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiCreateFlowSession
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowSessionCreateFromFlowRequest}
     * @memberof FlowsApiCreateFlowSession
     */
    readonly flowSessionCreateFromFlowRequest: FlowSessionCreateFromFlowRequest
}

/**
 * Request parameters for createMessageFeedback operation in FlowsApi.
 * @export
 * @interface FlowsApiCreateMessageFeedbackRequest
 */
export interface FlowsApiCreateMessageFeedbackRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiCreateMessageFeedback
     */
    readonly sessionId: string

    /**
     * 
     * @type {FlowMessageFeedbackRequest}
     * @memberof FlowsApiCreateMessageFeedback
     */
    readonly flowMessageFeedbackRequest: FlowMessageFeedbackRequest
}

/**
 * Request parameters for deleteAttachment operation in FlowsApi.
 * @export
 * @interface FlowsApiDeleteAttachmentRequest
 */
export interface FlowsApiDeleteAttachmentRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteAttachment
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteAttachment
     */
    readonly fileId: string
}

/**
 * Request parameters for deleteFlow operation in FlowsApi.
 * @export
 * @interface FlowsApiDeleteFlowRequest
 */
export interface FlowsApiDeleteFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteFlow
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteFlow
     */
    readonly workspaceId: string
}

/**
 * Request parameters for deleteFlowCategory operation in FlowsApi.
 * @export
 * @interface FlowsApiDeleteFlowCategoryRequest
 */
export interface FlowsApiDeleteFlowCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteFlowCategory
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteFlowCategory
     */
    readonly workspaceId: string
}

/**
 * Request parameters for deleteFlowCron operation in FlowsApi.
 * @export
 * @interface FlowsApiDeleteFlowCronRequest
 */
export interface FlowsApiDeleteFlowCronRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteFlowCron
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteFlowCron
     */
    readonly cronId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiDeleteFlowCron
     */
    readonly workspaceId: string
}

/**
 * Request parameters for executeFlowCron operation in FlowsApi.
 * @export
 * @interface FlowsApiExecuteFlowCronRequest
 */
export interface FlowsApiExecuteFlowCronRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiExecuteFlowCron
     */
    readonly cronId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiExecuteFlowCron
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiExecuteFlowCron
     */
    readonly workspaceId: string
}

/**
 * Request parameters for generateCommitMessage operation in FlowsApi.
 * @export
 * @interface FlowsApiGenerateCommitMessageRequest
 */
export interface FlowsApiGenerateCommitMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiGenerateCommitMessage
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiGenerateCommitMessage
     */
    readonly workspaceId: string
}

/**
 * Request parameters for get operation in FlowsApi.
 * @export
 * @interface FlowsApiGetRequest
 */
export interface FlowsApiGetRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiGet
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiGet
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiGet
     */
    readonly branch?: string
}

/**
 * Request parameters for getAttachments operation in FlowsApi.
 * @export
 * @interface FlowsApiGetAttachmentsRequest
 */
export interface FlowsApiGetAttachmentsRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetAttachments
     */
    readonly sessionId: string
}

/**
 * Request parameters for getFlowVersions operation in FlowsApi.
 * @export
 * @interface FlowsApiGetFlowVersionsRequest
 */
export interface FlowsApiGetFlowVersionsRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetFlowVersions
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetFlowVersions
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getInvokedFlowResults operation in FlowsApi.
 * @export
 * @interface FlowsApiGetInvokedFlowResultsRequest
 */
export interface FlowsApiGetInvokedFlowResultsRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetInvokedFlowResults
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetInvokedFlowResults
     */
    readonly taskId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetInvokedFlowResults
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getPublicFlow operation in FlowsApi.
 * @export
 * @interface FlowsApiGetPublicFlowRequest
 */
export interface FlowsApiGetPublicFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetPublicFlow
     */
    readonly flowId: string
}

/**
 * Request parameters for getTriggerTypes operation in FlowsApi.
 * @export
 * @interface FlowsApiGetTriggerTypesRequest
 */
export interface FlowsApiGetTriggerTypesRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetTriggerTypes
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiGetTriggerTypes
     */
    readonly workspaceId: string
}

/**
 * Request parameters for invokeFlow operation in FlowsApi.
 * @export
 * @interface FlowsApiInvokeFlowRequest
 */
export interface FlowsApiInvokeFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiInvokeFlow
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiInvokeFlow
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowInvokeRequest}
     * @memberof FlowsApiInvokeFlow
     */
    readonly flowInvokeRequest: FlowInvokeRequest
}

/**
 * Request parameters for invokeFlowResponse operation in FlowsApi.
 * @export
 * @interface FlowsApiInvokeFlowResponseRequest
 */
export interface FlowsApiInvokeFlowResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiInvokeFlowResponse
     */
    readonly sessionId: string

    /**
     * 
     * @type {FlowSessionInvokeRequest}
     * @memberof FlowsApiInvokeFlowResponse
     */
    readonly flowSessionInvokeRequest: FlowSessionInvokeRequest
}

/**
 * Request parameters for invokeFlowSingleton operation in FlowsApi.
 * @export
 * @interface FlowsApiInvokeFlowSingletonRequest
 */
export interface FlowsApiInvokeFlowSingletonRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiInvokeFlowSingleton
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiInvokeFlowSingleton
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowInvokeRequest}
     * @memberof FlowsApiInvokeFlowSingleton
     */
    readonly flowInvokeRequest: FlowInvokeRequest
}

/**
 * Request parameters for pollFlowResponse operation in FlowsApi.
 * @export
 * @interface FlowsApiPollFlowResponseRequest
 */
export interface FlowsApiPollFlowResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiPollFlowResponse
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiPollFlowResponse
     */
    readonly fromTimestamp: string
}

/**
 * Request parameters for publishFlow operation in FlowsApi.
 * @export
 * @interface FlowsApiPublishFlowRequest
 */
export interface FlowsApiPublishFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiPublishFlow
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiPublishFlow
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCommitRequest}
     * @memberof FlowsApiPublishFlow
     */
    readonly flowCommitRequest: FlowCommitRequest
}

/**
 * Request parameters for restoreFlowVersion operation in FlowsApi.
 * @export
 * @interface FlowsApiRestoreFlowVersionRequest
 */
export interface FlowsApiRestoreFlowVersionRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiRestoreFlowVersion
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiRestoreFlowVersion
     */
    readonly branch: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiRestoreFlowVersion
     */
    readonly workspaceId: string
}

/**
 * Request parameters for search operation in FlowsApi.
 * @export
 * @interface FlowsApiSearchRequest
 */
export interface FlowsApiSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiSearch
     */
    readonly workspaceId: string | null

    /**
     * 
     * @type {FlowSearchRequest}
     * @memberof FlowsApiSearch
     */
    readonly flowSearchRequest: FlowSearchRequest
}

/**
 * Request parameters for searchAll operation in FlowsApi.
 * @export
 * @interface FlowsApiSearchAllRequest
 */
export interface FlowsApiSearchAllRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiSearchAll
     */
    readonly workspaceId: string

    /**
     * 
     * @type {AllFlowsSearchRequest}
     * @memberof FlowsApiSearchAll
     */
    readonly allFlowsSearchRequest: AllFlowsSearchRequest
}

/**
 * Request parameters for searchFlowCategories operation in FlowsApi.
 * @export
 * @interface FlowsApiSearchFlowCategoriesRequest
 */
export interface FlowsApiSearchFlowCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiSearchFlowCategories
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCategorySearchRequest}
     * @memberof FlowsApiSearchFlowCategories
     */
    readonly flowCategorySearchRequest: FlowCategorySearchRequest
}

/**
 * Request parameters for searchFlowCrons operation in FlowsApi.
 * @export
 * @interface FlowsApiSearchFlowCronsRequest
 */
export interface FlowsApiSearchFlowCronsRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiSearchFlowCrons
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCronSearchRequest}
     * @memberof FlowsApiSearchFlowCrons
     */
    readonly flowCronSearchRequest: FlowCronSearchRequest
}

/**
 * Request parameters for updateFlow operation in FlowsApi.
 * @export
 * @interface FlowsApiUpdateFlowRequest
 */
export interface FlowsApiUpdateFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiUpdateFlow
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiUpdateFlow
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowUpdate}
     * @memberof FlowsApiUpdateFlow
     */
    readonly flowUpdate: FlowUpdate
}

/**
 * Request parameters for updateFlowCategory operation in FlowsApi.
 * @export
 * @interface FlowsApiUpdateFlowCategoryRequest
 */
export interface FlowsApiUpdateFlowCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiUpdateFlowCategory
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiUpdateFlowCategory
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCategoryCreateRequest}
     * @memberof FlowsApiUpdateFlowCategory
     */
    readonly flowCategoryCreateRequest: FlowCategoryCreateRequest
}

/**
 * Request parameters for updateFlowCron operation in FlowsApi.
 * @export
 * @interface FlowsApiUpdateFlowCronRequest
 */
export interface FlowsApiUpdateFlowCronRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiUpdateFlowCron
     */
    readonly cronId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiUpdateFlowCron
     */
    readonly flowId: string

    /**
     * 
     * @type {string}
     * @memberof FlowsApiUpdateFlowCron
     */
    readonly workspaceId: string

    /**
     * 
     * @type {FlowCronUpdateRequest}
     * @memberof FlowsApiUpdateFlowCron
     */
    readonly flowCronUpdateRequest: FlowCronUpdateRequest
}

/**
 * Request parameters for uploadAttachments operation in FlowsApi.
 * @export
 * @interface FlowsApiUploadAttachmentsRequest
 */
export interface FlowsApiUploadAttachmentsRequest {
    /**
     * 
     * @type {string}
     * @memberof FlowsApiUploadAttachments
     */
    readonly sessionId: string

    /**
     * 
     * @type {File}
     * @memberof FlowsApiUploadAttachments
     */
    readonly file: File
}

/**
 * FlowsApi - object-oriented interface
 * @export
 * @class FlowsApi
 * @extends {BaseAPI}
 */
export class FlowsApi extends BaseAPI implements FlowsApiInterface {
    /**
     * 
     * @summary Create Chatbot Session
     * @param {FlowsApiCreateChatbotSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public createChatbotSession(requestParameters: FlowsApiCreateChatbotSessionRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).createChatbotSession(requestParameters.workspaceId, requestParameters.flowSessionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Flow
     * @param {FlowsApiCreateFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public createFlow(requestParameters: FlowsApiCreateFlowRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).createFlow(requestParameters.workspaceId, requestParameters.flowCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Flow Category
     * @param {FlowsApiCreateFlowCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public createFlowCategory(requestParameters: FlowsApiCreateFlowCategoryRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).createFlowCategory(requestParameters.workspaceId, requestParameters.flowCategoryCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Flow Cron
     * @param {FlowsApiCreateFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public createFlowCron(requestParameters: FlowsApiCreateFlowCronRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).createFlowCron(requestParameters.workspaceId, requestParameters.flowCronCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Flow Session
     * @param {FlowsApiCreateFlowSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public createFlowSession(requestParameters: FlowsApiCreateFlowSessionRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).createFlowSession(requestParameters.workspaceId, requestParameters.flowSessionCreateFromFlowRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Message Feedback
     * @param {FlowsApiCreateMessageFeedbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public createMessageFeedback(requestParameters: FlowsApiCreateMessageFeedbackRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).createMessageFeedback(requestParameters.sessionId, requestParameters.flowMessageFeedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Attachment
     * @param {FlowsApiDeleteAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public deleteAttachment(requestParameters: FlowsApiDeleteAttachmentRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).deleteAttachment(requestParameters.sessionId, requestParameters.fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Flow
     * @param {FlowsApiDeleteFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public deleteFlow(requestParameters: FlowsApiDeleteFlowRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).deleteFlow(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Flow Category
     * @param {FlowsApiDeleteFlowCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public deleteFlowCategory(requestParameters: FlowsApiDeleteFlowCategoryRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).deleteFlowCategory(requestParameters.catId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Flow Cron
     * @param {FlowsApiDeleteFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public deleteFlowCron(requestParameters: FlowsApiDeleteFlowCronRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).deleteFlowCron(requestParameters.flowId, requestParameters.cronId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute Flow Cron
     * @param {FlowsApiExecuteFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public executeFlowCron(requestParameters: FlowsApiExecuteFlowCronRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).executeFlowCron(requestParameters.cronId, requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate Commit Message
     * @param {FlowsApiGenerateCommitMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public generateCommitMessage(requestParameters: FlowsApiGenerateCommitMessageRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).generateCommitMessage(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get
     * @param {FlowsApiGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public get(requestParameters: FlowsApiGetRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).get(requestParameters.flowId, requestParameters.workspaceId, requestParameters.branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public getAllComponents(options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).getAllComponents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Attachments
     * @param {FlowsApiGetAttachmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public getAttachments(requestParameters: FlowsApiGetAttachmentsRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).getAttachments(requestParameters.sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Flow Versions
     * @param {FlowsApiGetFlowVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public getFlowVersions(requestParameters: FlowsApiGetFlowVersionsRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).getFlowVersions(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Invoked Flow Results
     * @param {FlowsApiGetInvokedFlowResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public getInvokedFlowResults(requestParameters: FlowsApiGetInvokedFlowResultsRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).getInvokedFlowResults(requestParameters.flowId, requestParameters.taskId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Public Flow
     * @param {FlowsApiGetPublicFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public getPublicFlow(requestParameters: FlowsApiGetPublicFlowRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).getPublicFlow(requestParameters.flowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Trigger Types
     * @param {FlowsApiGetTriggerTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public getTriggerTypes(requestParameters: FlowsApiGetTriggerTypesRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).getTriggerTypes(requestParameters.flowId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke Flow
     * @param {FlowsApiInvokeFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public invokeFlow(requestParameters: FlowsApiInvokeFlowRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).invokeFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowInvokeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke Flow Response
     * @param {FlowsApiInvokeFlowResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public invokeFlowResponse(requestParameters: FlowsApiInvokeFlowResponseRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).invokeFlowResponse(requestParameters.sessionId, requestParameters.flowSessionInvokeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invoke Flow Singleton
     * @param {FlowsApiInvokeFlowSingletonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public invokeFlowSingleton(requestParameters: FlowsApiInvokeFlowSingletonRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).invokeFlowSingleton(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowInvokeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Poll Flow Response
     * @param {FlowsApiPollFlowResponseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public pollFlowResponse(requestParameters: FlowsApiPollFlowResponseRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).pollFlowResponse(requestParameters.sessionId, requestParameters.fromTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publish Flow
     * @param {FlowsApiPublishFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public publishFlow(requestParameters: FlowsApiPublishFlowRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).publishFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowCommitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore Flow Version
     * @param {FlowsApiRestoreFlowVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public restoreFlowVersion(requestParameters: FlowsApiRestoreFlowVersionRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).restoreFlowVersion(requestParameters.flowId, requestParameters.branch, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search
     * @param {FlowsApiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public search(requestParameters: FlowsApiSearchRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).search(requestParameters.workspaceId, requestParameters.flowSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search All
     * @param {FlowsApiSearchAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public searchAll(requestParameters: FlowsApiSearchAllRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).searchAll(requestParameters.workspaceId, requestParameters.allFlowsSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Flow Categories
     * @param {FlowsApiSearchFlowCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public searchFlowCategories(requestParameters: FlowsApiSearchFlowCategoriesRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).searchFlowCategories(requestParameters.workspaceId, requestParameters.flowCategorySearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Flow Crons
     * @param {FlowsApiSearchFlowCronsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public searchFlowCrons(requestParameters: FlowsApiSearchFlowCronsRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).searchFlowCrons(requestParameters.workspaceId, requestParameters.flowCronSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Flow
     * @param {FlowsApiUpdateFlowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public updateFlow(requestParameters: FlowsApiUpdateFlowRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).updateFlow(requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Flow Category
     * @param {FlowsApiUpdateFlowCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public updateFlowCategory(requestParameters: FlowsApiUpdateFlowCategoryRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).updateFlowCategory(requestParameters.catId, requestParameters.workspaceId, requestParameters.flowCategoryCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Flow Cron
     * @param {FlowsApiUpdateFlowCronRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public updateFlowCron(requestParameters: FlowsApiUpdateFlowCronRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).updateFlowCron(requestParameters.cronId, requestParameters.flowId, requestParameters.workspaceId, requestParameters.flowCronUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Attachments
     * @param {FlowsApiUploadAttachmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlowsApi
     */
    public uploadAttachments(requestParameters: FlowsApiUploadAttachmentsRequest, options?: RawAxiosRequestConfig) {
        return FlowsApiFp(this.configuration).uploadAttachments(requestParameters.sessionId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoogleApi - axios parameter creator
 * @export
 */
export const GoogleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Calendars
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendars: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getCalendars', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/google/calendar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Picker Token
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPickerToken: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getPickerToken', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/google/picker_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Sheets
         * @param {string} documentId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSheets: async (documentId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getSheets', 'documentId', documentId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSheets', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/google/sheets/{document_id}`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleApi - functional programming interface
 * @export
 */
export const GoogleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoogleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Calendars
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalendars(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleCalendarsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalendars(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleApi.getCalendars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Picker Token
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPickerToken(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GooglePickerTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPickerToken(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleApi.getPickerToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Sheets
         * @param {string} documentId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSheets(documentId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleSheetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSheets(documentId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleApi.getSheets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GoogleApi - factory interface
 * @export
 */
export const GoogleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoogleApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Calendars
         * @param {GoogleApiGetCalendarsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendars(requestParameters: GoogleApiGetCalendarsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleCalendarsResponse> {
            return localVarFp.getCalendars(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Picker Token
         * @param {GoogleApiGetPickerTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPickerToken(requestParameters: GoogleApiGetPickerTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<GooglePickerTokenResponse> {
            return localVarFp.getPickerToken(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Sheets
         * @param {GoogleApiGetSheetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSheets(requestParameters: GoogleApiGetSheetsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleSheetsResponse> {
            return localVarFp.getSheets(requestParameters.documentId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoogleApi - interface
 * @export
 * @interface GoogleApi
 */
export interface GoogleApiInterface {
    /**
     * 
     * @summary Get Calendars
     * @param {GoogleApiGetCalendarsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleApiInterface
     */
    getCalendars(requestParameters: GoogleApiGetCalendarsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleCalendarsResponse>;

    /**
     * 
     * @summary Get Picker Token
     * @param {GoogleApiGetPickerTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleApiInterface
     */
    getPickerToken(requestParameters: GoogleApiGetPickerTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<GooglePickerTokenResponse>;

    /**
     * 
     * @summary Get Sheets
     * @param {GoogleApiGetSheetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleApiInterface
     */
    getSheets(requestParameters: GoogleApiGetSheetsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleSheetsResponse>;

}

/**
 * Request parameters for getCalendars operation in GoogleApi.
 * @export
 * @interface GoogleApiGetCalendarsRequest
 */
export interface GoogleApiGetCalendarsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleApiGetCalendars
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getPickerToken operation in GoogleApi.
 * @export
 * @interface GoogleApiGetPickerTokenRequest
 */
export interface GoogleApiGetPickerTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleApiGetPickerToken
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getSheets operation in GoogleApi.
 * @export
 * @interface GoogleApiGetSheetsRequest
 */
export interface GoogleApiGetSheetsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleApiGetSheets
     */
    readonly documentId: string

    /**
     * 
     * @type {string}
     * @memberof GoogleApiGetSheets
     */
    readonly workspaceId: string
}

/**
 * GoogleApi - object-oriented interface
 * @export
 * @class GoogleApi
 * @extends {BaseAPI}
 */
export class GoogleApi extends BaseAPI implements GoogleApiInterface {
    /**
     * 
     * @summary Get Calendars
     * @param {GoogleApiGetCalendarsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleApi
     */
    public getCalendars(requestParameters: GoogleApiGetCalendarsRequest, options?: RawAxiosRequestConfig) {
        return GoogleApiFp(this.configuration).getCalendars(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Picker Token
     * @param {GoogleApiGetPickerTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleApi
     */
    public getPickerToken(requestParameters: GoogleApiGetPickerTokenRequest, options?: RawAxiosRequestConfig) {
        return GoogleApiFp(this.configuration).getPickerToken(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Sheets
     * @param {GoogleApiGetSheetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleApi
     */
    public getSheets(requestParameters: GoogleApiGetSheetsRequest, options?: RawAxiosRequestConfig) {
        return GoogleApiFp(this.configuration).getSheets(requestParameters.documentId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoogleAdsApi - axios parameter creator
 * @export
 */
export const GoogleAdsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Keyword To Group
         * @param {string} workspaceId 
         * @param {GoogleAdsKeywordAddRequest} googleAdsKeywordAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addKeywordToGroup: async (workspaceId: string, googleAdsKeywordAddRequest: GoogleAdsKeywordAddRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addKeywordToGroup', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsKeywordAddRequest' is not null or undefined
            assertParamExists('addKeywordToGroup', 'googleAdsKeywordAddRequest', googleAdsKeywordAddRequest)
            const localVarPath = `/v2/integrations/google_ads/keyword/add_to_group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsKeywordAddRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Analyze Not Assigned Keywords
         * @param {string} workspaceId 
         * @param {GoogleAdsAnalyzeKeywordsRequest} googleAdsAnalyzeKeywordsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeNotAssignedKeywords: async (workspaceId: string, googleAdsAnalyzeKeywordsRequest: GoogleAdsAnalyzeKeywordsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('analyzeNotAssignedKeywords', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsAnalyzeKeywordsRequest' is not null or undefined
            assertParamExists('analyzeNotAssignedKeywords', 'googleAdsAnalyzeKeywordsRequest', googleAdsAnalyzeKeywordsRequest)
            const localVarPath = `/v2/integrations/google_ads/analyze_not_assigned_keywords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsAnalyzeKeywordsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Google Ads Campaigns
         * @param {string} workspaceId 
         * @param {GoogleAdsCampaignsSearchRequest} googleAdsCampaignsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoogleAdsCampaigns: async (workspaceId: string, googleAdsCampaignsSearchRequest: GoogleAdsCampaignsSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getGoogleAdsCampaigns', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsCampaignsSearchRequest' is not null or undefined
            assertParamExists('getGoogleAdsCampaigns', 'googleAdsCampaignsSearchRequest', googleAdsCampaignsSearchRequest)
            const localVarPath = `/v2/integrations/google_ads/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsCampaignsSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Google Ads Customers
         * @param {string} workspaceId 
         * @param {GoogleAdsCustomersSearchRequest} googleAdsCustomersSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoogleAdsCustomers: async (workspaceId: string, googleAdsCustomersSearchRequest: GoogleAdsCustomersSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getGoogleAdsCustomers', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsCustomersSearchRequest' is not null or undefined
            assertParamExists('getGoogleAdsCustomers', 'googleAdsCustomersSearchRequest', googleAdsCustomersSearchRequest)
            const localVarPath = `/v2/integrations/google_ads/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsCustomersSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Google Ads Groups
         * @param {string} workspaceId 
         * @param {GoogleAdsGroupsSearchRequest} googleAdsGroupsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoogleAdsGroups: async (workspaceId: string, googleAdsGroupsSearchRequest: GoogleAdsGroupsSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getGoogleAdsGroups', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsGroupsSearchRequest' is not null or undefined
            assertParamExists('getGoogleAdsGroups', 'googleAdsGroupsSearchRequest', googleAdsGroupsSearchRequest)
            const localVarPath = `/v2/integrations/google_ads/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsGroupsSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Recommendations
         * @param {string} workspaceId 
         * @param {GoogleAdsRecommendationsRequest} googleAdsRecommendationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendations: async (workspaceId: string, googleAdsRecommendationsRequest: GoogleAdsRecommendationsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRecommendations', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsRecommendationsRequest' is not null or undefined
            assertParamExists('getRecommendations', 'googleAdsRecommendationsRequest', googleAdsRecommendationsRequest)
            const localVarPath = `/v2/integrations/google_ads/recommendations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsRecommendationsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Google Ads Campaigns
         * @param {string} workspaceId 
         * @param {GoogleAdsCampaignsSearchRequest} googleAdsCampaignsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGoogleAdsCampaigns: async (workspaceId: string, googleAdsCampaignsSearchRequest: GoogleAdsCampaignsSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('importGoogleAdsCampaigns', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsCampaignsSearchRequest' is not null or undefined
            assertParamExists('importGoogleAdsCampaigns', 'googleAdsCampaignsSearchRequest', googleAdsCampaignsSearchRequest)
            const localVarPath = `/v2/integrations/google_ads/campaigns/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsCampaignsSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Google Ads Customers
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGoogleAdsCustomers: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('importGoogleAdsCustomers', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/google_ads/customers/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Google Ads Groups
         * @param {string} workspaceId 
         * @param {GoogleAdsGroupsSearchRequest} googleAdsGroupsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGoogleAdsGroups: async (workspaceId: string, googleAdsGroupsSearchRequest: GoogleAdsGroupsSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('importGoogleAdsGroups', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsGroupsSearchRequest' is not null or undefined
            assertParamExists('importGoogleAdsGroups', 'googleAdsGroupsSearchRequest', googleAdsGroupsSearchRequest)
            const localVarPath = `/v2/integrations/google_ads/groups/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsGroupsSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Keyword From Group
         * @param {string} workspaceId 
         * @param {GoogleAdsKeywordRemoveRequest} googleAdsKeywordRemoveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeKeywordFromGroup: async (workspaceId: string, googleAdsKeywordRemoveRequest: GoogleAdsKeywordRemoveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeKeywordFromGroup', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsKeywordRemoveRequest' is not null or undefined
            assertParamExists('removeKeywordFromGroup', 'googleAdsKeywordRemoveRequest', googleAdsKeywordRemoveRequest)
            const localVarPath = `/v2/integrations/google_ads/keyword/remove_from_group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsKeywordRemoveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Google Ads Campaign
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} workspaceId 
         * @param {GoogleAdsCampaignUpdateRequest} googleAdsCampaignUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoogleAdsCampaign: async (customerId: string, campaignId: string, workspaceId: string, googleAdsCampaignUpdateRequest: GoogleAdsCampaignUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateGoogleAdsCampaign', 'customerId', customerId)
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('updateGoogleAdsCampaign', 'campaignId', campaignId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateGoogleAdsCampaign', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsCampaignUpdateRequest' is not null or undefined
            assertParamExists('updateGoogleAdsCampaign', 'googleAdsCampaignUpdateRequest', googleAdsCampaignUpdateRequest)
            const localVarPath = `/v2/integrations/google_ads/campaigns/{customer_id}/{campaign_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsCampaignUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Google Ads Customer Update
         * @param {string} customerId 
         * @param {string} workspaceId 
         * @param {GoogleAdsCustomerUpdateRequest} googleAdsCustomerUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoogleAdsCustomerUpdate: async (customerId: string, workspaceId: string, googleAdsCustomerUpdateRequest: GoogleAdsCustomerUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateGoogleAdsCustomerUpdate', 'customerId', customerId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateGoogleAdsCustomerUpdate', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsCustomerUpdateRequest' is not null or undefined
            assertParamExists('updateGoogleAdsCustomerUpdate', 'googleAdsCustomerUpdateRequest', googleAdsCustomerUpdateRequest)
            const localVarPath = `/v2/integrations/google_ads/customers/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsCustomerUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Google Ads Group
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {GoogleAdsGroupUpdateRequest} googleAdsGroupUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoogleAdsGroup: async (customerId: string, campaignId: string, groupId: string, workspaceId: string, googleAdsGroupUpdateRequest: GoogleAdsGroupUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateGoogleAdsGroup', 'customerId', customerId)
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('updateGoogleAdsGroup', 'campaignId', campaignId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGoogleAdsGroup', 'groupId', groupId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateGoogleAdsGroup', 'workspaceId', workspaceId)
            // verify required parameter 'googleAdsGroupUpdateRequest' is not null or undefined
            assertParamExists('updateGoogleAdsGroup', 'googleAdsGroupUpdateRequest', googleAdsGroupUpdateRequest)
            const localVarPath = `/v2/integrations/google_ads/groups/{customer_id}/{campaign_id}/{group_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleAdsGroupUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleAdsApi - functional programming interface
 * @export
 */
export const GoogleAdsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoogleAdsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Keyword To Group
         * @param {string} workspaceId 
         * @param {GoogleAdsKeywordAddRequest} googleAdsKeywordAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addKeywordToGroup(workspaceId: string, googleAdsKeywordAddRequest: GoogleAdsKeywordAddRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addKeywordToGroup(workspaceId, googleAdsKeywordAddRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.addKeywordToGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Analyze Not Assigned Keywords
         * @param {string} workspaceId 
         * @param {GoogleAdsAnalyzeKeywordsRequest} googleAdsAnalyzeKeywordsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzeNotAssignedKeywords(workspaceId: string, googleAdsAnalyzeKeywordsRequest: GoogleAdsAnalyzeKeywordsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeNotAssignedKeywords(workspaceId, googleAdsAnalyzeKeywordsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.analyzeNotAssignedKeywords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Google Ads Campaigns
         * @param {string} workspaceId 
         * @param {GoogleAdsCampaignsSearchRequest} googleAdsCampaignsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoogleAdsCampaigns(workspaceId: string, googleAdsCampaignsSearchRequest: GoogleAdsCampaignsSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GoogleAdsCampaignResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoogleAdsCampaigns(workspaceId, googleAdsCampaignsSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.getGoogleAdsCampaigns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Google Ads Customers
         * @param {string} workspaceId 
         * @param {GoogleAdsCustomersSearchRequest} googleAdsCustomersSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoogleAdsCustomers(workspaceId: string, googleAdsCustomersSearchRequest: GoogleAdsCustomersSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleAdsCustomersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoogleAdsCustomers(workspaceId, googleAdsCustomersSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.getGoogleAdsCustomers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Google Ads Groups
         * @param {string} workspaceId 
         * @param {GoogleAdsGroupsSearchRequest} googleAdsGroupsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoogleAdsGroups(workspaceId: string, googleAdsGroupsSearchRequest: GoogleAdsGroupsSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GoogleAdsGroupResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoogleAdsGroups(workspaceId, googleAdsGroupsSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.getGoogleAdsGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Recommendations
         * @param {string} workspaceId 
         * @param {GoogleAdsRecommendationsRequest} googleAdsRecommendationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendations(workspaceId: string, googleAdsRecommendationsRequest: GoogleAdsRecommendationsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GoogleAdsKeywordRecommendation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendations(workspaceId, googleAdsRecommendationsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.getRecommendations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Import Google Ads Campaigns
         * @param {string} workspaceId 
         * @param {GoogleAdsCampaignsSearchRequest} googleAdsCampaignsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importGoogleAdsCampaigns(workspaceId: string, googleAdsCampaignsSearchRequest: GoogleAdsCampaignsSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleAdsCampaignsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importGoogleAdsCampaigns(workspaceId, googleAdsCampaignsSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.importGoogleAdsCampaigns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Import Google Ads Customers
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importGoogleAdsCustomers(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleAdsCustomersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importGoogleAdsCustomers(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.importGoogleAdsCustomers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Import Google Ads Groups
         * @param {string} workspaceId 
         * @param {GoogleAdsGroupsSearchRequest} googleAdsGroupsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importGoogleAdsGroups(workspaceId: string, googleAdsGroupsSearchRequest: GoogleAdsGroupsSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleAdsGroupsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importGoogleAdsGroups(workspaceId, googleAdsGroupsSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.importGoogleAdsGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove Keyword From Group
         * @param {string} workspaceId 
         * @param {GoogleAdsKeywordRemoveRequest} googleAdsKeywordRemoveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeKeywordFromGroup(workspaceId: string, googleAdsKeywordRemoveRequest: GoogleAdsKeywordRemoveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeKeywordFromGroup(workspaceId, googleAdsKeywordRemoveRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.removeKeywordFromGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Google Ads Campaign
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} workspaceId 
         * @param {GoogleAdsCampaignUpdateRequest} googleAdsCampaignUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGoogleAdsCampaign(customerId: string, campaignId: string, workspaceId: string, googleAdsCampaignUpdateRequest: GoogleAdsCampaignUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleAdsCampaignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGoogleAdsCampaign(customerId, campaignId, workspaceId, googleAdsCampaignUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.updateGoogleAdsCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Google Ads Customer Update
         * @param {string} customerId 
         * @param {string} workspaceId 
         * @param {GoogleAdsCustomerUpdateRequest} googleAdsCustomerUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGoogleAdsCustomerUpdate(customerId: string, workspaceId: string, googleAdsCustomerUpdateRequest: GoogleAdsCustomerUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleAdsCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGoogleAdsCustomerUpdate(customerId, workspaceId, googleAdsCustomerUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.updateGoogleAdsCustomerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Google Ads Group
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {GoogleAdsGroupUpdateRequest} googleAdsGroupUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGoogleAdsGroup(customerId: string, campaignId: string, groupId: string, workspaceId: string, googleAdsGroupUpdateRequest: GoogleAdsGroupUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleAdsGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGoogleAdsGroup(customerId, campaignId, groupId, workspaceId, googleAdsGroupUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleAdsApi.updateGoogleAdsGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GoogleAdsApi - factory interface
 * @export
 */
export const GoogleAdsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoogleAdsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Keyword To Group
         * @param {GoogleAdsApiAddKeywordToGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addKeywordToGroup(requestParameters: GoogleAdsApiAddKeywordToGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.addKeywordToGroup(requestParameters.workspaceId, requestParameters.googleAdsKeywordAddRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Analyze Not Assigned Keywords
         * @param {GoogleAdsApiAnalyzeNotAssignedKeywordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeNotAssignedKeywords(requestParameters: GoogleAdsApiAnalyzeNotAssignedKeywordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.analyzeNotAssignedKeywords(requestParameters.workspaceId, requestParameters.googleAdsAnalyzeKeywordsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Google Ads Campaigns
         * @param {GoogleAdsApiGetGoogleAdsCampaignsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoogleAdsCampaigns(requestParameters: GoogleAdsApiGetGoogleAdsCampaignsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GoogleAdsCampaignResponse>> {
            return localVarFp.getGoogleAdsCampaigns(requestParameters.workspaceId, requestParameters.googleAdsCampaignsSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Google Ads Customers
         * @param {GoogleAdsApiGetGoogleAdsCustomersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoogleAdsCustomers(requestParameters: GoogleAdsApiGetGoogleAdsCustomersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCustomersResponse> {
            return localVarFp.getGoogleAdsCustomers(requestParameters.workspaceId, requestParameters.googleAdsCustomersSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Google Ads Groups
         * @param {GoogleAdsApiGetGoogleAdsGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoogleAdsGroups(requestParameters: GoogleAdsApiGetGoogleAdsGroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GoogleAdsGroupResponse>> {
            return localVarFp.getGoogleAdsGroups(requestParameters.workspaceId, requestParameters.googleAdsGroupsSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Recommendations
         * @param {GoogleAdsApiGetRecommendationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendations(requestParameters: GoogleAdsApiGetRecommendationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GoogleAdsKeywordRecommendation>> {
            return localVarFp.getRecommendations(requestParameters.workspaceId, requestParameters.googleAdsRecommendationsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import Google Ads Campaigns
         * @param {GoogleAdsApiImportGoogleAdsCampaignsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGoogleAdsCampaigns(requestParameters: GoogleAdsApiImportGoogleAdsCampaignsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCampaignsResponse> {
            return localVarFp.importGoogleAdsCampaigns(requestParameters.workspaceId, requestParameters.googleAdsCampaignsSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import Google Ads Customers
         * @param {GoogleAdsApiImportGoogleAdsCustomersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGoogleAdsCustomers(requestParameters: GoogleAdsApiImportGoogleAdsCustomersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCustomersResponse> {
            return localVarFp.importGoogleAdsCustomers(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import Google Ads Groups
         * @param {GoogleAdsApiImportGoogleAdsGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGoogleAdsGroups(requestParameters: GoogleAdsApiImportGoogleAdsGroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsGroupsResponse> {
            return localVarFp.importGoogleAdsGroups(requestParameters.workspaceId, requestParameters.googleAdsGroupsSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Keyword From Group
         * @param {GoogleAdsApiRemoveKeywordFromGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeKeywordFromGroup(requestParameters: GoogleAdsApiRemoveKeywordFromGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.removeKeywordFromGroup(requestParameters.workspaceId, requestParameters.googleAdsKeywordRemoveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Google Ads Campaign
         * @param {GoogleAdsApiUpdateGoogleAdsCampaignRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoogleAdsCampaign(requestParameters: GoogleAdsApiUpdateGoogleAdsCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCampaignResponse> {
            return localVarFp.updateGoogleAdsCampaign(requestParameters.customerId, requestParameters.campaignId, requestParameters.workspaceId, requestParameters.googleAdsCampaignUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Google Ads Customer Update
         * @param {GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoogleAdsCustomerUpdate(requestParameters: GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCustomerResponse> {
            return localVarFp.updateGoogleAdsCustomerUpdate(requestParameters.customerId, requestParameters.workspaceId, requestParameters.googleAdsCustomerUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Google Ads Group
         * @param {GoogleAdsApiUpdateGoogleAdsGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoogleAdsGroup(requestParameters: GoogleAdsApiUpdateGoogleAdsGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsGroupResponse> {
            return localVarFp.updateGoogleAdsGroup(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, requestParameters.googleAdsGroupUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoogleAdsApi - interface
 * @export
 * @interface GoogleAdsApi
 */
export interface GoogleAdsApiInterface {
    /**
     * 
     * @summary Add Keyword To Group
     * @param {GoogleAdsApiAddKeywordToGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    addKeywordToGroup(requestParameters: GoogleAdsApiAddKeywordToGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Analyze Not Assigned Keywords
     * @param {GoogleAdsApiAnalyzeNotAssignedKeywordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    analyzeNotAssignedKeywords(requestParameters: GoogleAdsApiAnalyzeNotAssignedKeywordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Get Google Ads Campaigns
     * @param {GoogleAdsApiGetGoogleAdsCampaignsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    getGoogleAdsCampaigns(requestParameters: GoogleAdsApiGetGoogleAdsCampaignsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GoogleAdsCampaignResponse>>;

    /**
     * 
     * @summary Get Google Ads Customers
     * @param {GoogleAdsApiGetGoogleAdsCustomersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    getGoogleAdsCustomers(requestParameters: GoogleAdsApiGetGoogleAdsCustomersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCustomersResponse>;

    /**
     * 
     * @summary Get Google Ads Groups
     * @param {GoogleAdsApiGetGoogleAdsGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    getGoogleAdsGroups(requestParameters: GoogleAdsApiGetGoogleAdsGroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GoogleAdsGroupResponse>>;

    /**
     * 
     * @summary Get Recommendations
     * @param {GoogleAdsApiGetRecommendationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    getRecommendations(requestParameters: GoogleAdsApiGetRecommendationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GoogleAdsKeywordRecommendation>>;

    /**
     * 
     * @summary Import Google Ads Campaigns
     * @param {GoogleAdsApiImportGoogleAdsCampaignsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    importGoogleAdsCampaigns(requestParameters: GoogleAdsApiImportGoogleAdsCampaignsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCampaignsResponse>;

    /**
     * 
     * @summary Import Google Ads Customers
     * @param {GoogleAdsApiImportGoogleAdsCustomersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    importGoogleAdsCustomers(requestParameters: GoogleAdsApiImportGoogleAdsCustomersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCustomersResponse>;

    /**
     * 
     * @summary Import Google Ads Groups
     * @param {GoogleAdsApiImportGoogleAdsGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    importGoogleAdsGroups(requestParameters: GoogleAdsApiImportGoogleAdsGroupsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsGroupsResponse>;

    /**
     * 
     * @summary Remove Keyword From Group
     * @param {GoogleAdsApiRemoveKeywordFromGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    removeKeywordFromGroup(requestParameters: GoogleAdsApiRemoveKeywordFromGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Update Google Ads Campaign
     * @param {GoogleAdsApiUpdateGoogleAdsCampaignRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    updateGoogleAdsCampaign(requestParameters: GoogleAdsApiUpdateGoogleAdsCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCampaignResponse>;

    /**
     * 
     * @summary Update Google Ads Customer Update
     * @param {GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    updateGoogleAdsCustomerUpdate(requestParameters: GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsCustomerResponse>;

    /**
     * 
     * @summary Update Google Ads Group
     * @param {GoogleAdsApiUpdateGoogleAdsGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApiInterface
     */
    updateGoogleAdsGroup(requestParameters: GoogleAdsApiUpdateGoogleAdsGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleAdsGroupResponse>;

}

/**
 * Request parameters for addKeywordToGroup operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiAddKeywordToGroupRequest
 */
export interface GoogleAdsApiAddKeywordToGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiAddKeywordToGroup
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsKeywordAddRequest}
     * @memberof GoogleAdsApiAddKeywordToGroup
     */
    readonly googleAdsKeywordAddRequest: GoogleAdsKeywordAddRequest
}

/**
 * Request parameters for analyzeNotAssignedKeywords operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiAnalyzeNotAssignedKeywordsRequest
 */
export interface GoogleAdsApiAnalyzeNotAssignedKeywordsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiAnalyzeNotAssignedKeywords
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsAnalyzeKeywordsRequest}
     * @memberof GoogleAdsApiAnalyzeNotAssignedKeywords
     */
    readonly googleAdsAnalyzeKeywordsRequest: GoogleAdsAnalyzeKeywordsRequest
}

/**
 * Request parameters for getGoogleAdsCampaigns operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiGetGoogleAdsCampaignsRequest
 */
export interface GoogleAdsApiGetGoogleAdsCampaignsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiGetGoogleAdsCampaigns
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsCampaignsSearchRequest}
     * @memberof GoogleAdsApiGetGoogleAdsCampaigns
     */
    readonly googleAdsCampaignsSearchRequest: GoogleAdsCampaignsSearchRequest
}

/**
 * Request parameters for getGoogleAdsCustomers operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiGetGoogleAdsCustomersRequest
 */
export interface GoogleAdsApiGetGoogleAdsCustomersRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiGetGoogleAdsCustomers
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsCustomersSearchRequest}
     * @memberof GoogleAdsApiGetGoogleAdsCustomers
     */
    readonly googleAdsCustomersSearchRequest: GoogleAdsCustomersSearchRequest
}

/**
 * Request parameters for getGoogleAdsGroups operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiGetGoogleAdsGroupsRequest
 */
export interface GoogleAdsApiGetGoogleAdsGroupsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiGetGoogleAdsGroups
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsGroupsSearchRequest}
     * @memberof GoogleAdsApiGetGoogleAdsGroups
     */
    readonly googleAdsGroupsSearchRequest: GoogleAdsGroupsSearchRequest
}

/**
 * Request parameters for getRecommendations operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiGetRecommendationsRequest
 */
export interface GoogleAdsApiGetRecommendationsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiGetRecommendations
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsRecommendationsRequest}
     * @memberof GoogleAdsApiGetRecommendations
     */
    readonly googleAdsRecommendationsRequest: GoogleAdsRecommendationsRequest
}

/**
 * Request parameters for importGoogleAdsCampaigns operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiImportGoogleAdsCampaignsRequest
 */
export interface GoogleAdsApiImportGoogleAdsCampaignsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiImportGoogleAdsCampaigns
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsCampaignsSearchRequest}
     * @memberof GoogleAdsApiImportGoogleAdsCampaigns
     */
    readonly googleAdsCampaignsSearchRequest: GoogleAdsCampaignsSearchRequest
}

/**
 * Request parameters for importGoogleAdsCustomers operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiImportGoogleAdsCustomersRequest
 */
export interface GoogleAdsApiImportGoogleAdsCustomersRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiImportGoogleAdsCustomers
     */
    readonly workspaceId: string
}

/**
 * Request parameters for importGoogleAdsGroups operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiImportGoogleAdsGroupsRequest
 */
export interface GoogleAdsApiImportGoogleAdsGroupsRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiImportGoogleAdsGroups
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsGroupsSearchRequest}
     * @memberof GoogleAdsApiImportGoogleAdsGroups
     */
    readonly googleAdsGroupsSearchRequest: GoogleAdsGroupsSearchRequest
}

/**
 * Request parameters for removeKeywordFromGroup operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiRemoveKeywordFromGroupRequest
 */
export interface GoogleAdsApiRemoveKeywordFromGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiRemoveKeywordFromGroup
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsKeywordRemoveRequest}
     * @memberof GoogleAdsApiRemoveKeywordFromGroup
     */
    readonly googleAdsKeywordRemoveRequest: GoogleAdsKeywordRemoveRequest
}

/**
 * Request parameters for updateGoogleAdsCampaign operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiUpdateGoogleAdsCampaignRequest
 */
export interface GoogleAdsApiUpdateGoogleAdsCampaignRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsCampaign
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsCampaign
     */
    readonly campaignId: string

    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsCampaign
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsCampaignUpdateRequest}
     * @memberof GoogleAdsApiUpdateGoogleAdsCampaign
     */
    readonly googleAdsCampaignUpdateRequest: GoogleAdsCampaignUpdateRequest
}

/**
 * Request parameters for updateGoogleAdsCustomerUpdate operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest
 */
export interface GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsCustomerUpdate
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsCustomerUpdate
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsCustomerUpdateRequest}
     * @memberof GoogleAdsApiUpdateGoogleAdsCustomerUpdate
     */
    readonly googleAdsCustomerUpdateRequest: GoogleAdsCustomerUpdateRequest
}

/**
 * Request parameters for updateGoogleAdsGroup operation in GoogleAdsApi.
 * @export
 * @interface GoogleAdsApiUpdateGoogleAdsGroupRequest
 */
export interface GoogleAdsApiUpdateGoogleAdsGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsGroup
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsGroup
     */
    readonly campaignId: string

    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsGroup
     */
    readonly groupId: string

    /**
     * 
     * @type {string}
     * @memberof GoogleAdsApiUpdateGoogleAdsGroup
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GoogleAdsGroupUpdateRequest}
     * @memberof GoogleAdsApiUpdateGoogleAdsGroup
     */
    readonly googleAdsGroupUpdateRequest: GoogleAdsGroupUpdateRequest
}

/**
 * GoogleAdsApi - object-oriented interface
 * @export
 * @class GoogleAdsApi
 * @extends {BaseAPI}
 */
export class GoogleAdsApi extends BaseAPI implements GoogleAdsApiInterface {
    /**
     * 
     * @summary Add Keyword To Group
     * @param {GoogleAdsApiAddKeywordToGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public addKeywordToGroup(requestParameters: GoogleAdsApiAddKeywordToGroupRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).addKeywordToGroup(requestParameters.workspaceId, requestParameters.googleAdsKeywordAddRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Analyze Not Assigned Keywords
     * @param {GoogleAdsApiAnalyzeNotAssignedKeywordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public analyzeNotAssignedKeywords(requestParameters: GoogleAdsApiAnalyzeNotAssignedKeywordsRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).analyzeNotAssignedKeywords(requestParameters.workspaceId, requestParameters.googleAdsAnalyzeKeywordsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Google Ads Campaigns
     * @param {GoogleAdsApiGetGoogleAdsCampaignsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public getGoogleAdsCampaigns(requestParameters: GoogleAdsApiGetGoogleAdsCampaignsRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).getGoogleAdsCampaigns(requestParameters.workspaceId, requestParameters.googleAdsCampaignsSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Google Ads Customers
     * @param {GoogleAdsApiGetGoogleAdsCustomersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public getGoogleAdsCustomers(requestParameters: GoogleAdsApiGetGoogleAdsCustomersRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).getGoogleAdsCustomers(requestParameters.workspaceId, requestParameters.googleAdsCustomersSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Google Ads Groups
     * @param {GoogleAdsApiGetGoogleAdsGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public getGoogleAdsGroups(requestParameters: GoogleAdsApiGetGoogleAdsGroupsRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).getGoogleAdsGroups(requestParameters.workspaceId, requestParameters.googleAdsGroupsSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Recommendations
     * @param {GoogleAdsApiGetRecommendationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public getRecommendations(requestParameters: GoogleAdsApiGetRecommendationsRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).getRecommendations(requestParameters.workspaceId, requestParameters.googleAdsRecommendationsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import Google Ads Campaigns
     * @param {GoogleAdsApiImportGoogleAdsCampaignsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public importGoogleAdsCampaigns(requestParameters: GoogleAdsApiImportGoogleAdsCampaignsRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).importGoogleAdsCampaigns(requestParameters.workspaceId, requestParameters.googleAdsCampaignsSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import Google Ads Customers
     * @param {GoogleAdsApiImportGoogleAdsCustomersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public importGoogleAdsCustomers(requestParameters: GoogleAdsApiImportGoogleAdsCustomersRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).importGoogleAdsCustomers(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import Google Ads Groups
     * @param {GoogleAdsApiImportGoogleAdsGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public importGoogleAdsGroups(requestParameters: GoogleAdsApiImportGoogleAdsGroupsRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).importGoogleAdsGroups(requestParameters.workspaceId, requestParameters.googleAdsGroupsSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Keyword From Group
     * @param {GoogleAdsApiRemoveKeywordFromGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public removeKeywordFromGroup(requestParameters: GoogleAdsApiRemoveKeywordFromGroupRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).removeKeywordFromGroup(requestParameters.workspaceId, requestParameters.googleAdsKeywordRemoveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Google Ads Campaign
     * @param {GoogleAdsApiUpdateGoogleAdsCampaignRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public updateGoogleAdsCampaign(requestParameters: GoogleAdsApiUpdateGoogleAdsCampaignRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).updateGoogleAdsCampaign(requestParameters.customerId, requestParameters.campaignId, requestParameters.workspaceId, requestParameters.googleAdsCampaignUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Google Ads Customer Update
     * @param {GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public updateGoogleAdsCustomerUpdate(requestParameters: GoogleAdsApiUpdateGoogleAdsCustomerUpdateRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).updateGoogleAdsCustomerUpdate(requestParameters.customerId, requestParameters.workspaceId, requestParameters.googleAdsCustomerUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Google Ads Group
     * @param {GoogleAdsApiUpdateGoogleAdsGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAdsApi
     */
    public updateGoogleAdsGroup(requestParameters: GoogleAdsApiUpdateGoogleAdsGroupRequest, options?: RawAxiosRequestConfig) {
        return GoogleAdsApiFp(this.configuration).updateGoogleAdsGroup(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, requestParameters.googleAdsGroupUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/monitoring/health/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.health']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: RawAxiosRequestConfig): AxiosPromise<Health> {
            return localVarFp.health(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - interface
 * @export
 * @interface HealthApi
 */
export interface HealthApiInterface {
    /**
     * 
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiInterface
     */
    health(options?: RawAxiosRequestConfig): AxiosPromise<Health>;

}

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI implements HealthApiInterface {
    /**
     * 
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public health(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).health(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HubSpotApi - axios parameter creator
 * @export
 */
export const HubSpotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Actors
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActors: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getActors', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/hubspot/actors/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HubSpotApi - functional programming interface
 * @export
 */
export const HubSpotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HubSpotApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Actors
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActors(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HubSpotActorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActors(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HubSpotApi.getActors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HubSpotApi - factory interface
 * @export
 */
export const HubSpotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HubSpotApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Actors
         * @param {HubSpotApiGetActorsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActors(requestParameters: HubSpotApiGetActorsRequest, options?: RawAxiosRequestConfig): AxiosPromise<HubSpotActorsResponse> {
            return localVarFp.getActors(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HubSpotApi - interface
 * @export
 * @interface HubSpotApi
 */
export interface HubSpotApiInterface {
    /**
     * 
     * @summary Get Actors
     * @param {HubSpotApiGetActorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubSpotApiInterface
     */
    getActors(requestParameters: HubSpotApiGetActorsRequest, options?: RawAxiosRequestConfig): AxiosPromise<HubSpotActorsResponse>;

}

/**
 * Request parameters for getActors operation in HubSpotApi.
 * @export
 * @interface HubSpotApiGetActorsRequest
 */
export interface HubSpotApiGetActorsRequest {
    /**
     * 
     * @type {string}
     * @memberof HubSpotApiGetActors
     */
    readonly workspaceId: string
}

/**
 * HubSpotApi - object-oriented interface
 * @export
 * @class HubSpotApi
 * @extends {BaseAPI}
 */
export class HubSpotApi extends BaseAPI implements HubSpotApiInterface {
    /**
     * 
     * @summary Get Actors
     * @param {HubSpotApiGetActorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubSpotApi
     */
    public getActors(requestParameters: HubSpotApiGetActorsRequest, options?: RawAxiosRequestConfig) {
        return HubSpotApiFp(this.configuration).getActors(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Convert Image
         * @param {string} workspaceId 
         * @param {ImageConvertRequest} imageConvertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertImage: async (workspaceId: string, imageConvertRequest: ImageConvertRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('convertImage', 'workspaceId', workspaceId)
            // verify required parameter 'imageConvertRequest' is not null or undefined
            assertParamExists('convertImage', 'imageConvertRequest', imageConvertRequest)
            const localVarPath = `/v2/images/convert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageConvertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Screenshot
         * @param {string} workspaceId 
         * @param {ScreenshotRequest} screenshotRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenshot: async (workspaceId: string, screenshotRequest: ScreenshotRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScreenshot', 'workspaceId', workspaceId)
            // verify required parameter 'screenshotRequest' is not null or undefined
            assertParamExists('getScreenshot', 'screenshotRequest', screenshotRequest)
            const localVarPath = `/v2/images/screenshot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(screenshotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Optimize Image
         * @param {string} workspaceId 
         * @param {ImageOptimizeRequest} imageOptimizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optimizeImage: async (workspaceId: string, imageOptimizeRequest: ImageOptimizeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('optimizeImage', 'workspaceId', workspaceId)
            // verify required parameter 'imageOptimizeRequest' is not null or undefined
            assertParamExists('optimizeImage', 'imageOptimizeRequest', imageOptimizeRequest)
            const localVarPath = `/v2/images/optimize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageOptimizeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Convert Image
         * @param {string} workspaceId 
         * @param {ImageConvertRequest} imageConvertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async convertImage(workspaceId: string, imageConvertRequest: ImageConvertRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.convertImage(workspaceId, imageConvertRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.convertImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Screenshot
         * @param {string} workspaceId 
         * @param {ScreenshotRequest} screenshotRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreenshot(workspaceId: string, screenshotRequest: ScreenshotRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScreenshotResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreenshot(workspaceId, screenshotRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.getScreenshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Optimize Image
         * @param {string} workspaceId 
         * @param {ImageOptimizeRequest} imageOptimizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async optimizeImage(workspaceId: string, imageOptimizeRequest: ImageOptimizeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.optimizeImage(workspaceId, imageOptimizeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.optimizeImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Convert Image
         * @param {ImagesApiConvertImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertImage(requestParameters: ImagesApiConvertImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.convertImage(requestParameters.workspaceId, requestParameters.imageConvertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Screenshot
         * @param {ImagesApiGetScreenshotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenshot(requestParameters: ImagesApiGetScreenshotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScreenshotResponse> {
            return localVarFp.getScreenshot(requestParameters.workspaceId, requestParameters.screenshotRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Optimize Image
         * @param {ImagesApiOptimizeImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        optimizeImage(requestParameters: ImagesApiOptimizeImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.optimizeImage(requestParameters.workspaceId, requestParameters.imageOptimizeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - interface
 * @export
 * @interface ImagesApi
 */
export interface ImagesApiInterface {
    /**
     * 
     * @summary Convert Image
     * @param {ImagesApiConvertImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApiInterface
     */
    convertImage(requestParameters: ImagesApiConvertImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

    /**
     * 
     * @summary Get Screenshot
     * @param {ImagesApiGetScreenshotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApiInterface
     */
    getScreenshot(requestParameters: ImagesApiGetScreenshotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScreenshotResponse>;

    /**
     * 
     * @summary Optimize Image
     * @param {ImagesApiOptimizeImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApiInterface
     */
    optimizeImage(requestParameters: ImagesApiOptimizeImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

}

/**
 * Request parameters for convertImage operation in ImagesApi.
 * @export
 * @interface ImagesApiConvertImageRequest
 */
export interface ImagesApiConvertImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImagesApiConvertImage
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ImageConvertRequest}
     * @memberof ImagesApiConvertImage
     */
    readonly imageConvertRequest: ImageConvertRequest
}

/**
 * Request parameters for getScreenshot operation in ImagesApi.
 * @export
 * @interface ImagesApiGetScreenshotRequest
 */
export interface ImagesApiGetScreenshotRequest {
    /**
     * 
     * @type {string}
     * @memberof ImagesApiGetScreenshot
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ScreenshotRequest}
     * @memberof ImagesApiGetScreenshot
     */
    readonly screenshotRequest: ScreenshotRequest
}

/**
 * Request parameters for optimizeImage operation in ImagesApi.
 * @export
 * @interface ImagesApiOptimizeImageRequest
 */
export interface ImagesApiOptimizeImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImagesApiOptimizeImage
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ImageOptimizeRequest}
     * @memberof ImagesApiOptimizeImage
     */
    readonly imageOptimizeRequest: ImageOptimizeRequest
}

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI implements ImagesApiInterface {
    /**
     * 
     * @summary Convert Image
     * @param {ImagesApiConvertImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public convertImage(requestParameters: ImagesApiConvertImageRequest, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).convertImage(requestParameters.workspaceId, requestParameters.imageConvertRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Screenshot
     * @param {ImagesApiGetScreenshotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public getScreenshot(requestParameters: ImagesApiGetScreenshotRequest, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).getScreenshot(requestParameters.workspaceId, requestParameters.screenshotRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Optimize Image
     * @param {ImagesApiOptimizeImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public optimizeImage(requestParameters: ImagesApiOptimizeImageRequest, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).optimizeImage(requestParameters.workspaceId, requestParameters.imageOptimizeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InstagramApi - axios parameter creator
 * @export
 */
export const InstagramApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Profile Information
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInformation: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getProfileInformation', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/instagram/profile_information`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstagramApi - functional programming interface
 * @export
 */
export const InstagramApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InstagramApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Profile Information
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileInformation(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstagramProfileInformationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileInformation(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstagramApi.getProfileInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InstagramApi - factory interface
 * @export
 */
export const InstagramApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InstagramApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Profile Information
         * @param {InstagramApiGetProfileInformationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInformation(requestParameters: InstagramApiGetProfileInformationRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstagramProfileInformationResponse> {
            return localVarFp.getProfileInformation(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InstagramApi - interface
 * @export
 * @interface InstagramApi
 */
export interface InstagramApiInterface {
    /**
     * 
     * @summary Get Profile Information
     * @param {InstagramApiGetProfileInformationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstagramApiInterface
     */
    getProfileInformation(requestParameters: InstagramApiGetProfileInformationRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstagramProfileInformationResponse>;

}

/**
 * Request parameters for getProfileInformation operation in InstagramApi.
 * @export
 * @interface InstagramApiGetProfileInformationRequest
 */
export interface InstagramApiGetProfileInformationRequest {
    /**
     * 
     * @type {string}
     * @memberof InstagramApiGetProfileInformation
     */
    readonly workspaceId: string
}

/**
 * InstagramApi - object-oriented interface
 * @export
 * @class InstagramApi
 * @extends {BaseAPI}
 */
export class InstagramApi extends BaseAPI implements InstagramApiInterface {
    /**
     * 
     * @summary Get Profile Information
     * @param {InstagramApiGetProfileInformationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstagramApi
     */
    public getProfileInformation(requestParameters: InstagramApiGetProfileInformationRequest, options?: RawAxiosRequestConfig) {
        return InstagramApiFp(this.configuration).getProfileInformation(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IntegrationsApi - axios parameter creator
 * @export
 */
export const IntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Integration
         * @param {IntegrationSlug} slug 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration: async (slug: IntegrationSlug, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('createIntegration', 'slug', slug)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createIntegration', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/{slug}/integrate`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Data Request
         * @param {CustomerDataRequestPayload} customerDataRequestPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDataRequest: async (customerDataRequestPayload: CustomerDataRequestPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerDataRequestPayload' is not null or undefined
            assertParamExists('customerDataRequest', 'customerDataRequestPayload', customerDataRequestPayload)
            const localVarPath = `/v2/integrations/shopify/webhooks/customers/data_request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerDataRequestPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Redact
         * @param {CustomerRedactPayload} customerRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerRedact: async (customerRedactPayload: CustomerRedactPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerRedactPayload' is not null or undefined
            assertParamExists('customerRedact', 'customerRedactPayload', customerRedactPayload)
            const localVarPath = `/v2/integrations/shopify/webhooks/customers/redact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerRedactPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Integration
         * @param {IntegrationSlug} slug 
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration: async (slug: IntegrationSlug, integrationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('deleteIntegration', 'slug', slug)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('deleteIntegration', 'integrationId', integrationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteIntegration', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/{slug}/{integration_id}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)))
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Actors
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActors: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getActors', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/hubspot/actors/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All Integrations
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllIntegrations: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getAllIntegrations', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Calendars
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendars: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getCalendars', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/google/calendar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Hubspot Custom Channel Connect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHubspotCustomChannelConnect: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/integrations/hubspot_custom_channel_connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Integration
         * @param {IntegrationSlug} slug 
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration: async (slug: IntegrationSlug, integrationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getIntegration', 'slug', slug)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('getIntegration', 'integrationId', integrationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getIntegration', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/{slug}/{integration_id}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)))
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Picker Token
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPickerToken: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getPickerToken', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/google/picker_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Profile Information
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInformation: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getProfileInformation', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/instagram/profile_information`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Sheets
         * @param {string} documentId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSheets: async (documentId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getSheets', 'documentId', documentId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSheets', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/google/sheets/{document_id}`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Shopify
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopify: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getShopify', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/shopify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Slack Channels
         * @param {string} slackTeamId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackChannels: async (slackTeamId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slackTeamId' is not null or undefined
            assertParamExists('getSlackChannels', 'slackTeamId', slackTeamId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSlackChannels', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/slack/{slack_team_id}/channels`
                .replace(`{${"slack_team_id"}}`, encodeURIComponent(String(slackTeamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Slack Workspaces
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackWorkspaces: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSlackWorkspaces', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/slack/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Wordpress Post Categories
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostCategories: async (integrationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('getWordpressPostCategories', 'integrationId', integrationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWordpressPostCategories', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/wordpress/{integration_id}/categories`
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Wordpress Post Tags
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostTags: async (integrationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('getWordpressPostTags', 'integrationId', integrationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWordpressPostTags', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/wordpress/{integration_id}/tags`
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Wordpress Sites
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressSites: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWordpressSites', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/wordpress/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Integration Callback
         * @param {IntegrationSlug} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationCallback: async (slug: IntegrationSlug, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('integrationCallback', 'slug', slug)
            const localVarPath = `/v2/integrations/{slug}/callback`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Integrations
         * @param {IntegrationSlug} slug 
         * @param {string} workspaceId 
         * @param {IntegrationSearchRequest} integrationSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchIntegrations: async (slug: IntegrationSlug, workspaceId: string, integrationSearchRequest: IntegrationSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('searchIntegrations', 'slug', slug)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchIntegrations', 'workspaceId', workspaceId)
            // verify required parameter 'integrationSearchRequest' is not null or undefined
            assertParamExists('searchIntegrations', 'integrationSearchRequest', integrationSearchRequest)
            const localVarPath = `/v2/integrations/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(integrationSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Shop Redact
         * @param {ShopRedactPayload} shopRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopRedact: async (shopRedactPayload: ShopRedactPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shopRedactPayload' is not null or undefined
            assertParamExists('shopRedact', 'shopRedactPayload', shopRedactPayload)
            const localVarPath = `/v2/integrations/shopify/webhooks/shop/redact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopRedactPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle subscription cancellation webhooks from Shopify.
         * @summary Subscription Cancel
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionCancel: async (xShopifyHmacSha256?: string, xShopifyTopic?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/integrations/shopify/webhooks/billing/subscription_cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xShopifyHmacSha256 != null) {
                localVarHeaderParameter['x-shopify-hmac-sha256'] = String(xShopifyHmacSha256);
            }
            if (xShopifyTopic != null) {
                localVarHeaderParameter['x-shopify-topic'] = String(xShopifyTopic);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
         * @summary Subscription Update
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionUpdate: async (xShopifyHmacSha256?: string, xShopifyTopic?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/integrations/shopify/webhooks/billing/subscription_update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xShopifyHmacSha256 != null) {
                localVarHeaderParameter['x-shopify-hmac-sha256'] = String(xShopifyHmacSha256);
            }
            if (xShopifyTopic != null) {
                localVarHeaderParameter['x-shopify-topic'] = String(xShopifyTopic);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Admin Consent
         * @param {string} workspaceId 
         * @param {string} integrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdminConsent: async (workspaceId: string, integrationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateAdminConsent', 'workspaceId', workspaceId)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('updateAdminConsent', 'integrationId', integrationId)
            const localVarPath = `/v2/integrations/microsoft_entra_id/admin_consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (integrationId !== undefined) {
                localVarQueryParameter['integration_id'] = integrationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Integration
         * @param {IntegrationSlug} slug 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIntegration(slug: IntegrationSlug, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationFlowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIntegration(slug, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.createIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Data Request
         * @param {CustomerDataRequestPayload} customerDataRequestPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerDataRequest(customerDataRequestPayload: CustomerDataRequestPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerDataRequest(customerDataRequestPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.customerDataRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Redact
         * @param {CustomerRedactPayload} customerRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerRedact(customerRedactPayload: CustomerRedactPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerRedact(customerRedactPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.customerRedact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Integration
         * @param {IntegrationSlug} slug 
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIntegration(slug: IntegrationSlug, integrationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIntegration(slug, integrationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.deleteIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Actors
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActors(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HubSpotActorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActors(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getActors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All Integrations
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllIntegrations(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IntegrationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllIntegrations(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getAllIntegrations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Calendars
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalendars(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleCalendarsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalendars(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getCalendars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Hubspot Custom Channel Connect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHubspotCustomChannelConnect(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHubspotCustomChannelConnect(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getHubspotCustomChannelConnect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Integration
         * @param {IntegrationSlug} slug 
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegration(slug: IntegrationSlug, integrationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegration(slug, integrationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Picker Token
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPickerToken(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GooglePickerTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPickerToken(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getPickerToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Profile Information
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileInformation(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstagramProfileInformationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileInformation(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getProfileInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Sheets
         * @param {string} documentId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSheets(documentId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoogleSheetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSheets(documentId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getSheets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Shopify
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShopify(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopifyIntegrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShopify(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getShopify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Slack Channels
         * @param {string} slackTeamId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlackChannels(slackTeamId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SlackChannelResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlackChannels(slackTeamId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getSlackChannels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Slack Workspaces
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlackWorkspaces(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SlackWorkspaceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlackWorkspaces(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getSlackWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Wordpress Post Categories
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWordpressPostCategories(integrationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WordPressCategoryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWordpressPostCategories(integrationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getWordpressPostCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Wordpress Post Tags
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWordpressPostTags(integrationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WordPressTagsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWordpressPostTags(integrationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getWordpressPostTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Wordpress Sites
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWordpressSites(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WordPressSiteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWordpressSites(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getWordpressSites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Integration Callback
         * @param {IntegrationSlug} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationCallback(slug: IntegrationSlug, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationCallback(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Integrations
         * @param {IntegrationSlug} slug 
         * @param {string} workspaceId 
         * @param {IntegrationSearchRequest} integrationSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchIntegrations(slug: IntegrationSlug, workspaceId: string, integrationSearchRequest: IntegrationSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IntegrationDetailResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchIntegrations(slug, workspaceId, integrationSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.searchIntegrations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Shop Redact
         * @param {ShopRedactPayload} shopRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopRedact(shopRedactPayload: ShopRedactPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopRedact(shopRedactPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.shopRedact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle subscription cancellation webhooks from Shopify.
         * @summary Subscription Cancel
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionCancel(xShopifyHmacSha256?: string, xShopifyTopic?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionCancel(xShopifyHmacSha256, xShopifyTopic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.subscriptionCancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
         * @summary Subscription Update
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionUpdate(xShopifyHmacSha256?: string, xShopifyTopic?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionUpdate(xShopifyHmacSha256, xShopifyTopic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.subscriptionUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Admin Consent
         * @param {string} workspaceId 
         * @param {string} integrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAdminConsent(workspaceId: string, integrationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAdminConsent(workspaceId, integrationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.updateAdminConsent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Integration
         * @param {IntegrationsApiCreateIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration(requestParameters: IntegrationsApiCreateIntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationFlowResponse> {
            return localVarFp.createIntegration(requestParameters.slug, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Data Request
         * @param {IntegrationsApiCustomerDataRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDataRequest(requestParameters: IntegrationsApiCustomerDataRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.customerDataRequest(requestParameters.customerDataRequestPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Redact
         * @param {IntegrationsApiCustomerRedactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerRedact(requestParameters: IntegrationsApiCustomerRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.customerRedact(requestParameters.customerRedactPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Integration
         * @param {IntegrationsApiDeleteIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration(requestParameters: IntegrationsApiDeleteIntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteIntegration(requestParameters.slug, requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Actors
         * @param {IntegrationsApiGetActorsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActors(requestParameters: IntegrationsApiGetActorsRequest, options?: RawAxiosRequestConfig): AxiosPromise<HubSpotActorsResponse> {
            return localVarFp.getActors(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All Integrations
         * @param {IntegrationsApiGetAllIntegrationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllIntegrations(requestParameters: IntegrationsApiGetAllIntegrationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<IntegrationResponse>> {
            return localVarFp.getAllIntegrations(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Calendars
         * @param {IntegrationsApiGetCalendarsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalendars(requestParameters: IntegrationsApiGetCalendarsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleCalendarsResponse> {
            return localVarFp.getCalendars(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Hubspot Custom Channel Connect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHubspotCustomChannelConnect(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getHubspotCustomChannelConnect(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Integration
         * @param {IntegrationsApiGetIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration(requestParameters: IntegrationsApiGetIntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationDetailResponse> {
            return localVarFp.getIntegration(requestParameters.slug, requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Picker Token
         * @param {IntegrationsApiGetPickerTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPickerToken(requestParameters: IntegrationsApiGetPickerTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<GooglePickerTokenResponse> {
            return localVarFp.getPickerToken(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Profile Information
         * @param {IntegrationsApiGetProfileInformationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInformation(requestParameters: IntegrationsApiGetProfileInformationRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstagramProfileInformationResponse> {
            return localVarFp.getProfileInformation(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Sheets
         * @param {IntegrationsApiGetSheetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSheets(requestParameters: IntegrationsApiGetSheetsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleSheetsResponse> {
            return localVarFp.getSheets(requestParameters.documentId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Shopify
         * @param {IntegrationsApiGetShopifyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopify(requestParameters: IntegrationsApiGetShopifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ShopifyIntegrationResponse> {
            return localVarFp.getShopify(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Slack Channels
         * @param {IntegrationsApiGetSlackChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackChannels(requestParameters: IntegrationsApiGetSlackChannelsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackChannelResponse>> {
            return localVarFp.getSlackChannels(requestParameters.slackTeamId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Slack Workspaces
         * @param {IntegrationsApiGetSlackWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackWorkspaces(requestParameters: IntegrationsApiGetSlackWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackWorkspaceResponse>> {
            return localVarFp.getSlackWorkspaces(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Wordpress Post Categories
         * @param {IntegrationsApiGetWordpressPostCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostCategories(requestParameters: IntegrationsApiGetWordpressPostCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressCategoryResponse>> {
            return localVarFp.getWordpressPostCategories(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Wordpress Post Tags
         * @param {IntegrationsApiGetWordpressPostTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostTags(requestParameters: IntegrationsApiGetWordpressPostTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressTagsResponse>> {
            return localVarFp.getWordpressPostTags(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Wordpress Sites
         * @param {IntegrationsApiGetWordpressSitesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressSites(requestParameters: IntegrationsApiGetWordpressSitesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressSiteResponse>> {
            return localVarFp.getWordpressSites(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Integration Callback
         * @param {IntegrationsApiIntegrationCallbackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationCallback(requestParameters: IntegrationsApiIntegrationCallbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.integrationCallback(requestParameters.slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Integrations
         * @param {IntegrationsApiSearchIntegrationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchIntegrations(requestParameters: IntegrationsApiSearchIntegrationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<IntegrationDetailResponse>> {
            return localVarFp.searchIntegrations(requestParameters.slug, requestParameters.workspaceId, requestParameters.integrationSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Shop Redact
         * @param {IntegrationsApiShopRedactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopRedact(requestParameters: IntegrationsApiShopRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.shopRedact(requestParameters.shopRedactPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle subscription cancellation webhooks from Shopify.
         * @summary Subscription Cancel
         * @param {IntegrationsApiSubscriptionCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionCancel(requestParameters: IntegrationsApiSubscriptionCancelRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.subscriptionCancel(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
         * @summary Subscription Update
         * @param {IntegrationsApiSubscriptionUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionUpdate(requestParameters: IntegrationsApiSubscriptionUpdateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.subscriptionUpdate(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Admin Consent
         * @param {IntegrationsApiUpdateAdminConsentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdminConsent(requestParameters: IntegrationsApiUpdateAdminConsentRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationDetailResponse> {
            return localVarFp.updateAdminConsent(requestParameters.workspaceId, requestParameters.integrationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntegrationsApi - interface
 * @export
 * @interface IntegrationsApi
 */
export interface IntegrationsApiInterface {
    /**
     * 
     * @summary Create Integration
     * @param {IntegrationsApiCreateIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    createIntegration(requestParameters: IntegrationsApiCreateIntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationFlowResponse>;

    /**
     * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Data Request
     * @param {IntegrationsApiCustomerDataRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    customerDataRequest(requestParameters: IntegrationsApiCustomerDataRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Redact
     * @param {IntegrationsApiCustomerRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    customerRedact(requestParameters: IntegrationsApiCustomerRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Delete Integration
     * @param {IntegrationsApiDeleteIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    deleteIntegration(requestParameters: IntegrationsApiDeleteIntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Get Actors
     * @param {IntegrationsApiGetActorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getActors(requestParameters: IntegrationsApiGetActorsRequest, options?: RawAxiosRequestConfig): AxiosPromise<HubSpotActorsResponse>;

    /**
     * 
     * @summary Get All Integrations
     * @param {IntegrationsApiGetAllIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getAllIntegrations(requestParameters: IntegrationsApiGetAllIntegrationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<IntegrationResponse>>;

    /**
     * 
     * @summary Get Calendars
     * @param {IntegrationsApiGetCalendarsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getCalendars(requestParameters: IntegrationsApiGetCalendarsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleCalendarsResponse>;

    /**
     * 
     * @summary Get Hubspot Custom Channel Connect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getHubspotCustomChannelConnect(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Integration
     * @param {IntegrationsApiGetIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getIntegration(requestParameters: IntegrationsApiGetIntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationDetailResponse>;

    /**
     * 
     * @summary Get Picker Token
     * @param {IntegrationsApiGetPickerTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getPickerToken(requestParameters: IntegrationsApiGetPickerTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<GooglePickerTokenResponse>;

    /**
     * 
     * @summary Get Profile Information
     * @param {IntegrationsApiGetProfileInformationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getProfileInformation(requestParameters: IntegrationsApiGetProfileInformationRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstagramProfileInformationResponse>;

    /**
     * 
     * @summary Get Sheets
     * @param {IntegrationsApiGetSheetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getSheets(requestParameters: IntegrationsApiGetSheetsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GoogleSheetsResponse>;

    /**
     * 
     * @summary Get Shopify
     * @param {IntegrationsApiGetShopifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getShopify(requestParameters: IntegrationsApiGetShopifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ShopifyIntegrationResponse>;

    /**
     * 
     * @summary Get Slack Channels
     * @param {IntegrationsApiGetSlackChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getSlackChannels(requestParameters: IntegrationsApiGetSlackChannelsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackChannelResponse>>;

    /**
     * 
     * @summary Get Slack Workspaces
     * @param {IntegrationsApiGetSlackWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getSlackWorkspaces(requestParameters: IntegrationsApiGetSlackWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackWorkspaceResponse>>;

    /**
     * 
     * @summary Get Wordpress Post Categories
     * @param {IntegrationsApiGetWordpressPostCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getWordpressPostCategories(requestParameters: IntegrationsApiGetWordpressPostCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressCategoryResponse>>;

    /**
     * 
     * @summary Get Wordpress Post Tags
     * @param {IntegrationsApiGetWordpressPostTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getWordpressPostTags(requestParameters: IntegrationsApiGetWordpressPostTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressTagsResponse>>;

    /**
     * 
     * @summary Get Wordpress Sites
     * @param {IntegrationsApiGetWordpressSitesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    getWordpressSites(requestParameters: IntegrationsApiGetWordpressSitesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressSiteResponse>>;

    /**
     * 
     * @summary Integration Callback
     * @param {IntegrationsApiIntegrationCallbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    integrationCallback(requestParameters: IntegrationsApiIntegrationCallbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Search Integrations
     * @param {IntegrationsApiSearchIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    searchIntegrations(requestParameters: IntegrationsApiSearchIntegrationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<IntegrationDetailResponse>>;

    /**
     * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Shop Redact
     * @param {IntegrationsApiShopRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    shopRedact(requestParameters: IntegrationsApiShopRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle subscription cancellation webhooks from Shopify.
     * @summary Subscription Cancel
     * @param {IntegrationsApiSubscriptionCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    subscriptionCancel(requestParameters?: IntegrationsApiSubscriptionCancelRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
     * @summary Subscription Update
     * @param {IntegrationsApiSubscriptionUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    subscriptionUpdate(requestParameters?: IntegrationsApiSubscriptionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Update Admin Consent
     * @param {IntegrationsApiUpdateAdminConsentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApiInterface
     */
    updateAdminConsent(requestParameters: IntegrationsApiUpdateAdminConsentRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationDetailResponse>;

}

/**
 * Request parameters for createIntegration operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiCreateIntegrationRequest
 */
export interface IntegrationsApiCreateIntegrationRequest {
    /**
     * 
     * @type {IntegrationSlug}
     * @memberof IntegrationsApiCreateIntegration
     */
    readonly slug: IntegrationSlug

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiCreateIntegration
     */
    readonly workspaceId: string
}

/**
 * Request parameters for customerDataRequest operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiCustomerDataRequestRequest
 */
export interface IntegrationsApiCustomerDataRequestRequest {
    /**
     * 
     * @type {CustomerDataRequestPayload}
     * @memberof IntegrationsApiCustomerDataRequest
     */
    readonly customerDataRequestPayload: CustomerDataRequestPayload
}

/**
 * Request parameters for customerRedact operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiCustomerRedactRequest
 */
export interface IntegrationsApiCustomerRedactRequest {
    /**
     * 
     * @type {CustomerRedactPayload}
     * @memberof IntegrationsApiCustomerRedact
     */
    readonly customerRedactPayload: CustomerRedactPayload
}

/**
 * Request parameters for deleteIntegration operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiDeleteIntegrationRequest
 */
export interface IntegrationsApiDeleteIntegrationRequest {
    /**
     * 
     * @type {IntegrationSlug}
     * @memberof IntegrationsApiDeleteIntegration
     */
    readonly slug: IntegrationSlug

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiDeleteIntegration
     */
    readonly integrationId: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiDeleteIntegration
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getActors operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetActorsRequest
 */
export interface IntegrationsApiGetActorsRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetActors
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getAllIntegrations operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetAllIntegrationsRequest
 */
export interface IntegrationsApiGetAllIntegrationsRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetAllIntegrations
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getCalendars operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetCalendarsRequest
 */
export interface IntegrationsApiGetCalendarsRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetCalendars
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getIntegration operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetIntegrationRequest
 */
export interface IntegrationsApiGetIntegrationRequest {
    /**
     * 
     * @type {IntegrationSlug}
     * @memberof IntegrationsApiGetIntegration
     */
    readonly slug: IntegrationSlug

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetIntegration
     */
    readonly integrationId: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetIntegration
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getPickerToken operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetPickerTokenRequest
 */
export interface IntegrationsApiGetPickerTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetPickerToken
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getProfileInformation operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetProfileInformationRequest
 */
export interface IntegrationsApiGetProfileInformationRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetProfileInformation
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getSheets operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetSheetsRequest
 */
export interface IntegrationsApiGetSheetsRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetSheets
     */
    readonly documentId: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetSheets
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getShopify operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetShopifyRequest
 */
export interface IntegrationsApiGetShopifyRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetShopify
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getSlackChannels operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetSlackChannelsRequest
 */
export interface IntegrationsApiGetSlackChannelsRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetSlackChannels
     */
    readonly slackTeamId: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetSlackChannels
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getSlackWorkspaces operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetSlackWorkspacesRequest
 */
export interface IntegrationsApiGetSlackWorkspacesRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetSlackWorkspaces
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getWordpressPostCategories operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetWordpressPostCategoriesRequest
 */
export interface IntegrationsApiGetWordpressPostCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetWordpressPostCategories
     */
    readonly integrationId: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetWordpressPostCategories
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getWordpressPostTags operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetWordpressPostTagsRequest
 */
export interface IntegrationsApiGetWordpressPostTagsRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetWordpressPostTags
     */
    readonly integrationId: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetWordpressPostTags
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getWordpressSites operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiGetWordpressSitesRequest
 */
export interface IntegrationsApiGetWordpressSitesRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiGetWordpressSites
     */
    readonly workspaceId: string
}

/**
 * Request parameters for integrationCallback operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiIntegrationCallbackRequest
 */
export interface IntegrationsApiIntegrationCallbackRequest {
    /**
     * 
     * @type {IntegrationSlug}
     * @memberof IntegrationsApiIntegrationCallback
     */
    readonly slug: IntegrationSlug
}

/**
 * Request parameters for searchIntegrations operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSearchIntegrationsRequest
 */
export interface IntegrationsApiSearchIntegrationsRequest {
    /**
     * 
     * @type {IntegrationSlug}
     * @memberof IntegrationsApiSearchIntegrations
     */
    readonly slug: IntegrationSlug

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiSearchIntegrations
     */
    readonly workspaceId: string

    /**
     * 
     * @type {IntegrationSearchRequest}
     * @memberof IntegrationsApiSearchIntegrations
     */
    readonly integrationSearchRequest: IntegrationSearchRequest
}

/**
 * Request parameters for shopRedact operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiShopRedactRequest
 */
export interface IntegrationsApiShopRedactRequest {
    /**
     * 
     * @type {ShopRedactPayload}
     * @memberof IntegrationsApiShopRedact
     */
    readonly shopRedactPayload: ShopRedactPayload
}

/**
 * Request parameters for subscriptionCancel operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSubscriptionCancelRequest
 */
export interface IntegrationsApiSubscriptionCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiSubscriptionCancel
     */
    readonly xShopifyHmacSha256?: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiSubscriptionCancel
     */
    readonly xShopifyTopic?: string
}

/**
 * Request parameters for subscriptionUpdate operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiSubscriptionUpdateRequest
 */
export interface IntegrationsApiSubscriptionUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiSubscriptionUpdate
     */
    readonly xShopifyHmacSha256?: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiSubscriptionUpdate
     */
    readonly xShopifyTopic?: string
}

/**
 * Request parameters for updateAdminConsent operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiUpdateAdminConsentRequest
 */
export interface IntegrationsApiUpdateAdminConsentRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiUpdateAdminConsent
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof IntegrationsApiUpdateAdminConsent
     */
    readonly integrationId: string
}

/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export class IntegrationsApi extends BaseAPI implements IntegrationsApiInterface {
    /**
     * 
     * @summary Create Integration
     * @param {IntegrationsApiCreateIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public createIntegration(requestParameters: IntegrationsApiCreateIntegrationRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).createIntegration(requestParameters.slug, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Data Request
     * @param {IntegrationsApiCustomerDataRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public customerDataRequest(requestParameters: IntegrationsApiCustomerDataRequestRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).customerDataRequest(requestParameters.customerDataRequestPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Redact
     * @param {IntegrationsApiCustomerRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public customerRedact(requestParameters: IntegrationsApiCustomerRedactRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).customerRedact(requestParameters.customerRedactPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Integration
     * @param {IntegrationsApiDeleteIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public deleteIntegration(requestParameters: IntegrationsApiDeleteIntegrationRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).deleteIntegration(requestParameters.slug, requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Actors
     * @param {IntegrationsApiGetActorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getActors(requestParameters: IntegrationsApiGetActorsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getActors(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All Integrations
     * @param {IntegrationsApiGetAllIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getAllIntegrations(requestParameters: IntegrationsApiGetAllIntegrationsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getAllIntegrations(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Calendars
     * @param {IntegrationsApiGetCalendarsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getCalendars(requestParameters: IntegrationsApiGetCalendarsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getCalendars(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Hubspot Custom Channel Connect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getHubspotCustomChannelConnect(options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getHubspotCustomChannelConnect(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Integration
     * @param {IntegrationsApiGetIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getIntegration(requestParameters: IntegrationsApiGetIntegrationRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getIntegration(requestParameters.slug, requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Picker Token
     * @param {IntegrationsApiGetPickerTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getPickerToken(requestParameters: IntegrationsApiGetPickerTokenRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getPickerToken(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Profile Information
     * @param {IntegrationsApiGetProfileInformationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getProfileInformation(requestParameters: IntegrationsApiGetProfileInformationRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getProfileInformation(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Sheets
     * @param {IntegrationsApiGetSheetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getSheets(requestParameters: IntegrationsApiGetSheetsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getSheets(requestParameters.documentId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Shopify
     * @param {IntegrationsApiGetShopifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getShopify(requestParameters: IntegrationsApiGetShopifyRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getShopify(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Slack Channels
     * @param {IntegrationsApiGetSlackChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getSlackChannels(requestParameters: IntegrationsApiGetSlackChannelsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getSlackChannels(requestParameters.slackTeamId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Slack Workspaces
     * @param {IntegrationsApiGetSlackWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getSlackWorkspaces(requestParameters: IntegrationsApiGetSlackWorkspacesRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getSlackWorkspaces(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Wordpress Post Categories
     * @param {IntegrationsApiGetWordpressPostCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getWordpressPostCategories(requestParameters: IntegrationsApiGetWordpressPostCategoriesRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getWordpressPostCategories(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Wordpress Post Tags
     * @param {IntegrationsApiGetWordpressPostTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getWordpressPostTags(requestParameters: IntegrationsApiGetWordpressPostTagsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getWordpressPostTags(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Wordpress Sites
     * @param {IntegrationsApiGetWordpressSitesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getWordpressSites(requestParameters: IntegrationsApiGetWordpressSitesRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getWordpressSites(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Integration Callback
     * @param {IntegrationsApiIntegrationCallbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public integrationCallback(requestParameters: IntegrationsApiIntegrationCallbackRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationCallback(requestParameters.slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Integrations
     * @param {IntegrationsApiSearchIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public searchIntegrations(requestParameters: IntegrationsApiSearchIntegrationsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).searchIntegrations(requestParameters.slug, requestParameters.workspaceId, requestParameters.integrationSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Shop Redact
     * @param {IntegrationsApiShopRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public shopRedact(requestParameters: IntegrationsApiShopRedactRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).shopRedact(requestParameters.shopRedactPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle subscription cancellation webhooks from Shopify.
     * @summary Subscription Cancel
     * @param {IntegrationsApiSubscriptionCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public subscriptionCancel(requestParameters: IntegrationsApiSubscriptionCancelRequest = {}, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).subscriptionCancel(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
     * @summary Subscription Update
     * @param {IntegrationsApiSubscriptionUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public subscriptionUpdate(requestParameters: IntegrationsApiSubscriptionUpdateRequest = {}, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).subscriptionUpdate(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Admin Consent
     * @param {IntegrationsApiUpdateAdminConsentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public updateAdminConsent(requestParameters: IntegrationsApiUpdateAdminConsentRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).updateAdminConsent(requestParameters.workspaceId, requestParameters.integrationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LogsApi - axios parameter creator
 * @export
 */
export const LogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search for logs based on various criteria
         * @summary Search logs
         * @param {string} workspaceId 
         * @param {LogsSearchRequest} logsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLogs: async (workspaceId: string, logsSearchRequest: LogsSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchLogs', 'workspaceId', workspaceId)
            // verify required parameter 'logsSearchRequest' is not null or undefined
            assertParamExists('searchLogs', 'logsSearchRequest', logsSearchRequest)
            const localVarPath = `/v2/logs/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logsSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration)
    return {
        /**
         * Search for logs based on various criteria
         * @summary Search logs
         * @param {string} workspaceId 
         * @param {LogsSearchRequest} logsSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchLogs(workspaceId: string, logsSearchRequest: LogsSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchLogs(workspaceId, logsSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogsApi.searchLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LogsApi - factory interface
 * @export
 */
export const LogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogsApiFp(configuration)
    return {
        /**
         * Search for logs based on various criteria
         * @summary Search logs
         * @param {LogsApiSearchLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLogs(requestParameters: LogsApiSearchLogsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<LogResponse>> {
            return localVarFp.searchLogs(requestParameters.workspaceId, requestParameters.logsSearchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogsApi - interface
 * @export
 * @interface LogsApi
 */
export interface LogsApiInterface {
    /**
     * Search for logs based on various criteria
     * @summary Search logs
     * @param {LogsApiSearchLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApiInterface
     */
    searchLogs(requestParameters: LogsApiSearchLogsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<LogResponse>>;

}

/**
 * Request parameters for searchLogs operation in LogsApi.
 * @export
 * @interface LogsApiSearchLogsRequest
 */
export interface LogsApiSearchLogsRequest {
    /**
     * 
     * @type {string}
     * @memberof LogsApiSearchLogs
     */
    readonly workspaceId: string

    /**
     * 
     * @type {LogsSearchRequest}
     * @memberof LogsApiSearchLogs
     */
    readonly logsSearchRequest: LogsSearchRequest
}

/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
export class LogsApi extends BaseAPI implements LogsApiInterface {
    /**
     * Search for logs based on various criteria
     * @summary Search logs
     * @param {LogsApiSearchLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public searchLogs(requestParameters: LogsApiSearchLogsRequest, options?: RawAxiosRequestConfig) {
        return LogsApiFp(this.configuration).searchLogs(requestParameters.workspaceId, requestParameters.logsSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MCPServersApi - axios parameter creator
 * @export
 */
export const MCPServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new MCP server.  Args:     workspace_id: The workspace ID.     request: The MCP server creation request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerCreateResponse: The created MCP server with the raw API key.
         * @summary Create Mcp Server
         * @param {string} workspaceId 
         * @param {MCPServerCreateRequest} mCPServerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMcpServer: async (workspaceId: string, mCPServerCreateRequest: MCPServerCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createMcpServer', 'workspaceId', workspaceId)
            // verify required parameter 'mCPServerCreateRequest' is not null or undefined
            assertParamExists('createMcpServer', 'mCPServerCreateRequest', mCPServerCreateRequest)
            const localVarPath = `/v2/mcp_servers/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mCPServerCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an MCP server.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.
         * @summary Delete Mcp Server
         * @param {string} mcpServerId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMcpServer: async (mcpServerId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mcpServerId' is not null or undefined
            assertParamExists('deleteMcpServer', 'mcpServerId', mcpServerId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteMcpServer', 'workspaceId', workspaceId)
            const localVarPath = `/v2/mcp_servers/{mcp_server_id}`
                .replace(`{${"mcp_server_id"}}`, encodeURIComponent(String(mcpServerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all MCP subservers available in the system.  Args:     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPSubServerBinding]: List of all MCP subservers.
         * @summary Get All Mcp Subservers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMcpSubservers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/mcp_servers/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an MCP server by ID.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The MCP server.
         * @summary Get Mcp Server
         * @param {string} mcpServerId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMcpServer: async (mcpServerId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mcpServerId' is not null or undefined
            assertParamExists('getMcpServer', 'mcpServerId', mcpServerId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getMcpServer', 'workspaceId', workspaceId)
            const localVarPath = `/v2/mcp_servers/{mcp_server_id}`
                .replace(`{${"mcp_server_id"}}`, encodeURIComponent(String(mcpServerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List MCP servers in a workspace.  Args:     workspace_id: The workspace ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPServerResponse]: List of MCP servers.
         * @summary Search Mcp Servers
         * @param {string} workspaceId 
         * @param {MCPServerSearchRequest} mCPServerSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMcpServers: async (workspaceId: string, mCPServerSearchRequest: MCPServerSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchMcpServers', 'workspaceId', workspaceId)
            // verify required parameter 'mCPServerSearchRequest' is not null or undefined
            assertParamExists('searchMcpServers', 'mCPServerSearchRequest', mCPServerSearchRequest)
            const localVarPath = `/v2/mcp_servers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mCPServerSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an MCP server.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     request: The update request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The updated MCP server.
         * @summary Update Mcp Server
         * @param {string} mcpServerId 
         * @param {string} workspaceId 
         * @param {MCPServerCreateRequest} mCPServerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMcpServer: async (mcpServerId: string, workspaceId: string, mCPServerCreateRequest: MCPServerCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mcpServerId' is not null or undefined
            assertParamExists('updateMcpServer', 'mcpServerId', mcpServerId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateMcpServer', 'workspaceId', workspaceId)
            // verify required parameter 'mCPServerCreateRequest' is not null or undefined
            assertParamExists('updateMcpServer', 'mCPServerCreateRequest', mCPServerCreateRequest)
            const localVarPath = `/v2/mcp_servers/{mcp_server_id}`
                .replace(`{${"mcp_server_id"}}`, encodeURIComponent(String(mcpServerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mCPServerCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MCPServersApi - functional programming interface
 * @export
 */
export const MCPServersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MCPServersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new MCP server.  Args:     workspace_id: The workspace ID.     request: The MCP server creation request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerCreateResponse: The created MCP server with the raw API key.
         * @summary Create Mcp Server
         * @param {string} workspaceId 
         * @param {MCPServerCreateRequest} mCPServerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMcpServer(workspaceId: string, mCPServerCreateRequest: MCPServerCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MCPServerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMcpServer(workspaceId, mCPServerCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MCPServersApi.createMcpServer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an MCP server.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.
         * @summary Delete Mcp Server
         * @param {string} mcpServerId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMcpServer(mcpServerId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMcpServer(mcpServerId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MCPServersApi.deleteMcpServer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all MCP subservers available in the system.  Args:     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPSubServerBinding]: List of all MCP subservers.
         * @summary Get All Mcp Subservers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMcpSubservers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneralMCPSubserverResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMcpSubservers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MCPServersApi.getAllMcpSubservers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an MCP server by ID.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The MCP server.
         * @summary Get Mcp Server
         * @param {string} mcpServerId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMcpServer(mcpServerId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MCPServerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMcpServer(mcpServerId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MCPServersApi.getMcpServer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List MCP servers in a workspace.  Args:     workspace_id: The workspace ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPServerResponse]: List of MCP servers.
         * @summary Search Mcp Servers
         * @param {string} workspaceId 
         * @param {MCPServerSearchRequest} mCPServerSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMcpServers(workspaceId: string, mCPServerSearchRequest: MCPServerSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MCPServerResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMcpServers(workspaceId, mCPServerSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MCPServersApi.searchMcpServers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an MCP server.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     request: The update request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The updated MCP server.
         * @summary Update Mcp Server
         * @param {string} mcpServerId 
         * @param {string} workspaceId 
         * @param {MCPServerCreateRequest} mCPServerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMcpServer(mcpServerId: string, workspaceId: string, mCPServerCreateRequest: MCPServerCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MCPServerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMcpServer(mcpServerId, workspaceId, mCPServerCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MCPServersApi.updateMcpServer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MCPServersApi - factory interface
 * @export
 */
export const MCPServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MCPServersApiFp(configuration)
    return {
        /**
         * Create a new MCP server.  Args:     workspace_id: The workspace ID.     request: The MCP server creation request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerCreateResponse: The created MCP server with the raw API key.
         * @summary Create Mcp Server
         * @param {MCPServersApiCreateMcpServerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMcpServer(requestParameters: MCPServersApiCreateMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<MCPServerResponse> {
            return localVarFp.createMcpServer(requestParameters.workspaceId, requestParameters.mCPServerCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an MCP server.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.
         * @summary Delete Mcp Server
         * @param {MCPServersApiDeleteMcpServerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMcpServer(requestParameters: MCPServersApiDeleteMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteMcpServer(requestParameters.mcpServerId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all MCP subservers available in the system.  Args:     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPSubServerBinding]: List of all MCP subservers.
         * @summary Get All Mcp Subservers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMcpSubservers(options?: RawAxiosRequestConfig): AxiosPromise<Array<GeneralMCPSubserverResponse>> {
            return localVarFp.getAllMcpSubservers(options).then((request) => request(axios, basePath));
        },
        /**
         * Get an MCP server by ID.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The MCP server.
         * @summary Get Mcp Server
         * @param {MCPServersApiGetMcpServerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMcpServer(requestParameters: MCPServersApiGetMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<MCPServerResponse> {
            return localVarFp.getMcpServer(requestParameters.mcpServerId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List MCP servers in a workspace.  Args:     workspace_id: The workspace ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPServerResponse]: List of MCP servers.
         * @summary Search Mcp Servers
         * @param {MCPServersApiSearchMcpServersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMcpServers(requestParameters: MCPServersApiSearchMcpServersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MCPServerResponse>> {
            return localVarFp.searchMcpServers(requestParameters.workspaceId, requestParameters.mCPServerSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an MCP server.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     request: The update request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The updated MCP server.
         * @summary Update Mcp Server
         * @param {MCPServersApiUpdateMcpServerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMcpServer(requestParameters: MCPServersApiUpdateMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<MCPServerResponse> {
            return localVarFp.updateMcpServer(requestParameters.mcpServerId, requestParameters.workspaceId, requestParameters.mCPServerCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MCPServersApi - interface
 * @export
 * @interface MCPServersApi
 */
export interface MCPServersApiInterface {
    /**
     * Create a new MCP server.  Args:     workspace_id: The workspace ID.     request: The MCP server creation request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerCreateResponse: The created MCP server with the raw API key.
     * @summary Create Mcp Server
     * @param {MCPServersApiCreateMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApiInterface
     */
    createMcpServer(requestParameters: MCPServersApiCreateMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<MCPServerResponse>;

    /**
     * Delete an MCP server.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.
     * @summary Delete Mcp Server
     * @param {MCPServersApiDeleteMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApiInterface
     */
    deleteMcpServer(requestParameters: MCPServersApiDeleteMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * Get all MCP subservers available in the system.  Args:     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPSubServerBinding]: List of all MCP subservers.
     * @summary Get All Mcp Subservers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApiInterface
     */
    getAllMcpSubservers(options?: RawAxiosRequestConfig): AxiosPromise<Array<GeneralMCPSubserverResponse>>;

    /**
     * Get an MCP server by ID.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The MCP server.
     * @summary Get Mcp Server
     * @param {MCPServersApiGetMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApiInterface
     */
    getMcpServer(requestParameters: MCPServersApiGetMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<MCPServerResponse>;

    /**
     * List MCP servers in a workspace.  Args:     workspace_id: The workspace ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPServerResponse]: List of MCP servers.
     * @summary Search Mcp Servers
     * @param {MCPServersApiSearchMcpServersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApiInterface
     */
    searchMcpServers(requestParameters: MCPServersApiSearchMcpServersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MCPServerResponse>>;

    /**
     * Update an MCP server.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     request: The update request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The updated MCP server.
     * @summary Update Mcp Server
     * @param {MCPServersApiUpdateMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApiInterface
     */
    updateMcpServer(requestParameters: MCPServersApiUpdateMcpServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<MCPServerResponse>;

}

/**
 * Request parameters for createMcpServer operation in MCPServersApi.
 * @export
 * @interface MCPServersApiCreateMcpServerRequest
 */
export interface MCPServersApiCreateMcpServerRequest {
    /**
     * 
     * @type {string}
     * @memberof MCPServersApiCreateMcpServer
     */
    readonly workspaceId: string

    /**
     * 
     * @type {MCPServerCreateRequest}
     * @memberof MCPServersApiCreateMcpServer
     */
    readonly mCPServerCreateRequest: MCPServerCreateRequest
}

/**
 * Request parameters for deleteMcpServer operation in MCPServersApi.
 * @export
 * @interface MCPServersApiDeleteMcpServerRequest
 */
export interface MCPServersApiDeleteMcpServerRequest {
    /**
     * 
     * @type {string}
     * @memberof MCPServersApiDeleteMcpServer
     */
    readonly mcpServerId: string

    /**
     * 
     * @type {string}
     * @memberof MCPServersApiDeleteMcpServer
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getMcpServer operation in MCPServersApi.
 * @export
 * @interface MCPServersApiGetMcpServerRequest
 */
export interface MCPServersApiGetMcpServerRequest {
    /**
     * 
     * @type {string}
     * @memberof MCPServersApiGetMcpServer
     */
    readonly mcpServerId: string

    /**
     * 
     * @type {string}
     * @memberof MCPServersApiGetMcpServer
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchMcpServers operation in MCPServersApi.
 * @export
 * @interface MCPServersApiSearchMcpServersRequest
 */
export interface MCPServersApiSearchMcpServersRequest {
    /**
     * 
     * @type {string}
     * @memberof MCPServersApiSearchMcpServers
     */
    readonly workspaceId: string

    /**
     * 
     * @type {MCPServerSearchRequest}
     * @memberof MCPServersApiSearchMcpServers
     */
    readonly mCPServerSearchRequest: MCPServerSearchRequest
}

/**
 * Request parameters for updateMcpServer operation in MCPServersApi.
 * @export
 * @interface MCPServersApiUpdateMcpServerRequest
 */
export interface MCPServersApiUpdateMcpServerRequest {
    /**
     * 
     * @type {string}
     * @memberof MCPServersApiUpdateMcpServer
     */
    readonly mcpServerId: string

    /**
     * 
     * @type {string}
     * @memberof MCPServersApiUpdateMcpServer
     */
    readonly workspaceId: string

    /**
     * 
     * @type {MCPServerCreateRequest}
     * @memberof MCPServersApiUpdateMcpServer
     */
    readonly mCPServerCreateRequest: MCPServerCreateRequest
}

/**
 * MCPServersApi - object-oriented interface
 * @export
 * @class MCPServersApi
 * @extends {BaseAPI}
 */
export class MCPServersApi extends BaseAPI implements MCPServersApiInterface {
    /**
     * Create a new MCP server.  Args:     workspace_id: The workspace ID.     request: The MCP server creation request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerCreateResponse: The created MCP server with the raw API key.
     * @summary Create Mcp Server
     * @param {MCPServersApiCreateMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApi
     */
    public createMcpServer(requestParameters: MCPServersApiCreateMcpServerRequest, options?: RawAxiosRequestConfig) {
        return MCPServersApiFp(this.configuration).createMcpServer(requestParameters.workspaceId, requestParameters.mCPServerCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an MCP server.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.
     * @summary Delete Mcp Server
     * @param {MCPServersApiDeleteMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApi
     */
    public deleteMcpServer(requestParameters: MCPServersApiDeleteMcpServerRequest, options?: RawAxiosRequestConfig) {
        return MCPServersApiFp(this.configuration).deleteMcpServer(requestParameters.mcpServerId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all MCP subservers available in the system.  Args:     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPSubServerBinding]: List of all MCP subservers.
     * @summary Get All Mcp Subservers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApi
     */
    public getAllMcpSubservers(options?: RawAxiosRequestConfig) {
        return MCPServersApiFp(this.configuration).getAllMcpSubservers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an MCP server by ID.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The MCP server.
     * @summary Get Mcp Server
     * @param {MCPServersApiGetMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApi
     */
    public getMcpServer(requestParameters: MCPServersApiGetMcpServerRequest, options?: RawAxiosRequestConfig) {
        return MCPServersApiFp(this.configuration).getMcpServer(requestParameters.mcpServerId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List MCP servers in a workspace.  Args:     workspace_id: The workspace ID.     user: The authenticated user.     controller: The MCP server controller.  Returns:     List[MCPServerResponse]: List of MCP servers.
     * @summary Search Mcp Servers
     * @param {MCPServersApiSearchMcpServersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApi
     */
    public searchMcpServers(requestParameters: MCPServersApiSearchMcpServersRequest, options?: RawAxiosRequestConfig) {
        return MCPServersApiFp(this.configuration).searchMcpServers(requestParameters.workspaceId, requestParameters.mCPServerSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an MCP server.  Args:     workspace_id: The workspace ID.     mcp_server_id: The MCP server ID.     request: The update request.     user: The authenticated user.     controller: The MCP server controller.  Returns:     MCPServerResponse: The updated MCP server.
     * @summary Update Mcp Server
     * @param {MCPServersApiUpdateMcpServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MCPServersApi
     */
    public updateMcpServer(requestParameters: MCPServersApiUpdateMcpServerRequest, options?: RawAxiosRequestConfig) {
        return MCPServersApiFp(this.configuration).updateMcpServer(requestParameters.mcpServerId, requestParameters.workspaceId, requestParameters.mCPServerCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeApi - axios parameter creator
 * @export
 */
export const MeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get current user settings with defaults applied.
         * @summary Get User Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/users/me/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update current user settings (UPSERT operation).
         * @summary Update User Settings
         * @param {UpdateUserSettingsRequest} updateUserSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSettings: async (updateUserSettingsRequest: UpdateUserSettingsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserSettingsRequest' is not null or undefined
            assertParamExists('updateUserSettings', 'updateUserSettingsRequest', updateUserSettingsRequest)
            const localVarPath = `/v2/users/me/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeApi - functional programming interface
 * @export
 */
export const MeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeApiAxiosParamCreator(configuration)
    return {
        /**
         * Get current user settings with defaults applied.
         * @summary Get User Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.getUserSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update current user settings (UPSERT operation).
         * @summary Update User Settings
         * @param {UpdateUserSettingsRequest} updateUserSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSettings(updateUserSettingsRequest: UpdateUserSettingsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserSettings(updateUserSettingsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.updateUserSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeApi - factory interface
 * @export
 */
export const MeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeApiFp(configuration)
    return {
        /**
         * Get current user settings with defaults applied.
         * @summary Get User Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings(options?: RawAxiosRequestConfig): AxiosPromise<UserSettingsResponse> {
            return localVarFp.getUserSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Update current user settings (UPSERT operation).
         * @summary Update User Settings
         * @param {MeApiUpdateUserSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSettings(requestParameters: MeApiUpdateUserSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserSettingsResponse> {
            return localVarFp.updateUserSettings(requestParameters.updateUserSettingsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeApi - interface
 * @export
 * @interface MeApi
 */
export interface MeApiInterface {
    /**
     * Get current user settings with defaults applied.
     * @summary Get User Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    getUserSettings(options?: RawAxiosRequestConfig): AxiosPromise<UserSettingsResponse>;

    /**
     * Update current user settings (UPSERT operation).
     * @summary Update User Settings
     * @param {MeApiUpdateUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    updateUserSettings(requestParameters: MeApiUpdateUserSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserSettingsResponse>;

}

/**
 * Request parameters for updateUserSettings operation in MeApi.
 * @export
 * @interface MeApiUpdateUserSettingsRequest
 */
export interface MeApiUpdateUserSettingsRequest {
    /**
     * 
     * @type {UpdateUserSettingsRequest}
     * @memberof MeApiUpdateUserSettings
     */
    readonly updateUserSettingsRequest: UpdateUserSettingsRequest
}

/**
 * MeApi - object-oriented interface
 * @export
 * @class MeApi
 * @extends {BaseAPI}
 */
export class MeApi extends BaseAPI implements MeApiInterface {
    /**
     * Get current user settings with defaults applied.
     * @summary Get User Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public getUserSettings(options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).getUserSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update current user settings (UPSERT operation).
     * @summary Update User Settings
     * @param {MeApiUpdateUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public updateUserSettings(requestParameters: MeApiUpdateUserSettingsRequest, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).updateUserSettings(requestParameters.updateUserSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Transcript
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {string} [postbackUrl] The post back URL where to send the response in body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranscript: async (workspaceId: string, file: File, postbackUrl?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getTranscript', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('getTranscript', 'file', file)
            const localVarPath = `/v2/media/transcript`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (postbackUrl !== undefined) { 
                localVarFormParams.append('postback_url', postbackUrl as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Transcript Result
         * @param {string} workspaceId 
         * @param {TranscriptTaskRequest} transcriptTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranscriptResult: async (workspaceId: string, transcriptTaskRequest: TranscriptTaskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getTranscriptResult', 'workspaceId', workspaceId)
            // verify required parameter 'transcriptTaskRequest' is not null or undefined
            assertParamExists('getTranscriptResult', 'transcriptTaskRequest', transcriptTaskRequest)
            const localVarPath = `/v2/media/transcript_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transcriptTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Youtube Transcript
         * @param {string} workspaceId 
         * @param {YoutubeTranscriptRequest} youtubeTranscriptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYoutubeTranscript: async (workspaceId: string, youtubeTranscriptRequest: YoutubeTranscriptRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getYoutubeTranscript', 'workspaceId', workspaceId)
            // verify required parameter 'youtubeTranscriptRequest' is not null or undefined
            assertParamExists('getYoutubeTranscript', 'youtubeTranscriptRequest', youtubeTranscriptRequest)
            const localVarPath = `/v2/media/youtube/transcript`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(youtubeTranscriptRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Transcript
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {string} [postbackUrl] The post back URL where to send the response in body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTranscript(workspaceId: string, file: File, postbackUrl?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentContentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTranscript(workspaceId, file, postbackUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getTranscript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Transcript Result
         * @param {string} workspaceId 
         * @param {TranscriptTaskRequest} transcriptTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTranscriptResult(workspaceId: string, transcriptTaskRequest: TranscriptTaskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentContentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTranscriptResult(workspaceId, transcriptTaskRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getTranscriptResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Youtube Transcript
         * @param {string} workspaceId 
         * @param {YoutubeTranscriptRequest} youtubeTranscriptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getYoutubeTranscript(workspaceId: string, youtubeTranscriptRequest: YoutubeTranscriptRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<YoutubeTranscriptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getYoutubeTranscript(workspaceId, youtubeTranscriptRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.getYoutubeTranscript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Transcript
         * @param {MediaApiGetTranscriptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranscript(requestParameters: MediaApiGetTranscriptRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentContentResponse> {
            return localVarFp.getTranscript(requestParameters.workspaceId, requestParameters.file, requestParameters.postbackUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Transcript Result
         * @param {MediaApiGetTranscriptResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranscriptResult(requestParameters: MediaApiGetTranscriptResultRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentContentResponse> {
            return localVarFp.getTranscriptResult(requestParameters.workspaceId, requestParameters.transcriptTaskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Youtube Transcript
         * @param {MediaApiGetYoutubeTranscriptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYoutubeTranscript(requestParameters: MediaApiGetYoutubeTranscriptRequest, options?: RawAxiosRequestConfig): AxiosPromise<YoutubeTranscriptResponse> {
            return localVarFp.getYoutubeTranscript(requestParameters.workspaceId, requestParameters.youtubeTranscriptRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - interface
 * @export
 * @interface MediaApi
 */
export interface MediaApiInterface {
    /**
     * 
     * @summary Get Transcript
     * @param {MediaApiGetTranscriptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApiInterface
     */
    getTranscript(requestParameters: MediaApiGetTranscriptRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentContentResponse>;

    /**
     * 
     * @summary Get Transcript Result
     * @param {MediaApiGetTranscriptResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApiInterface
     */
    getTranscriptResult(requestParameters: MediaApiGetTranscriptResultRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentContentResponse>;

    /**
     * 
     * @summary Get Youtube Transcript
     * @param {MediaApiGetYoutubeTranscriptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApiInterface
     */
    getYoutubeTranscript(requestParameters: MediaApiGetYoutubeTranscriptRequest, options?: RawAxiosRequestConfig): AxiosPromise<YoutubeTranscriptResponse>;

}

/**
 * Request parameters for getTranscript operation in MediaApi.
 * @export
 * @interface MediaApiGetTranscriptRequest
 */
export interface MediaApiGetTranscriptRequest {
    /**
     * 
     * @type {string}
     * @memberof MediaApiGetTranscript
     */
    readonly workspaceId: string

    /**
     * 
     * @type {File}
     * @memberof MediaApiGetTranscript
     */
    readonly file: File

    /**
     * The post back URL where to send the response in body
     * @type {string}
     * @memberof MediaApiGetTranscript
     */
    readonly postbackUrl?: string
}

/**
 * Request parameters for getTranscriptResult operation in MediaApi.
 * @export
 * @interface MediaApiGetTranscriptResultRequest
 */
export interface MediaApiGetTranscriptResultRequest {
    /**
     * 
     * @type {string}
     * @memberof MediaApiGetTranscriptResult
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TranscriptTaskRequest}
     * @memberof MediaApiGetTranscriptResult
     */
    readonly transcriptTaskRequest: TranscriptTaskRequest
}

/**
 * Request parameters for getYoutubeTranscript operation in MediaApi.
 * @export
 * @interface MediaApiGetYoutubeTranscriptRequest
 */
export interface MediaApiGetYoutubeTranscriptRequest {
    /**
     * 
     * @type {string}
     * @memberof MediaApiGetYoutubeTranscript
     */
    readonly workspaceId: string

    /**
     * 
     * @type {YoutubeTranscriptRequest}
     * @memberof MediaApiGetYoutubeTranscript
     */
    readonly youtubeTranscriptRequest: YoutubeTranscriptRequest
}

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI implements MediaApiInterface {
    /**
     * 
     * @summary Get Transcript
     * @param {MediaApiGetTranscriptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getTranscript(requestParameters: MediaApiGetTranscriptRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getTranscript(requestParameters.workspaceId, requestParameters.file, requestParameters.postbackUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Transcript Result
     * @param {MediaApiGetTranscriptResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getTranscriptResult(requestParameters: MediaApiGetTranscriptResultRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getTranscriptResult(requestParameters.workspaceId, requestParameters.transcriptTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Youtube Transcript
     * @param {MediaApiGetYoutubeTranscriptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public getYoutubeTranscript(requestParameters: MediaApiGetYoutubeTranscriptRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).getYoutubeTranscript(requestParameters.workspaceId, requestParameters.youtubeTranscriptRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MemoryApi - axios parameter creator
 * @export
 */
export const MemoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Node
         * @param {string} workspaceId 
         * @param {NodeDetailRequest} nodeDetailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode: async (workspaceId: string, nodeDetailRequest: NodeDetailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createNode', 'workspaceId', workspaceId)
            // verify required parameter 'nodeDetailRequest' is not null or undefined
            assertParamExists('createNode', 'nodeDetailRequest', nodeDetailRequest)
            const localVarPath = `/v2/memory/node/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeDetailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Node
         * @param {string} nodeId 
         * @param {string} workspaceId 
         * @param {DeleteNodeRequest} deleteNodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNode: async (nodeId: string, workspaceId: string, deleteNodeRequest: DeleteNodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('deleteNode', 'nodeId', nodeId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteNode', 'workspaceId', workspaceId)
            // verify required parameter 'deleteNodeRequest' is not null or undefined
            assertParamExists('deleteNode', 'deleteNodeRequest', deleteNodeRequest)
            const localVarPath = `/v2/memory/node/{node_id}`
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteNodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Node
         * @param {string} nodeId 
         * @param {string} workspaceId 
         * @param {GetNodeRequest} getNodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode: async (nodeId: string, workspaceId: string, getNodeRequest: GetNodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('getNode', 'nodeId', nodeId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getNode', 'workspaceId', workspaceId)
            // verify required parameter 'getNodeRequest' is not null or undefined
            assertParamExists('getNode', 'getNodeRequest', getNodeRequest)
            const localVarPath = `/v2/memory/node/{node_id}`
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getNodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Process Documents
         * @param {string} workspaceId 
         * @param {MemoryDocumentProcessRequest} memoryDocumentProcessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processDocuments: async (workspaceId: string, memoryDocumentProcessRequest: MemoryDocumentProcessRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('processDocuments', 'workspaceId', workspaceId)
            // verify required parameter 'memoryDocumentProcessRequest' is not null or undefined
            assertParamExists('processDocuments', 'memoryDocumentProcessRequest', memoryDocumentProcessRequest)
            const localVarPath = `/v2/memory/process-documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memoryDocumentProcessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Memory Categories
         * @param {string} workspaceId 
         * @param {MemorySearchRequest} memorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMemoryCategories: async (workspaceId: string, memorySearchRequest: MemorySearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchMemoryCategories', 'workspaceId', workspaceId)
            // verify required parameter 'memorySearchRequest' is not null or undefined
            assertParamExists('searchMemoryCategories', 'memorySearchRequest', memorySearchRequest)
            const localVarPath = `/v2/memory/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memorySearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Memory Node Name
         * @param {string} workspaceId 
         * @param {MemoryNodeNameSearchRequest} memoryNodeNameSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMemoryNodeName: async (workspaceId: string, memoryNodeNameSearchRequest: MemoryNodeNameSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchMemoryNodeName', 'workspaceId', workspaceId)
            // verify required parameter 'memoryNodeNameSearchRequest' is not null or undefined
            assertParamExists('searchMemoryNodeName', 'memoryNodeNameSearchRequest', memoryNodeNameSearchRequest)
            const localVarPath = `/v2/memory/search_node_name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memoryNodeNameSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Memory Node Path
         * @param {string} workspaceId 
         * @param {MemoryNodePathSearchRequest} memoryNodePathSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMemoryNodePath: async (workspaceId: string, memoryNodePathSearchRequest: MemoryNodePathSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchMemoryNodePath', 'workspaceId', workspaceId)
            // verify required parameter 'memoryNodePathSearchRequest' is not null or undefined
            assertParamExists('searchMemoryNodePath', 'memoryNodePathSearchRequest', memoryNodePathSearchRequest)
            const localVarPath = `/v2/memory/search_node_path`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(memoryNodePathSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Node
         * @param {string} nodeId 
         * @param {string} workspaceId 
         * @param {NodeUpdateRequest} nodeUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNode: async (nodeId: string, workspaceId: string, nodeUpdateRequest: NodeUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('updateNode', 'nodeId', nodeId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateNode', 'workspaceId', workspaceId)
            // verify required parameter 'nodeUpdateRequest' is not null or undefined
            assertParamExists('updateNode', 'nodeUpdateRequest', nodeUpdateRequest)
            const localVarPath = `/v2/memory/node/{node_id}`
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Document
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument: async (catId: string, workspaceId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('uploadDocument', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('uploadDocument', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadDocument', 'file', file)
            const localVarPath = `/v2/memory/upload/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MemoryApi - functional programming interface
 * @export
 */
export const MemoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MemoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Node
         * @param {string} workspaceId 
         * @param {NodeDetailRequest} nodeDetailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNode(workspaceId: string, nodeDetailRequest: NodeDetailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryNodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNode(workspaceId, nodeDetailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.createNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Node
         * @param {string} nodeId 
         * @param {string} workspaceId 
         * @param {DeleteNodeRequest} deleteNodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNode(nodeId: string, workspaceId: string, deleteNodeRequest: DeleteNodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNode(nodeId, workspaceId, deleteNodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.deleteNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Node
         * @param {string} nodeId 
         * @param {string} workspaceId 
         * @param {GetNodeRequest} getNodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNode(nodeId: string, workspaceId: string, getNodeRequest: GetNodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryNodeDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNode(nodeId, workspaceId, getNodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.getNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Process Documents
         * @param {string} workspaceId 
         * @param {MemoryDocumentProcessRequest} memoryDocumentProcessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processDocuments(workspaceId: string, memoryDocumentProcessRequest: MemoryDocumentProcessRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processDocuments(workspaceId, memoryDocumentProcessRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.processDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Memory Categories
         * @param {string} workspaceId 
         * @param {MemorySearchRequest} memorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMemoryCategories(workspaceId: string, memorySearchRequest: MemorySearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemorySearchResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMemoryCategories(workspaceId, memorySearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.searchMemoryCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Memory Node Name
         * @param {string} workspaceId 
         * @param {MemoryNodeNameSearchRequest} memoryNodeNameSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMemoryNodeName(workspaceId: string, memoryNodeNameSearchRequest: MemoryNodeNameSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemorySearchResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMemoryNodeName(workspaceId, memoryNodeNameSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.searchMemoryNodeName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Memory Node Path
         * @param {string} workspaceId 
         * @param {MemoryNodePathSearchRequest} memoryNodePathSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMemoryNodePath(workspaceId: string, memoryNodePathSearchRequest: MemoryNodePathSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemorySearchResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMemoryNodePath(workspaceId, memoryNodePathSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.searchMemoryNodePath']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Node
         * @param {string} nodeId 
         * @param {string} workspaceId 
         * @param {NodeUpdateRequest} nodeUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNode(nodeId: string, workspaceId: string, nodeUpdateRequest: NodeUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryNodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNode(nodeId, workspaceId, nodeUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.updateNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Document
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadDocument(catId: string, workspaceId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryDocumentUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadDocument(catId, workspaceId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MemoryApi.uploadDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MemoryApi - factory interface
 * @export
 */
export const MemoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MemoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Node
         * @param {MemoryApiCreateNodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode(requestParameters: MemoryApiCreateNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryNodeResponse> {
            return localVarFp.createNode(requestParameters.workspaceId, requestParameters.nodeDetailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Node
         * @param {MemoryApiDeleteNodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNode(requestParameters: MemoryApiDeleteNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryMessageResponse> {
            return localVarFp.deleteNode(requestParameters.nodeId, requestParameters.workspaceId, requestParameters.deleteNodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Node
         * @param {MemoryApiGetNodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode(requestParameters: MemoryApiGetNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryNodeDetailResponse> {
            return localVarFp.getNode(requestParameters.nodeId, requestParameters.workspaceId, requestParameters.getNodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Process Documents
         * @param {MemoryApiProcessDocumentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processDocuments(requestParameters: MemoryApiProcessDocumentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryMessageResponse> {
            return localVarFp.processDocuments(requestParameters.workspaceId, requestParameters.memoryDocumentProcessRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Memory Categories
         * @param {MemoryApiSearchMemoryCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMemoryCategories(requestParameters: MemoryApiSearchMemoryCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MemorySearchResponse>> {
            return localVarFp.searchMemoryCategories(requestParameters.workspaceId, requestParameters.memorySearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Memory Node Name
         * @param {MemoryApiSearchMemoryNodeNameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMemoryNodeName(requestParameters: MemoryApiSearchMemoryNodeNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MemorySearchResponse>> {
            return localVarFp.searchMemoryNodeName(requestParameters.workspaceId, requestParameters.memoryNodeNameSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Memory Node Path
         * @param {MemoryApiSearchMemoryNodePathRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMemoryNodePath(requestParameters: MemoryApiSearchMemoryNodePathRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MemorySearchResponse>> {
            return localVarFp.searchMemoryNodePath(requestParameters.workspaceId, requestParameters.memoryNodePathSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Node
         * @param {MemoryApiUpdateNodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNode(requestParameters: MemoryApiUpdateNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryNodeResponse> {
            return localVarFp.updateNode(requestParameters.nodeId, requestParameters.workspaceId, requestParameters.nodeUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Document
         * @param {MemoryApiUploadDocumentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument(requestParameters: MemoryApiUploadDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryDocumentUploadResponse> {
            return localVarFp.uploadDocument(requestParameters.catId, requestParameters.workspaceId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MemoryApi - interface
 * @export
 * @interface MemoryApi
 */
export interface MemoryApiInterface {
    /**
     * 
     * @summary Create Node
     * @param {MemoryApiCreateNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    createNode(requestParameters: MemoryApiCreateNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryNodeResponse>;

    /**
     * 
     * @summary Delete Node
     * @param {MemoryApiDeleteNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    deleteNode(requestParameters: MemoryApiDeleteNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryMessageResponse>;

    /**
     * 
     * @summary Get Node
     * @param {MemoryApiGetNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    getNode(requestParameters: MemoryApiGetNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryNodeDetailResponse>;

    /**
     * 
     * @summary Process Documents
     * @param {MemoryApiProcessDocumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    processDocuments(requestParameters: MemoryApiProcessDocumentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryMessageResponse>;

    /**
     * 
     * @summary Search Memory Categories
     * @param {MemoryApiSearchMemoryCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    searchMemoryCategories(requestParameters: MemoryApiSearchMemoryCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MemorySearchResponse>>;

    /**
     * 
     * @summary Search Memory Node Name
     * @param {MemoryApiSearchMemoryNodeNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    searchMemoryNodeName(requestParameters: MemoryApiSearchMemoryNodeNameRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MemorySearchResponse>>;

    /**
     * 
     * @summary Search Memory Node Path
     * @param {MemoryApiSearchMemoryNodePathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    searchMemoryNodePath(requestParameters: MemoryApiSearchMemoryNodePathRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MemorySearchResponse>>;

    /**
     * 
     * @summary Update Node
     * @param {MemoryApiUpdateNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    updateNode(requestParameters: MemoryApiUpdateNodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryNodeResponse>;

    /**
     * 
     * @summary Upload Document
     * @param {MemoryApiUploadDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApiInterface
     */
    uploadDocument(requestParameters: MemoryApiUploadDocumentRequest, options?: RawAxiosRequestConfig): AxiosPromise<MemoryDocumentUploadResponse>;

}

/**
 * Request parameters for createNode operation in MemoryApi.
 * @export
 * @interface MemoryApiCreateNodeRequest
 */
export interface MemoryApiCreateNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiCreateNode
     */
    readonly workspaceId: string

    /**
     * 
     * @type {NodeDetailRequest}
     * @memberof MemoryApiCreateNode
     */
    readonly nodeDetailRequest: NodeDetailRequest
}

/**
 * Request parameters for deleteNode operation in MemoryApi.
 * @export
 * @interface MemoryApiDeleteNodeRequest
 */
export interface MemoryApiDeleteNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiDeleteNode
     */
    readonly nodeId: string

    /**
     * 
     * @type {string}
     * @memberof MemoryApiDeleteNode
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DeleteNodeRequest}
     * @memberof MemoryApiDeleteNode
     */
    readonly deleteNodeRequest: DeleteNodeRequest
}

/**
 * Request parameters for getNode operation in MemoryApi.
 * @export
 * @interface MemoryApiGetNodeRequest
 */
export interface MemoryApiGetNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiGetNode
     */
    readonly nodeId: string

    /**
     * 
     * @type {string}
     * @memberof MemoryApiGetNode
     */
    readonly workspaceId: string

    /**
     * 
     * @type {GetNodeRequest}
     * @memberof MemoryApiGetNode
     */
    readonly getNodeRequest: GetNodeRequest
}

/**
 * Request parameters for processDocuments operation in MemoryApi.
 * @export
 * @interface MemoryApiProcessDocumentsRequest
 */
export interface MemoryApiProcessDocumentsRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiProcessDocuments
     */
    readonly workspaceId: string

    /**
     * 
     * @type {MemoryDocumentProcessRequest}
     * @memberof MemoryApiProcessDocuments
     */
    readonly memoryDocumentProcessRequest: MemoryDocumentProcessRequest
}

/**
 * Request parameters for searchMemoryCategories operation in MemoryApi.
 * @export
 * @interface MemoryApiSearchMemoryCategoriesRequest
 */
export interface MemoryApiSearchMemoryCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiSearchMemoryCategories
     */
    readonly workspaceId: string

    /**
     * 
     * @type {MemorySearchRequest}
     * @memberof MemoryApiSearchMemoryCategories
     */
    readonly memorySearchRequest: MemorySearchRequest
}

/**
 * Request parameters for searchMemoryNodeName operation in MemoryApi.
 * @export
 * @interface MemoryApiSearchMemoryNodeNameRequest
 */
export interface MemoryApiSearchMemoryNodeNameRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiSearchMemoryNodeName
     */
    readonly workspaceId: string

    /**
     * 
     * @type {MemoryNodeNameSearchRequest}
     * @memberof MemoryApiSearchMemoryNodeName
     */
    readonly memoryNodeNameSearchRequest: MemoryNodeNameSearchRequest
}

/**
 * Request parameters for searchMemoryNodePath operation in MemoryApi.
 * @export
 * @interface MemoryApiSearchMemoryNodePathRequest
 */
export interface MemoryApiSearchMemoryNodePathRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiSearchMemoryNodePath
     */
    readonly workspaceId: string

    /**
     * 
     * @type {MemoryNodePathSearchRequest}
     * @memberof MemoryApiSearchMemoryNodePath
     */
    readonly memoryNodePathSearchRequest: MemoryNodePathSearchRequest
}

/**
 * Request parameters for updateNode operation in MemoryApi.
 * @export
 * @interface MemoryApiUpdateNodeRequest
 */
export interface MemoryApiUpdateNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiUpdateNode
     */
    readonly nodeId: string

    /**
     * 
     * @type {string}
     * @memberof MemoryApiUpdateNode
     */
    readonly workspaceId: string

    /**
     * 
     * @type {NodeUpdateRequest}
     * @memberof MemoryApiUpdateNode
     */
    readonly nodeUpdateRequest: NodeUpdateRequest
}

/**
 * Request parameters for uploadDocument operation in MemoryApi.
 * @export
 * @interface MemoryApiUploadDocumentRequest
 */
export interface MemoryApiUploadDocumentRequest {
    /**
     * 
     * @type {string}
     * @memberof MemoryApiUploadDocument
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof MemoryApiUploadDocument
     */
    readonly workspaceId: string

    /**
     * 
     * @type {File}
     * @memberof MemoryApiUploadDocument
     */
    readonly file: File
}

/**
 * MemoryApi - object-oriented interface
 * @export
 * @class MemoryApi
 * @extends {BaseAPI}
 */
export class MemoryApi extends BaseAPI implements MemoryApiInterface {
    /**
     * 
     * @summary Create Node
     * @param {MemoryApiCreateNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public createNode(requestParameters: MemoryApiCreateNodeRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).createNode(requestParameters.workspaceId, requestParameters.nodeDetailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Node
     * @param {MemoryApiDeleteNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public deleteNode(requestParameters: MemoryApiDeleteNodeRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).deleteNode(requestParameters.nodeId, requestParameters.workspaceId, requestParameters.deleteNodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Node
     * @param {MemoryApiGetNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public getNode(requestParameters: MemoryApiGetNodeRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).getNode(requestParameters.nodeId, requestParameters.workspaceId, requestParameters.getNodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Process Documents
     * @param {MemoryApiProcessDocumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public processDocuments(requestParameters: MemoryApiProcessDocumentsRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).processDocuments(requestParameters.workspaceId, requestParameters.memoryDocumentProcessRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Memory Categories
     * @param {MemoryApiSearchMemoryCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public searchMemoryCategories(requestParameters: MemoryApiSearchMemoryCategoriesRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).searchMemoryCategories(requestParameters.workspaceId, requestParameters.memorySearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Memory Node Name
     * @param {MemoryApiSearchMemoryNodeNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public searchMemoryNodeName(requestParameters: MemoryApiSearchMemoryNodeNameRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).searchMemoryNodeName(requestParameters.workspaceId, requestParameters.memoryNodeNameSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Memory Node Path
     * @param {MemoryApiSearchMemoryNodePathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public searchMemoryNodePath(requestParameters: MemoryApiSearchMemoryNodePathRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).searchMemoryNodePath(requestParameters.workspaceId, requestParameters.memoryNodePathSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Node
     * @param {MemoryApiUpdateNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public updateNode(requestParameters: MemoryApiUpdateNodeRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).updateNode(requestParameters.nodeId, requestParameters.workspaceId, requestParameters.nodeUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Document
     * @param {MemoryApiUploadDocumentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemoryApi
     */
    public uploadDocument(requestParameters: MemoryApiUploadDocumentRequest, options?: RawAxiosRequestConfig) {
        return MemoryApiFp(this.configuration).uploadDocument(requestParameters.catId, requestParameters.workspaceId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MicrosoftOutlookApi - axios parameter creator
 * @export
 */
export const MicrosoftOutlookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update Admin Consent
         * @param {string} workspaceId 
         * @param {string} integrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdminConsent: async (workspaceId: string, integrationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateAdminConsent', 'workspaceId', workspaceId)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('updateAdminConsent', 'integrationId', integrationId)
            const localVarPath = `/v2/integrations/microsoft_entra_id/admin_consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }

            if (integrationId !== undefined) {
                localVarQueryParameter['integration_id'] = integrationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MicrosoftOutlookApi - functional programming interface
 * @export
 */
export const MicrosoftOutlookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MicrosoftOutlookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update Admin Consent
         * @param {string} workspaceId 
         * @param {string} integrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAdminConsent(workspaceId: string, integrationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAdminConsent(workspaceId, integrationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MicrosoftOutlookApi.updateAdminConsent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MicrosoftOutlookApi - factory interface
 * @export
 */
export const MicrosoftOutlookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MicrosoftOutlookApiFp(configuration)
    return {
        /**
         * 
         * @summary Update Admin Consent
         * @param {MicrosoftOutlookApiUpdateAdminConsentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdminConsent(requestParameters: MicrosoftOutlookApiUpdateAdminConsentRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationDetailResponse> {
            return localVarFp.updateAdminConsent(requestParameters.workspaceId, requestParameters.integrationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MicrosoftOutlookApi - interface
 * @export
 * @interface MicrosoftOutlookApi
 */
export interface MicrosoftOutlookApiInterface {
    /**
     * 
     * @summary Update Admin Consent
     * @param {MicrosoftOutlookApiUpdateAdminConsentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrosoftOutlookApiInterface
     */
    updateAdminConsent(requestParameters: MicrosoftOutlookApiUpdateAdminConsentRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationDetailResponse>;

}

/**
 * Request parameters for updateAdminConsent operation in MicrosoftOutlookApi.
 * @export
 * @interface MicrosoftOutlookApiUpdateAdminConsentRequest
 */
export interface MicrosoftOutlookApiUpdateAdminConsentRequest {
    /**
     * 
     * @type {string}
     * @memberof MicrosoftOutlookApiUpdateAdminConsent
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof MicrosoftOutlookApiUpdateAdminConsent
     */
    readonly integrationId: string
}

/**
 * MicrosoftOutlookApi - object-oriented interface
 * @export
 * @class MicrosoftOutlookApi
 * @extends {BaseAPI}
 */
export class MicrosoftOutlookApi extends BaseAPI implements MicrosoftOutlookApiInterface {
    /**
     * 
     * @summary Update Admin Consent
     * @param {MicrosoftOutlookApiUpdateAdminConsentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrosoftOutlookApi
     */
    public updateAdminConsent(requestParameters: MicrosoftOutlookApiUpdateAdminConsentRequest, options?: RawAxiosRequestConfig) {
        return MicrosoftOutlookApiFp(this.configuration).updateAdminConsent(requestParameters.workspaceId, requestParameters.integrationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OAuth authorization endpoint
         * @summary Oauth Authorize
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAuthorize: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/oauth/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth authorization endpoint (consent form submission)
         * @summary Oauth Authorize Post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAuthorizePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/oauth/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth callback endpoint for third-party providers
         * @summary Oauth Callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthCallback: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/oauth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth login page
         * @summary Oauth Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthLogin: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/oauth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth login with GitHub
         * @summary Oauth Login Github
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthLoginGithub: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/oauth/login/github`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth login with Google
         * @summary Oauth Login Google
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthLoginGoogle: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/oauth/login/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth login form submission
         * @summary Oauth Login Post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthLoginPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/oauth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth login with Shopify for app installation
         * @summary Oauth Login Shopify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthLoginShopify: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/oauth/login/shopify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth logout endpoint - revokes tokens, clears session and redirects to specified URL
         * @summary Oauth Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/oauth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth token revocation endpoint
         * @summary Oauth Revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthRevoke: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/oauth/revoke`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth token endpoint
         * @summary Oauth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/oauth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OpenID Connect userinfo endpoint
         * @summary Oauth Userinfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthUserinfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/oauth/userinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * SAML callback endpoint (Assertion Consumer Service) Handles the SAML response from the Identity Provider after successful authentication
         * @summary Saml Callback
         * @param {string} randomId 
         * @param {string} [workspaceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        samlCallback: async (randomId: string, workspaceId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'randomId' is not null or undefined
            assertParamExists('samlCallback', 'randomId', randomId)
            const localVarPath = `/v2/auth/oauth/callback/saml/{random_id}`
                .replace(`{${"random_id"}}`, encodeURIComponent(String(randomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * OAuth authorization endpoint
         * @summary Oauth Authorize
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthAuthorize(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthAuthorize(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthAuthorize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth authorization endpoint (consent form submission)
         * @summary Oauth Authorize Post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthAuthorizePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthAuthorizePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthAuthorizePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth callback endpoint for third-party providers
         * @summary Oauth Callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthCallback(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthCallback(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth login page
         * @summary Oauth Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthLogin(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthLogin(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth login with GitHub
         * @summary Oauth Login Github
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthLoginGithub(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthLoginGithub(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthLoginGithub']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth login with Google
         * @summary Oauth Login Google
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthLoginGoogle(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthLoginGoogle(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthLoginGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth login form submission
         * @summary Oauth Login Post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthLoginPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthLoginPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth login with Shopify for app installation
         * @summary Oauth Login Shopify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthLoginShopify(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthLoginShopify(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthLoginShopify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth logout endpoint - revokes tokens, clears session and redirects to specified URL
         * @summary Oauth Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth token revocation endpoint
         * @summary Oauth Revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthRevoke(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthRevoke(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthRevoke']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth token endpoint
         * @summary Oauth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OpenID Connect userinfo endpoint
         * @summary Oauth Userinfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthUserinfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthUserinfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthUserinfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * SAML callback endpoint (Assertion Consumer Service) Handles the SAML response from the Identity Provider after successful authentication
         * @summary Saml Callback
         * @param {string} randomId 
         * @param {string} [workspaceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async samlCallback(randomId: string, workspaceId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.samlCallback(randomId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.samlCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthApiFp(configuration)
    return {
        /**
         * OAuth authorization endpoint
         * @summary Oauth Authorize
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAuthorize(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.oauthAuthorize(options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth authorization endpoint (consent form submission)
         * @summary Oauth Authorize Post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAuthorizePost(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.oauthAuthorizePost(options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth callback endpoint for third-party providers
         * @summary Oauth Callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthCallback(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.oauthCallback(options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth login page
         * @summary Oauth Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthLogin(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.oauthLogin(options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth login with GitHub
         * @summary Oauth Login Github
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthLoginGithub(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.oauthLoginGithub(options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth login with Google
         * @summary Oauth Login Google
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthLoginGoogle(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.oauthLoginGoogle(options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth login form submission
         * @summary Oauth Login Post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthLoginPost(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.oauthLoginPost(options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth login with Shopify for app installation
         * @summary Oauth Login Shopify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthLoginShopify(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.oauthLoginShopify(options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth logout endpoint - revokes tokens, clears session and redirects to specified URL
         * @summary Oauth Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthLogout(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.oauthLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth token revocation endpoint
         * @summary Oauth Revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthRevoke(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.oauthRevoke(options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth token endpoint
         * @summary Oauth Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthToken(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.oauthToken(options).then((request) => request(axios, basePath));
        },
        /**
         * OpenID Connect userinfo endpoint
         * @summary Oauth Userinfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthUserinfo(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.oauthUserinfo(options).then((request) => request(axios, basePath));
        },
        /**
         * SAML callback endpoint (Assertion Consumer Service) Handles the SAML response from the Identity Provider after successful authentication
         * @summary Saml Callback
         * @param {OAuthApiSamlCallbackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        samlCallback(requestParameters: OAuthApiSamlCallbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.samlCallback(requestParameters.randomId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuthApi - interface
 * @export
 * @interface OAuthApi
 */
export interface OAuthApiInterface {
    /**
     * OAuth authorization endpoint
     * @summary Oauth Authorize
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApiInterface
     */
    oauthAuthorize(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * OAuth authorization endpoint (consent form submission)
     * @summary Oauth Authorize Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApiInterface
     */
    oauthAuthorizePost(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * OAuth callback endpoint for third-party providers
     * @summary Oauth Callback
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApiInterface
     */
    oauthCallback(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * OAuth login page
     * @summary Oauth Login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApiInterface
     */
    oauthLogin(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * OAuth login with GitHub
     * @summary Oauth Login Github
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApiInterface
     */
    oauthLoginGithub(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * OAuth login with Google
     * @summary Oauth Login Google
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApiInterface
     */
    oauthLoginGoogle(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * OAuth login form submission
     * @summary Oauth Login Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApiInterface
     */
    oauthLoginPost(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * OAuth login with Shopify for app installation
     * @summary Oauth Login Shopify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApiInterface
     */
    oauthLoginShopify(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * OAuth logout endpoint - revokes tokens, clears session and redirects to specified URL
     * @summary Oauth Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApiInterface
     */
    oauthLogout(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * OAuth token revocation endpoint
     * @summary Oauth Revoke
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApiInterface
     */
    oauthRevoke(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * OAuth token endpoint
     * @summary Oauth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApiInterface
     */
    oauthToken(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * OpenID Connect userinfo endpoint
     * @summary Oauth Userinfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApiInterface
     */
    oauthUserinfo(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * SAML callback endpoint (Assertion Consumer Service) Handles the SAML response from the Identity Provider after successful authentication
     * @summary Saml Callback
     * @param {OAuthApiSamlCallbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApiInterface
     */
    samlCallback(requestParameters: OAuthApiSamlCallbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

}

/**
 * Request parameters for samlCallback operation in OAuthApi.
 * @export
 * @interface OAuthApiSamlCallbackRequest
 */
export interface OAuthApiSamlCallbackRequest {
    /**
     * 
     * @type {string}
     * @memberof OAuthApiSamlCallback
     */
    readonly randomId: string

    /**
     * 
     * @type {string}
     * @memberof OAuthApiSamlCallback
     */
    readonly workspaceId?: string
}

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI implements OAuthApiInterface {
    /**
     * OAuth authorization endpoint
     * @summary Oauth Authorize
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthAuthorize(options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthAuthorize(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth authorization endpoint (consent form submission)
     * @summary Oauth Authorize Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthAuthorizePost(options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthAuthorizePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth callback endpoint for third-party providers
     * @summary Oauth Callback
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthCallback(options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthCallback(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth login page
     * @summary Oauth Login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthLogin(options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthLogin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth login with GitHub
     * @summary Oauth Login Github
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthLoginGithub(options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthLoginGithub(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth login with Google
     * @summary Oauth Login Google
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthLoginGoogle(options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthLoginGoogle(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth login form submission
     * @summary Oauth Login Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthLoginPost(options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthLoginPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth login with Shopify for app installation
     * @summary Oauth Login Shopify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthLoginShopify(options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthLoginShopify(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth logout endpoint - revokes tokens, clears session and redirects to specified URL
     * @summary Oauth Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthLogout(options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth token revocation endpoint
     * @summary Oauth Revoke
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthRevoke(options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthRevoke(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth token endpoint
     * @summary Oauth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthToken(options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OpenID Connect userinfo endpoint
     * @summary Oauth Userinfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthUserinfo(options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthUserinfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * SAML callback endpoint (Assertion Consumer Service) Handles the SAML response from the Identity Provider after successful authentication
     * @summary Saml Callback
     * @param {OAuthApiSamlCallbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public samlCallback(requestParameters: OAuthApiSamlCallbackRequest, options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).samlCallback(requestParameters.randomId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ObservabilityDriverApi - axios parameter creator
 * @export
 */
export const ObservabilityDriverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Activate Langfuse Observability Driver
         * @param {string} workspaceId 
         * @param {LangfuseRequest} langfuseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateLangfuseObservabilityDriver: async (workspaceId: string, langfuseRequest: LangfuseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('activateLangfuseObservabilityDriver', 'workspaceId', workspaceId)
            // verify required parameter 'langfuseRequest' is not null or undefined
            assertParamExists('activateLangfuseObservabilityDriver', 'langfuseRequest', langfuseRequest)
            const localVarPath = `/v2/observability_driver/langfuse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(langfuseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Activate Power Bi Observability Driver
         * @param {string} workspaceId 
         * @param {PowerBiRequest} powerBiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePowerBiObservabilityDriver: async (workspaceId: string, powerBiRequest: PowerBiRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('activatePowerBiObservabilityDriver', 'workspaceId', workspaceId)
            // verify required parameter 'powerBiRequest' is not null or undefined
            assertParamExists('activatePowerBiObservabilityDriver', 'powerBiRequest', powerBiRequest)
            const localVarPath = `/v2/observability_driver/power_bi`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(powerBiRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Power Bi Push Dataset
         * @param {string} workspaceId 
         * @param {PowerBiPushDatasetRequest} powerBiPushDatasetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPowerBiPushDataset: async (workspaceId: string, powerBiPushDatasetRequest: PowerBiPushDatasetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createPowerBiPushDataset', 'workspaceId', workspaceId)
            // verify required parameter 'powerBiPushDatasetRequest' is not null or undefined
            assertParamExists('createPowerBiPushDataset', 'powerBiPushDatasetRequest', powerBiPushDatasetRequest)
            const localVarPath = `/v2/observability_driver/power_bi/push_dataset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(powerBiPushDatasetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Observability Driver
         * @param {DriverType} driverType 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObservabilityDriver: async (driverType: DriverType, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driverType' is not null or undefined
            assertParamExists('deleteObservabilityDriver', 'driverType', driverType)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteObservabilityDriver', 'workspaceId', workspaceId)
            const localVarPath = `/v2/observability_driver/{driver_type}`
                .replace(`{${"driver_type"}}`, encodeURIComponent(String(driverType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Observability Driver
         * @param {DriverType} driverType 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObservabilityDriver: async (driverType: DriverType, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'driverType' is not null or undefined
            assertParamExists('getObservabilityDriver', 'driverType', driverType)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getObservabilityDriver', 'workspaceId', workspaceId)
            const localVarPath = `/v2/observability_driver/{driver_type}`
                .replace(`{${"driver_type"}}`, encodeURIComponent(String(driverType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Observability Driver Workspace
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObservabilityDriverWorkspace: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getObservabilityDriverWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/v2/observability_driver/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Power Bi Datasets
         * @param {string} workspaceId 
         * @param {PowerBiDatasetRequest} powerBiDatasetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPowerBiDatasets: async (workspaceId: string, powerBiDatasetRequest: PowerBiDatasetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listPowerBiDatasets', 'workspaceId', workspaceId)
            // verify required parameter 'powerBiDatasetRequest' is not null or undefined
            assertParamExists('listPowerBiDatasets', 'powerBiDatasetRequest', powerBiDatasetRequest)
            const localVarPath = `/v2/observability_driver/power_bi/datasets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(powerBiDatasetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Power Bi Tables
         * @param {string} workspaceId 
         * @param {PowerBiTableRequest} powerBiTableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPowerBiTables: async (workspaceId: string, powerBiTableRequest: PowerBiTableRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listPowerBiTables', 'workspaceId', workspaceId)
            // verify required parameter 'powerBiTableRequest' is not null or undefined
            assertParamExists('listPowerBiTables', 'powerBiTableRequest', powerBiTableRequest)
            const localVarPath = `/v2/observability_driver/power_bi/tables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(powerBiTableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Power Bi Workspaces
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPowerBiWorkspaces: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listPowerBiWorkspaces', 'workspaceId', workspaceId)
            const localVarPath = `/v2/observability_driver/power_bi/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Langfuse Observability Driver
         * @param {string} workspaceId 
         * @param {LangfuseRequest} langfuseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLangfuseObservabilityDriver: async (workspaceId: string, langfuseRequest: LangfuseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateLangfuseObservabilityDriver', 'workspaceId', workspaceId)
            // verify required parameter 'langfuseRequest' is not null or undefined
            assertParamExists('updateLangfuseObservabilityDriver', 'langfuseRequest', langfuseRequest)
            const localVarPath = `/v2/observability_driver/langfuse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(langfuseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Power Bi Observability Driver
         * @param {string} workspaceId 
         * @param {PowerBiRequest} powerBiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePowerBiObservabilityDriver: async (workspaceId: string, powerBiRequest: PowerBiRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updatePowerBiObservabilityDriver', 'workspaceId', workspaceId)
            // verify required parameter 'powerBiRequest' is not null or undefined
            assertParamExists('updatePowerBiObservabilityDriver', 'powerBiRequest', powerBiRequest)
            const localVarPath = `/v2/observability_driver/power_bi`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(powerBiRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate Push Dataset Table
         * @param {string} workspaceId 
         * @param {PowerBiRequest} powerBiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePushDatasetTable: async (workspaceId: string, powerBiRequest: PowerBiRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('validatePushDatasetTable', 'workspaceId', workspaceId)
            // verify required parameter 'powerBiRequest' is not null or undefined
            assertParamExists('validatePushDatasetTable', 'powerBiRequest', powerBiRequest)
            const localVarPath = `/v2/observability_driver/power_bi/validate_push_dataset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(powerBiRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObservabilityDriverApi - functional programming interface
 * @export
 */
export const ObservabilityDriverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ObservabilityDriverApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Activate Langfuse Observability Driver
         * @param {string} workspaceId 
         * @param {LangfuseRequest} langfuseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateLangfuseObservabilityDriver(workspaceId: string, langfuseRequest: LangfuseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservabilityDriverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateLangfuseObservabilityDriver(workspaceId, langfuseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.activateLangfuseObservabilityDriver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Activate Power Bi Observability Driver
         * @param {string} workspaceId 
         * @param {PowerBiRequest} powerBiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activatePowerBiObservabilityDriver(workspaceId: string, powerBiRequest: PowerBiRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservabilityDriverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activatePowerBiObservabilityDriver(workspaceId, powerBiRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.activatePowerBiObservabilityDriver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Power Bi Push Dataset
         * @param {string} workspaceId 
         * @param {PowerBiPushDatasetRequest} powerBiPushDatasetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPowerBiPushDataset(workspaceId: string, powerBiPushDatasetRequest: PowerBiPushDatasetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MicrosoftPowerBiPushDatasetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPowerBiPushDataset(workspaceId, powerBiPushDatasetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.createPowerBiPushDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Observability Driver
         * @param {DriverType} driverType 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteObservabilityDriver(driverType: DriverType, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteObservabilityDriver(driverType, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.deleteObservabilityDriver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Observability Driver
         * @param {DriverType} driverType 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getObservabilityDriver(driverType: DriverType, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservabilityDriverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getObservabilityDriver(driverType, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.getObservabilityDriver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Observability Driver Workspace
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getObservabilityDriverWorkspace(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ObservabilityDriverResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getObservabilityDriverWorkspace(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.getObservabilityDriverWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Power Bi Datasets
         * @param {string} workspaceId 
         * @param {PowerBiDatasetRequest} powerBiDatasetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPowerBiDatasets(workspaceId: string, powerBiDatasetRequest: PowerBiDatasetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MicrosoftPowerBiDatasetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPowerBiDatasets(workspaceId, powerBiDatasetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.listPowerBiDatasets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Power Bi Tables
         * @param {string} workspaceId 
         * @param {PowerBiTableRequest} powerBiTableRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPowerBiTables(workspaceId: string, powerBiTableRequest: PowerBiTableRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MicrosoftPowerBiTablesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPowerBiTables(workspaceId, powerBiTableRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.listPowerBiTables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Power Bi Workspaces
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPowerBiWorkspaces(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MicrosoftPowerBiWorkspacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPowerBiWorkspaces(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.listPowerBiWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Langfuse Observability Driver
         * @param {string} workspaceId 
         * @param {LangfuseRequest} langfuseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLangfuseObservabilityDriver(workspaceId: string, langfuseRequest: LangfuseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservabilityDriverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLangfuseObservabilityDriver(workspaceId, langfuseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.updateLangfuseObservabilityDriver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Power Bi Observability Driver
         * @param {string} workspaceId 
         * @param {PowerBiRequest} powerBiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePowerBiObservabilityDriver(workspaceId: string, powerBiRequest: PowerBiRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservabilityDriverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePowerBiObservabilityDriver(workspaceId, powerBiRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.updatePowerBiObservabilityDriver']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Validate Push Dataset Table
         * @param {string} workspaceId 
         * @param {PowerBiRequest} powerBiRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatePushDatasetTable(workspaceId: string, powerBiRequest: PowerBiRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MicrosoftPowerBiTableValidateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatePushDatasetTable(workspaceId, powerBiRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObservabilityDriverApi.validatePushDatasetTable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ObservabilityDriverApi - factory interface
 * @export
 */
export const ObservabilityDriverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ObservabilityDriverApiFp(configuration)
    return {
        /**
         * 
         * @summary Activate Langfuse Observability Driver
         * @param {ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateLangfuseObservabilityDriver(requestParameters: ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse> {
            return localVarFp.activateLangfuseObservabilityDriver(requestParameters.workspaceId, requestParameters.langfuseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Activate Power Bi Observability Driver
         * @param {ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activatePowerBiObservabilityDriver(requestParameters: ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse> {
            return localVarFp.activatePowerBiObservabilityDriver(requestParameters.workspaceId, requestParameters.powerBiRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Power Bi Push Dataset
         * @param {ObservabilityDriverApiCreatePowerBiPushDatasetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPowerBiPushDataset(requestParameters: ObservabilityDriverApiCreatePowerBiPushDatasetRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiPushDatasetResponse> {
            return localVarFp.createPowerBiPushDataset(requestParameters.workspaceId, requestParameters.powerBiPushDatasetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Observability Driver
         * @param {ObservabilityDriverApiDeleteObservabilityDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteObservabilityDriver(requestParameters: ObservabilityDriverApiDeleteObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<DriverSuccessResponse> {
            return localVarFp.deleteObservabilityDriver(requestParameters.driverType, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Observability Driver
         * @param {ObservabilityDriverApiGetObservabilityDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObservabilityDriver(requestParameters: ObservabilityDriverApiGetObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse> {
            return localVarFp.getObservabilityDriver(requestParameters.driverType, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Observability Driver Workspace
         * @param {ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObservabilityDriverWorkspace(requestParameters: ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ObservabilityDriverResponse>> {
            return localVarFp.getObservabilityDriverWorkspace(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Power Bi Datasets
         * @param {ObservabilityDriverApiListPowerBiDatasetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPowerBiDatasets(requestParameters: ObservabilityDriverApiListPowerBiDatasetsRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiDatasetsResponse> {
            return localVarFp.listPowerBiDatasets(requestParameters.workspaceId, requestParameters.powerBiDatasetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Power Bi Tables
         * @param {ObservabilityDriverApiListPowerBiTablesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPowerBiTables(requestParameters: ObservabilityDriverApiListPowerBiTablesRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiTablesResponse> {
            return localVarFp.listPowerBiTables(requestParameters.workspaceId, requestParameters.powerBiTableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Power Bi Workspaces
         * @param {ObservabilityDriverApiListPowerBiWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPowerBiWorkspaces(requestParameters: ObservabilityDriverApiListPowerBiWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiWorkspacesResponse> {
            return localVarFp.listPowerBiWorkspaces(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Langfuse Observability Driver
         * @param {ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLangfuseObservabilityDriver(requestParameters: ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse> {
            return localVarFp.updateLangfuseObservabilityDriver(requestParameters.workspaceId, requestParameters.langfuseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Power Bi Observability Driver
         * @param {ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePowerBiObservabilityDriver(requestParameters: ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse> {
            return localVarFp.updatePowerBiObservabilityDriver(requestParameters.workspaceId, requestParameters.powerBiRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate Push Dataset Table
         * @param {ObservabilityDriverApiValidatePushDatasetTableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePushDatasetTable(requestParameters: ObservabilityDriverApiValidatePushDatasetTableRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiTableValidateResponse> {
            return localVarFp.validatePushDatasetTable(requestParameters.workspaceId, requestParameters.powerBiRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObservabilityDriverApi - interface
 * @export
 * @interface ObservabilityDriverApi
 */
export interface ObservabilityDriverApiInterface {
    /**
     * 
     * @summary Activate Langfuse Observability Driver
     * @param {ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    activateLangfuseObservabilityDriver(requestParameters: ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse>;

    /**
     * 
     * @summary Activate Power Bi Observability Driver
     * @param {ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    activatePowerBiObservabilityDriver(requestParameters: ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse>;

    /**
     * 
     * @summary Create Power Bi Push Dataset
     * @param {ObservabilityDriverApiCreatePowerBiPushDatasetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    createPowerBiPushDataset(requestParameters: ObservabilityDriverApiCreatePowerBiPushDatasetRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiPushDatasetResponse>;

    /**
     * 
     * @summary Delete Observability Driver
     * @param {ObservabilityDriverApiDeleteObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    deleteObservabilityDriver(requestParameters: ObservabilityDriverApiDeleteObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<DriverSuccessResponse>;

    /**
     * 
     * @summary Get Observability Driver
     * @param {ObservabilityDriverApiGetObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    getObservabilityDriver(requestParameters: ObservabilityDriverApiGetObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse>;

    /**
     * 
     * @summary Get Observability Driver Workspace
     * @param {ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    getObservabilityDriverWorkspace(requestParameters: ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ObservabilityDriverResponse>>;

    /**
     * 
     * @summary List Power Bi Datasets
     * @param {ObservabilityDriverApiListPowerBiDatasetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    listPowerBiDatasets(requestParameters: ObservabilityDriverApiListPowerBiDatasetsRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiDatasetsResponse>;

    /**
     * 
     * @summary List Power Bi Tables
     * @param {ObservabilityDriverApiListPowerBiTablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    listPowerBiTables(requestParameters: ObservabilityDriverApiListPowerBiTablesRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiTablesResponse>;

    /**
     * 
     * @summary List Power Bi Workspaces
     * @param {ObservabilityDriverApiListPowerBiWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    listPowerBiWorkspaces(requestParameters: ObservabilityDriverApiListPowerBiWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiWorkspacesResponse>;

    /**
     * 
     * @summary Update Langfuse Observability Driver
     * @param {ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    updateLangfuseObservabilityDriver(requestParameters: ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse>;

    /**
     * 
     * @summary Update Power Bi Observability Driver
     * @param {ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    updatePowerBiObservabilityDriver(requestParameters: ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservabilityDriverResponse>;

    /**
     * 
     * @summary Validate Push Dataset Table
     * @param {ObservabilityDriverApiValidatePushDatasetTableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApiInterface
     */
    validatePushDatasetTable(requestParameters: ObservabilityDriverApiValidatePushDatasetTableRequest, options?: RawAxiosRequestConfig): AxiosPromise<MicrosoftPowerBiTableValidateResponse>;

}

/**
 * Request parameters for activateLangfuseObservabilityDriver operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest
 */
export interface ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiActivateLangfuseObservabilityDriver
     */
    readonly workspaceId: string

    /**
     * 
     * @type {LangfuseRequest}
     * @memberof ObservabilityDriverApiActivateLangfuseObservabilityDriver
     */
    readonly langfuseRequest: LangfuseRequest
}

/**
 * Request parameters for activatePowerBiObservabilityDriver operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest
 */
export interface ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiActivatePowerBiObservabilityDriver
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PowerBiRequest}
     * @memberof ObservabilityDriverApiActivatePowerBiObservabilityDriver
     */
    readonly powerBiRequest: PowerBiRequest
}

/**
 * Request parameters for createPowerBiPushDataset operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiCreatePowerBiPushDatasetRequest
 */
export interface ObservabilityDriverApiCreatePowerBiPushDatasetRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiCreatePowerBiPushDataset
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PowerBiPushDatasetRequest}
     * @memberof ObservabilityDriverApiCreatePowerBiPushDataset
     */
    readonly powerBiPushDatasetRequest: PowerBiPushDatasetRequest
}

/**
 * Request parameters for deleteObservabilityDriver operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiDeleteObservabilityDriverRequest
 */
export interface ObservabilityDriverApiDeleteObservabilityDriverRequest {
    /**
     * 
     * @type {DriverType}
     * @memberof ObservabilityDriverApiDeleteObservabilityDriver
     */
    readonly driverType: DriverType

    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiDeleteObservabilityDriver
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getObservabilityDriver operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiGetObservabilityDriverRequest
 */
export interface ObservabilityDriverApiGetObservabilityDriverRequest {
    /**
     * 
     * @type {DriverType}
     * @memberof ObservabilityDriverApiGetObservabilityDriver
     */
    readonly driverType: DriverType

    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiGetObservabilityDriver
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getObservabilityDriverWorkspace operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest
 */
export interface ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiGetObservabilityDriverWorkspace
     */
    readonly workspaceId: string
}

/**
 * Request parameters for listPowerBiDatasets operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiListPowerBiDatasetsRequest
 */
export interface ObservabilityDriverApiListPowerBiDatasetsRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiListPowerBiDatasets
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PowerBiDatasetRequest}
     * @memberof ObservabilityDriverApiListPowerBiDatasets
     */
    readonly powerBiDatasetRequest: PowerBiDatasetRequest
}

/**
 * Request parameters for listPowerBiTables operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiListPowerBiTablesRequest
 */
export interface ObservabilityDriverApiListPowerBiTablesRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiListPowerBiTables
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PowerBiTableRequest}
     * @memberof ObservabilityDriverApiListPowerBiTables
     */
    readonly powerBiTableRequest: PowerBiTableRequest
}

/**
 * Request parameters for listPowerBiWorkspaces operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiListPowerBiWorkspacesRequest
 */
export interface ObservabilityDriverApiListPowerBiWorkspacesRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiListPowerBiWorkspaces
     */
    readonly workspaceId: string
}

/**
 * Request parameters for updateLangfuseObservabilityDriver operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest
 */
export interface ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiUpdateLangfuseObservabilityDriver
     */
    readonly workspaceId: string

    /**
     * 
     * @type {LangfuseRequest}
     * @memberof ObservabilityDriverApiUpdateLangfuseObservabilityDriver
     */
    readonly langfuseRequest: LangfuseRequest
}

/**
 * Request parameters for updatePowerBiObservabilityDriver operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest
 */
export interface ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiUpdatePowerBiObservabilityDriver
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PowerBiRequest}
     * @memberof ObservabilityDriverApiUpdatePowerBiObservabilityDriver
     */
    readonly powerBiRequest: PowerBiRequest
}

/**
 * Request parameters for validatePushDatasetTable operation in ObservabilityDriverApi.
 * @export
 * @interface ObservabilityDriverApiValidatePushDatasetTableRequest
 */
export interface ObservabilityDriverApiValidatePushDatasetTableRequest {
    /**
     * 
     * @type {string}
     * @memberof ObservabilityDriverApiValidatePushDatasetTable
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PowerBiRequest}
     * @memberof ObservabilityDriverApiValidatePushDatasetTable
     */
    readonly powerBiRequest: PowerBiRequest
}

/**
 * ObservabilityDriverApi - object-oriented interface
 * @export
 * @class ObservabilityDriverApi
 * @extends {BaseAPI}
 */
export class ObservabilityDriverApi extends BaseAPI implements ObservabilityDriverApiInterface {
    /**
     * 
     * @summary Activate Langfuse Observability Driver
     * @param {ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public activateLangfuseObservabilityDriver(requestParameters: ObservabilityDriverApiActivateLangfuseObservabilityDriverRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).activateLangfuseObservabilityDriver(requestParameters.workspaceId, requestParameters.langfuseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Activate Power Bi Observability Driver
     * @param {ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public activatePowerBiObservabilityDriver(requestParameters: ObservabilityDriverApiActivatePowerBiObservabilityDriverRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).activatePowerBiObservabilityDriver(requestParameters.workspaceId, requestParameters.powerBiRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Power Bi Push Dataset
     * @param {ObservabilityDriverApiCreatePowerBiPushDatasetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public createPowerBiPushDataset(requestParameters: ObservabilityDriverApiCreatePowerBiPushDatasetRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).createPowerBiPushDataset(requestParameters.workspaceId, requestParameters.powerBiPushDatasetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Observability Driver
     * @param {ObservabilityDriverApiDeleteObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public deleteObservabilityDriver(requestParameters: ObservabilityDriverApiDeleteObservabilityDriverRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).deleteObservabilityDriver(requestParameters.driverType, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Observability Driver
     * @param {ObservabilityDriverApiGetObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public getObservabilityDriver(requestParameters: ObservabilityDriverApiGetObservabilityDriverRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).getObservabilityDriver(requestParameters.driverType, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Observability Driver Workspace
     * @param {ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public getObservabilityDriverWorkspace(requestParameters: ObservabilityDriverApiGetObservabilityDriverWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).getObservabilityDriverWorkspace(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Power Bi Datasets
     * @param {ObservabilityDriverApiListPowerBiDatasetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public listPowerBiDatasets(requestParameters: ObservabilityDriverApiListPowerBiDatasetsRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).listPowerBiDatasets(requestParameters.workspaceId, requestParameters.powerBiDatasetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Power Bi Tables
     * @param {ObservabilityDriverApiListPowerBiTablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public listPowerBiTables(requestParameters: ObservabilityDriverApiListPowerBiTablesRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).listPowerBiTables(requestParameters.workspaceId, requestParameters.powerBiTableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Power Bi Workspaces
     * @param {ObservabilityDriverApiListPowerBiWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public listPowerBiWorkspaces(requestParameters: ObservabilityDriverApiListPowerBiWorkspacesRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).listPowerBiWorkspaces(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Langfuse Observability Driver
     * @param {ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public updateLangfuseObservabilityDriver(requestParameters: ObservabilityDriverApiUpdateLangfuseObservabilityDriverRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).updateLangfuseObservabilityDriver(requestParameters.workspaceId, requestParameters.langfuseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Power Bi Observability Driver
     * @param {ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public updatePowerBiObservabilityDriver(requestParameters: ObservabilityDriverApiUpdatePowerBiObservabilityDriverRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).updatePowerBiObservabilityDriver(requestParameters.workspaceId, requestParameters.powerBiRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate Push Dataset Table
     * @param {ObservabilityDriverApiValidatePushDatasetTableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObservabilityDriverApi
     */
    public validatePushDatasetTable(requestParameters: ObservabilityDriverApiValidatePushDatasetTableRequest, options?: RawAxiosRequestConfig) {
        return ObservabilityDriverApiFp(this.configuration).validatePushDatasetTable(requestParameters.workspaceId, requestParameters.powerBiRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PhotoAIApi - axios parameter creator
 * @export
 */
export const PhotoAIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Explore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explore: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/photo_ai/public/explore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Effects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffects: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/photo_ai/public/effects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStyles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/photo_ai/public/styles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/photo_ai/public/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhotoAIApi - functional programming interface
 * @export
 */
export const PhotoAIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PhotoAIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Explore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explore(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommunityImageGenerationsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explore(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhotoAIApi.explore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Effects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEffects(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PhotoAIEffectResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEffects(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhotoAIApi.getEffects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStyles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PhotoAIStyleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStyles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhotoAIApi.getStyles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PhotoAITemplateResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhotoAIApi.getTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PhotoAIApi - factory interface
 * @export
 */
export const PhotoAIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PhotoAIApiFp(configuration)
    return {
        /**
         * 
         * @summary Explore
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explore(options?: RawAxiosRequestConfig): AxiosPromise<Array<CommunityImageGenerationsResponse>> {
            return localVarFp.explore(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Effects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffects(options?: RawAxiosRequestConfig): AxiosPromise<Array<PhotoAIEffectResponse>> {
            return localVarFp.getEffects(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStyles(options?: RawAxiosRequestConfig): AxiosPromise<Array<PhotoAIStyleResponse>> {
            return localVarFp.getStyles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(options?: RawAxiosRequestConfig): AxiosPromise<Array<PhotoAITemplateResponse>> {
            return localVarFp.getTemplates(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PhotoAIApi - interface
 * @export
 * @interface PhotoAIApi
 */
export interface PhotoAIApiInterface {
    /**
     * 
     * @summary Explore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApiInterface
     */
    explore(options?: RawAxiosRequestConfig): AxiosPromise<Array<CommunityImageGenerationsResponse>>;

    /**
     * 
     * @summary Get Effects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApiInterface
     */
    getEffects(options?: RawAxiosRequestConfig): AxiosPromise<Array<PhotoAIEffectResponse>>;

    /**
     * 
     * @summary Get Styles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApiInterface
     */
    getStyles(options?: RawAxiosRequestConfig): AxiosPromise<Array<PhotoAIStyleResponse>>;

    /**
     * 
     * @summary Get Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApiInterface
     */
    getTemplates(options?: RawAxiosRequestConfig): AxiosPromise<Array<PhotoAITemplateResponse>>;

}

/**
 * PhotoAIApi - object-oriented interface
 * @export
 * @class PhotoAIApi
 * @extends {BaseAPI}
 */
export class PhotoAIApi extends BaseAPI implements PhotoAIApiInterface {
    /**
     * 
     * @summary Explore
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApi
     */
    public explore(options?: RawAxiosRequestConfig) {
        return PhotoAIApiFp(this.configuration).explore(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Effects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApi
     */
    public getEffects(options?: RawAxiosRequestConfig) {
        return PhotoAIApiFp(this.configuration).getEffects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Styles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApi
     */
    public getStyles(options?: RawAxiosRequestConfig) {
        return PhotoAIApiFp(this.configuration).getStyles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotoAIApi
     */
    public getTemplates(options?: RawAxiosRequestConfig) {
        return PhotoAIApiFp(this.configuration).getTemplates(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptsApi - axios parameter creator
 * @export
 */
export const PromptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Prompt
         * @param {string} workspaceId 
         * @param {PromptCreateRequest} promptCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrompt: async (workspaceId: string, promptCreateRequest: PromptCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createPrompt', 'workspaceId', workspaceId)
            // verify required parameter 'promptCreateRequest' is not null or undefined
            assertParamExists('createPrompt', 'promptCreateRequest', promptCreateRequest)
            const localVarPath = `/v2/prompts/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Prompt Category
         * @param {string} workspaceId 
         * @param {PromptCategoryCreateRequest} promptCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPromptCategory: async (workspaceId: string, promptCategoryCreateRequest: PromptCategoryCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createPromptCategory', 'workspaceId', workspaceId)
            // verify required parameter 'promptCategoryCreateRequest' is not null or undefined
            assertParamExists('createPromptCategory', 'promptCategoryCreateRequest', promptCategoryCreateRequest)
            const localVarPath = `/v2/prompts/categories/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptCategoryCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Prompt
         * @param {string} promptId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrompt: async (promptId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('deletePrompt', 'promptId', promptId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deletePrompt', 'workspaceId', workspaceId)
            const localVarPath = `/v2/prompts/{prompt_id}`
                .replace(`{${"prompt_id"}}`, encodeURIComponent(String(promptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Prompt Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePromptCategory: async (catId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('deletePromptCategory', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deletePromptCategory', 'workspaceId', workspaceId)
            const localVarPath = `/v2/prompts/categories/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Prompt Categories
         * @param {string} workspaceId 
         * @param {PromptCategorySearchRequest} promptCategorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPromptCategories: async (workspaceId: string, promptCategorySearchRequest: PromptCategorySearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchPromptCategories', 'workspaceId', workspaceId)
            // verify required parameter 'promptCategorySearchRequest' is not null or undefined
            assertParamExists('searchPromptCategories', 'promptCategorySearchRequest', promptCategorySearchRequest)
            const localVarPath = `/v2/prompts/categories/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptCategorySearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Prompts
         * @param {string} workspaceId 
         * @param {PromptSearchRequest} promptSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPrompts: async (workspaceId: string, promptSearchRequest: PromptSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchPrompts', 'workspaceId', workspaceId)
            // verify required parameter 'promptSearchRequest' is not null or undefined
            assertParamExists('searchPrompts', 'promptSearchRequest', promptSearchRequest)
            const localVarPath = `/v2/prompts/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Prompt
         * @param {string} promptId 
         * @param {string} workspaceId 
         * @param {PromptUpdateRequest} promptUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrompt: async (promptId: string, workspaceId: string, promptUpdateRequest: PromptUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('updatePrompt', 'promptId', promptId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updatePrompt', 'workspaceId', workspaceId)
            // verify required parameter 'promptUpdateRequest' is not null or undefined
            assertParamExists('updatePrompt', 'promptUpdateRequest', promptUpdateRequest)
            const localVarPath = `/v2/prompts/{prompt_id}`
                .replace(`{${"prompt_id"}}`, encodeURIComponent(String(promptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Prompt Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {PromptCategoryUpdateRequest} promptCategoryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePromptCategory: async (catId: string, workspaceId: string, promptCategoryUpdateRequest: PromptCategoryUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catId' is not null or undefined
            assertParamExists('updatePromptCategory', 'catId', catId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updatePromptCategory', 'workspaceId', workspaceId)
            // verify required parameter 'promptCategoryUpdateRequest' is not null or undefined
            assertParamExists('updatePromptCategory', 'promptCategoryUpdateRequest', promptCategoryUpdateRequest)
            const localVarPath = `/v2/prompts/categories/{cat_id}`
                .replace(`{${"cat_id"}}`, encodeURIComponent(String(catId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptCategoryUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptsApi - functional programming interface
 * @export
 */
export const PromptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Prompt
         * @param {string} workspaceId 
         * @param {PromptCreateRequest} promptCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPrompt(workspaceId: string, promptCreateRequest: PromptCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPrompt(workspaceId, promptCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.createPrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Prompt Category
         * @param {string} workspaceId 
         * @param {PromptCategoryCreateRequest} promptCategoryCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPromptCategory(workspaceId: string, promptCategoryCreateRequest: PromptCategoryCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPromptCategory(workspaceId, promptCategoryCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.createPromptCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Prompt
         * @param {string} promptId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePrompt(promptId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePrompt(promptId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.deletePrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Prompt Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePromptCategory(catId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePromptCategory(catId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.deletePromptCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Prompt Categories
         * @param {string} workspaceId 
         * @param {PromptCategorySearchRequest} promptCategorySearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPromptCategories(workspaceId: string, promptCategorySearchRequest: PromptCategorySearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PromptCategoryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPromptCategories(workspaceId, promptCategorySearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.searchPromptCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Prompts
         * @param {string} workspaceId 
         * @param {PromptSearchRequest} promptSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPrompts(workspaceId: string, promptSearchRequest: PromptSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PromptResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPrompts(workspaceId, promptSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.searchPrompts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Prompt
         * @param {string} promptId 
         * @param {string} workspaceId 
         * @param {PromptUpdateRequest} promptUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePrompt(promptId: string, workspaceId: string, promptUpdateRequest: PromptUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePrompt(promptId, workspaceId, promptUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.updatePrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Prompt Category
         * @param {string} catId 
         * @param {string} workspaceId 
         * @param {PromptCategoryUpdateRequest} promptCategoryUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePromptCategory(catId: string, workspaceId: string, promptCategoryUpdateRequest: PromptCategoryUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptCategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePromptCategory(catId, workspaceId, promptCategoryUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.updatePromptCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptsApi - factory interface
 * @export
 */
export const PromptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Prompt
         * @param {PromptsApiCreatePromptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrompt(requestParameters: PromptsApiCreatePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse> {
            return localVarFp.createPrompt(requestParameters.workspaceId, requestParameters.promptCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Prompt Category
         * @param {PromptsApiCreatePromptCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPromptCategory(requestParameters: PromptsApiCreatePromptCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptCategoryResponse> {
            return localVarFp.createPromptCategory(requestParameters.workspaceId, requestParameters.promptCategoryCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Prompt
         * @param {PromptsApiDeletePromptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrompt(requestParameters: PromptsApiDeletePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deletePrompt(requestParameters.promptId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Prompt Category
         * @param {PromptsApiDeletePromptCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePromptCategory(requestParameters: PromptsApiDeletePromptCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deletePromptCategory(requestParameters.catId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Prompt Categories
         * @param {PromptsApiSearchPromptCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPromptCategories(requestParameters: PromptsApiSearchPromptCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<PromptCategoryResponse>> {
            return localVarFp.searchPromptCategories(requestParameters.workspaceId, requestParameters.promptCategorySearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Prompts
         * @param {PromptsApiSearchPromptsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPrompts(requestParameters: PromptsApiSearchPromptsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<PromptResponse>> {
            return localVarFp.searchPrompts(requestParameters.workspaceId, requestParameters.promptSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Prompt
         * @param {PromptsApiUpdatePromptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrompt(requestParameters: PromptsApiUpdatePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse> {
            return localVarFp.updatePrompt(requestParameters.promptId, requestParameters.workspaceId, requestParameters.promptUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Prompt Category
         * @param {PromptsApiUpdatePromptCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePromptCategory(requestParameters: PromptsApiUpdatePromptCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptCategoryResponse> {
            return localVarFp.updatePromptCategory(requestParameters.catId, requestParameters.workspaceId, requestParameters.promptCategoryUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptsApi - interface
 * @export
 * @interface PromptsApi
 */
export interface PromptsApiInterface {
    /**
     * 
     * @summary Create Prompt
     * @param {PromptsApiCreatePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    createPrompt(requestParameters: PromptsApiCreatePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse>;

    /**
     * 
     * @summary Create Prompt Category
     * @param {PromptsApiCreatePromptCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    createPromptCategory(requestParameters: PromptsApiCreatePromptCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptCategoryResponse>;

    /**
     * 
     * @summary Delete Prompt
     * @param {PromptsApiDeletePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    deletePrompt(requestParameters: PromptsApiDeletePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Delete Prompt Category
     * @param {PromptsApiDeletePromptCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    deletePromptCategory(requestParameters: PromptsApiDeletePromptCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Search Prompt Categories
     * @param {PromptsApiSearchPromptCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    searchPromptCategories(requestParameters: PromptsApiSearchPromptCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<PromptCategoryResponse>>;

    /**
     * 
     * @summary Search Prompts
     * @param {PromptsApiSearchPromptsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    searchPrompts(requestParameters: PromptsApiSearchPromptsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<PromptResponse>>;

    /**
     * 
     * @summary Update Prompt
     * @param {PromptsApiUpdatePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    updatePrompt(requestParameters: PromptsApiUpdatePromptRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse>;

    /**
     * 
     * @summary Update Prompt Category
     * @param {PromptsApiUpdatePromptCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    updatePromptCategory(requestParameters: PromptsApiUpdatePromptCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptCategoryResponse>;

}

/**
 * Request parameters for createPrompt operation in PromptsApi.
 * @export
 * @interface PromptsApiCreatePromptRequest
 */
export interface PromptsApiCreatePromptRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiCreatePrompt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PromptCreateRequest}
     * @memberof PromptsApiCreatePrompt
     */
    readonly promptCreateRequest: PromptCreateRequest
}

/**
 * Request parameters for createPromptCategory operation in PromptsApi.
 * @export
 * @interface PromptsApiCreatePromptCategoryRequest
 */
export interface PromptsApiCreatePromptCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiCreatePromptCategory
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PromptCategoryCreateRequest}
     * @memberof PromptsApiCreatePromptCategory
     */
    readonly promptCategoryCreateRequest: PromptCategoryCreateRequest
}

/**
 * Request parameters for deletePrompt operation in PromptsApi.
 * @export
 * @interface PromptsApiDeletePromptRequest
 */
export interface PromptsApiDeletePromptRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiDeletePrompt
     */
    readonly promptId: string

    /**
     * 
     * @type {string}
     * @memberof PromptsApiDeletePrompt
     */
    readonly workspaceId: string
}

/**
 * Request parameters for deletePromptCategory operation in PromptsApi.
 * @export
 * @interface PromptsApiDeletePromptCategoryRequest
 */
export interface PromptsApiDeletePromptCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiDeletePromptCategory
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof PromptsApiDeletePromptCategory
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchPromptCategories operation in PromptsApi.
 * @export
 * @interface PromptsApiSearchPromptCategoriesRequest
 */
export interface PromptsApiSearchPromptCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiSearchPromptCategories
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PromptCategorySearchRequest}
     * @memberof PromptsApiSearchPromptCategories
     */
    readonly promptCategorySearchRequest: PromptCategorySearchRequest
}

/**
 * Request parameters for searchPrompts operation in PromptsApi.
 * @export
 * @interface PromptsApiSearchPromptsRequest
 */
export interface PromptsApiSearchPromptsRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiSearchPrompts
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PromptSearchRequest}
     * @memberof PromptsApiSearchPrompts
     */
    readonly promptSearchRequest: PromptSearchRequest
}

/**
 * Request parameters for updatePrompt operation in PromptsApi.
 * @export
 * @interface PromptsApiUpdatePromptRequest
 */
export interface PromptsApiUpdatePromptRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiUpdatePrompt
     */
    readonly promptId: string

    /**
     * 
     * @type {string}
     * @memberof PromptsApiUpdatePrompt
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PromptUpdateRequest}
     * @memberof PromptsApiUpdatePrompt
     */
    readonly promptUpdateRequest: PromptUpdateRequest
}

/**
 * Request parameters for updatePromptCategory operation in PromptsApi.
 * @export
 * @interface PromptsApiUpdatePromptCategoryRequest
 */
export interface PromptsApiUpdatePromptCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiUpdatePromptCategory
     */
    readonly catId: string

    /**
     * 
     * @type {string}
     * @memberof PromptsApiUpdatePromptCategory
     */
    readonly workspaceId: string

    /**
     * 
     * @type {PromptCategoryUpdateRequest}
     * @memberof PromptsApiUpdatePromptCategory
     */
    readonly promptCategoryUpdateRequest: PromptCategoryUpdateRequest
}

/**
 * PromptsApi - object-oriented interface
 * @export
 * @class PromptsApi
 * @extends {BaseAPI}
 */
export class PromptsApi extends BaseAPI implements PromptsApiInterface {
    /**
     * 
     * @summary Create Prompt
     * @param {PromptsApiCreatePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public createPrompt(requestParameters: PromptsApiCreatePromptRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).createPrompt(requestParameters.workspaceId, requestParameters.promptCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Prompt Category
     * @param {PromptsApiCreatePromptCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public createPromptCategory(requestParameters: PromptsApiCreatePromptCategoryRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).createPromptCategory(requestParameters.workspaceId, requestParameters.promptCategoryCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Prompt
     * @param {PromptsApiDeletePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public deletePrompt(requestParameters: PromptsApiDeletePromptRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).deletePrompt(requestParameters.promptId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Prompt Category
     * @param {PromptsApiDeletePromptCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public deletePromptCategory(requestParameters: PromptsApiDeletePromptCategoryRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).deletePromptCategory(requestParameters.catId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Prompt Categories
     * @param {PromptsApiSearchPromptCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public searchPromptCategories(requestParameters: PromptsApiSearchPromptCategoriesRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).searchPromptCategories(requestParameters.workspaceId, requestParameters.promptCategorySearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Prompts
     * @param {PromptsApiSearchPromptsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public searchPrompts(requestParameters: PromptsApiSearchPromptsRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).searchPrompts(requestParameters.workspaceId, requestParameters.promptSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Prompt
     * @param {PromptsApiUpdatePromptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public updatePrompt(requestParameters: PromptsApiUpdatePromptRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).updatePrompt(requestParameters.promptId, requestParameters.workspaceId, requestParameters.promptUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Prompt Category
     * @param {PromptsApiUpdatePromptCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public updatePromptCategory(requestParameters: PromptsApiUpdatePromptCategoryRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).updatePromptCategory(requestParameters.catId, requestParameters.workspaceId, requestParameters.promptCategoryUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReindexApi - axios parameter creator
 * @export
 */
export const ReindexApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the status of a reindex operation.  The task_id format is: {workspace_id}_{embedding_model} or installation_{embedding_model}
         * @summary Get Reindex Status
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReindexStatus: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getReindexStatus', 'taskId', taskId)
            const localVarPath = `/v2/reindex/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sudo_api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo-Api-Key", configuration)

            if (taskId !== undefined) {
                localVarQueryParameter['task_id'] = taskId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a reindex operation for all data or a specific workspace.  This endpoint requires sudo API key authentication.  The reindex operation will: 1. Create a new versioned Qdrant collection 2. Reindex all documents, FAQs, and schedules 3. Support resume capability via Redis cursor 4. Be idempotent - can be called multiple times safely
         * @summary Trigger Reindex
         * @param {ReindexRequest} reindexRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerReindex: async (reindexRequest: ReindexRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reindexRequest' is not null or undefined
            assertParamExists('triggerReindex', 'reindexRequest', reindexRequest)
            const localVarPath = `/v2/reindex/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sudo_api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo-Api-Key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reindexRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReindexApi - functional programming interface
 * @export
 */
export const ReindexApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReindexApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the status of a reindex operation.  The task_id format is: {workspace_id}_{embedding_model} or installation_{embedding_model}
         * @summary Get Reindex Status
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReindexStatus(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReindexStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReindexStatus(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReindexApi.getReindexStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger a reindex operation for all data or a specific workspace.  This endpoint requires sudo API key authentication.  The reindex operation will: 1. Create a new versioned Qdrant collection 2. Reindex all documents, FAQs, and schedules 3. Support resume capability via Redis cursor 4. Be idempotent - can be called multiple times safely
         * @summary Trigger Reindex
         * @param {ReindexRequest} reindexRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerReindex(reindexRequest: ReindexRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReindexStartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerReindex(reindexRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReindexApi.triggerReindex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReindexApi - factory interface
 * @export
 */
export const ReindexApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReindexApiFp(configuration)
    return {
        /**
         * Get the status of a reindex operation.  The task_id format is: {workspace_id}_{embedding_model} or installation_{embedding_model}
         * @summary Get Reindex Status
         * @param {ReindexApiGetReindexStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReindexStatus(requestParameters: ReindexApiGetReindexStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReindexStatusResponse> {
            return localVarFp.getReindexStatus(requestParameters.taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger a reindex operation for all data or a specific workspace.  This endpoint requires sudo API key authentication.  The reindex operation will: 1. Create a new versioned Qdrant collection 2. Reindex all documents, FAQs, and schedules 3. Support resume capability via Redis cursor 4. Be idempotent - can be called multiple times safely
         * @summary Trigger Reindex
         * @param {ReindexApiTriggerReindexRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerReindex(requestParameters: ReindexApiTriggerReindexRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReindexStartResponse> {
            return localVarFp.triggerReindex(requestParameters.reindexRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReindexApi - interface
 * @export
 * @interface ReindexApi
 */
export interface ReindexApiInterface {
    /**
     * Get the status of a reindex operation.  The task_id format is: {workspace_id}_{embedding_model} or installation_{embedding_model}
     * @summary Get Reindex Status
     * @param {ReindexApiGetReindexStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReindexApiInterface
     */
    getReindexStatus(requestParameters: ReindexApiGetReindexStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReindexStatusResponse>;

    /**
     * Trigger a reindex operation for all data or a specific workspace.  This endpoint requires sudo API key authentication.  The reindex operation will: 1. Create a new versioned Qdrant collection 2. Reindex all documents, FAQs, and schedules 3. Support resume capability via Redis cursor 4. Be idempotent - can be called multiple times safely
     * @summary Trigger Reindex
     * @param {ReindexApiTriggerReindexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReindexApiInterface
     */
    triggerReindex(requestParameters: ReindexApiTriggerReindexRequest, options?: RawAxiosRequestConfig): AxiosPromise<ReindexStartResponse>;

}

/**
 * Request parameters for getReindexStatus operation in ReindexApi.
 * @export
 * @interface ReindexApiGetReindexStatusRequest
 */
export interface ReindexApiGetReindexStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof ReindexApiGetReindexStatus
     */
    readonly taskId: string
}

/**
 * Request parameters for triggerReindex operation in ReindexApi.
 * @export
 * @interface ReindexApiTriggerReindexRequest
 */
export interface ReindexApiTriggerReindexRequest {
    /**
     * 
     * @type {ReindexRequest}
     * @memberof ReindexApiTriggerReindex
     */
    readonly reindexRequest: ReindexRequest
}

/**
 * ReindexApi - object-oriented interface
 * @export
 * @class ReindexApi
 * @extends {BaseAPI}
 */
export class ReindexApi extends BaseAPI implements ReindexApiInterface {
    /**
     * Get the status of a reindex operation.  The task_id format is: {workspace_id}_{embedding_model} or installation_{embedding_model}
     * @summary Get Reindex Status
     * @param {ReindexApiGetReindexStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReindexApi
     */
    public getReindexStatus(requestParameters: ReindexApiGetReindexStatusRequest, options?: RawAxiosRequestConfig) {
        return ReindexApiFp(this.configuration).getReindexStatus(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger a reindex operation for all data or a specific workspace.  This endpoint requires sudo API key authentication.  The reindex operation will: 1. Create a new versioned Qdrant collection 2. Reindex all documents, FAQs, and schedules 3. Support resume capability via Redis cursor 4. Be idempotent - can be called multiple times safely
     * @summary Trigger Reindex
     * @param {ReindexApiTriggerReindexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReindexApi
     */
    public triggerReindex(requestParameters: ReindexApiTriggerReindexRequest, options?: RawAxiosRequestConfig) {
        return ReindexApiFp(this.configuration).triggerReindex(requestParameters.reindexRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SERPApi - axios parameter creator
 * @export
 */
export const SERPApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Search Cluster Query
         * @param {string} workspaceId 
         * @param {SerpClusterGroupSearchRequest} serpClusterGroupSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchClusterQuery: async (workspaceId: string, serpClusterGroupSearchRequest: SerpClusterGroupSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchClusterQuery', 'workspaceId', workspaceId)
            // verify required parameter 'serpClusterGroupSearchRequest' is not null or undefined
            assertParamExists('searchClusterQuery', 'serpClusterGroupSearchRequest', serpClusterGroupSearchRequest)
            const localVarPath = `/v2/serp/clusters/keywords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpClusterGroupSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Add Queries
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {SerpClusterAddQueryRequests} serpClusterAddQueryRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterAddQueries: async (customerId: string, campaignId: string, groupId: string, workspaceId: string, serpClusterAddQueryRequests: SerpClusterAddQueryRequests, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('serpClusterAddQueries', 'customerId', customerId)
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('serpClusterAddQueries', 'campaignId', campaignId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('serpClusterAddQueries', 'groupId', groupId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterAddQueries', 'workspaceId', workspaceId)
            // verify required parameter 'serpClusterAddQueryRequests' is not null or undefined
            assertParamExists('serpClusterAddQueries', 'serpClusterAddQueryRequests', serpClusterAddQueryRequests)
            const localVarPath = `/v2/serp/clusters/{customer_id}/{campaign_id}/{group_id}/add_keywords`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpClusterAddQueryRequests, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Delete Campaign
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteCampaign: async (customerId: string, campaignId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('serpClusterDeleteCampaign', 'customerId', customerId)
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('serpClusterDeleteCampaign', 'campaignId', campaignId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterDeleteCampaign', 'workspaceId', workspaceId)
            const localVarPath = `/v2/serp/clusters/{customer_id}/{campaign_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Delete Customer
         * @param {string} customerId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteCustomer: async (customerId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('serpClusterDeleteCustomer', 'customerId', customerId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterDeleteCustomer', 'workspaceId', workspaceId)
            const localVarPath = `/v2/serp/clusters/{customer_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Delete Group
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteGroup: async (customerId: string, campaignId: string, groupId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('serpClusterDeleteGroup', 'customerId', customerId)
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('serpClusterDeleteGroup', 'campaignId', campaignId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('serpClusterDeleteGroup', 'groupId', groupId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterDeleteGroup', 'workspaceId', workspaceId)
            const localVarPath = `/v2/serp/clusters/{customer_id}/{campaign_id}/{group_id}`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Delete Group Queries
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {SerpQueryRequest} serpQueryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteGroupQueries: async (customerId: string, campaignId: string, groupId: string, workspaceId: string, serpQueryRequest: SerpQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('serpClusterDeleteGroupQueries', 'customerId', customerId)
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('serpClusterDeleteGroupQueries', 'campaignId', campaignId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('serpClusterDeleteGroupQueries', 'groupId', groupId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterDeleteGroupQueries', 'workspaceId', workspaceId)
            // verify required parameter 'serpQueryRequest' is not null or undefined
            assertParamExists('serpClusterDeleteGroupQueries', 'serpQueryRequest', serpQueryRequest)
            const localVarPath = `/v2/serp/clusters/{customer_id}/{campaign_id}/{group_id}/delete_queries`
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)))
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Get Graph Nodes
         * @param {string} workspaceId 
         * @param {SerpClusterGroupIntersectionsRequest} serpClusterGroupIntersectionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterGetGraphNodes: async (workspaceId: string, serpClusterGroupIntersectionsRequest: SerpClusterGroupIntersectionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterGetGraphNodes', 'workspaceId', workspaceId)
            // verify required parameter 'serpClusterGroupIntersectionsRequest' is not null or undefined
            assertParamExists('serpClusterGetGraphNodes', 'serpClusterGroupIntersectionsRequest', serpClusterGroupIntersectionsRequest)
            const localVarPath = `/v2/serp/clusters/graph_nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpClusterGroupIntersectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Get Matching Groups To Query
         * @param {string} workspaceId 
         * @param {SerpClusterBestGroupsRequest} serpClusterBestGroupsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterGetMatchingGroupsToQuery: async (workspaceId: string, serpClusterBestGroupsRequest: SerpClusterBestGroupsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterGetMatchingGroupsToQuery', 'workspaceId', workspaceId)
            // verify required parameter 'serpClusterBestGroupsRequest' is not null or undefined
            assertParamExists('serpClusterGetMatchingGroupsToQuery', 'serpClusterBestGroupsRequest', serpClusterBestGroupsRequest)
            const localVarPath = `/v2/serp/clusters/recommended_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpClusterBestGroupsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Get Related Keywords To Query
         * @param {string} workspaceId 
         * @param {SerpClusterKeywordIntersectionsRequest} serpClusterKeywordIntersectionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterGetRelatedKeywordsToQuery: async (workspaceId: string, serpClusterKeywordIntersectionsRequest: SerpClusterKeywordIntersectionsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterGetRelatedKeywordsToQuery', 'workspaceId', workspaceId)
            // verify required parameter 'serpClusterKeywordIntersectionsRequest' is not null or undefined
            assertParamExists('serpClusterGetRelatedKeywordsToQuery', 'serpClusterKeywordIntersectionsRequest', serpClusterKeywordIntersectionsRequest)
            const localVarPath = `/v2/serp/clusters/related_keywords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpClusterKeywordIntersectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Cluster Split To Sub Clusters
         * @param {string} workspaceId 
         * @param {SerpClusterGroupSubClustersRequest} serpClusterGroupSubClustersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterSplitToSubClusters: async (workspaceId: string, serpClusterGroupSubClustersRequest: SerpClusterGroupSubClustersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpClusterSplitToSubClusters', 'workspaceId', workspaceId)
            // verify required parameter 'serpClusterGroupSubClustersRequest' is not null or undefined
            assertParamExists('serpClusterSplitToSubClusters', 'serpClusterGroupSubClustersRequest', serpClusterGroupSubClustersRequest)
            const localVarPath = `/v2/serp/clusters/split_sub_clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpClusterGroupSubClustersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Search
         * @param {string} workspaceId 
         * @param {SerpSearchRequests} serpSearchRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpSearch: async (workspaceId: string, serpSearchRequests: SerpSearchRequests, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpSearch', 'workspaceId', workspaceId)
            // verify required parameter 'serpSearchRequests' is not null or undefined
            assertParamExists('serpSearch', 'serpSearchRequests', serpSearchRequests)
            const localVarPath = `/v2/serp/serp/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpSearchRequests, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Volumes
         * @param {string} workspaceId 
         * @param {SerpVolumeRequest} serpVolumeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpVolumes: async (workspaceId: string, serpVolumeRequest: SerpVolumeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('serpVolumes', 'workspaceId', workspaceId)
            // verify required parameter 'serpVolumeRequest' is not null or undefined
            assertParamExists('serpVolumes', 'serpVolumeRequest', serpVolumeRequest)
            const localVarPath = `/v2/serp/serp/volumes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serpVolumeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serp Volumes Pingback
         * @param {string} id 
         * @param {string | null} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpVolumesPingback: async (id: string, tag: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serpVolumesPingback', 'id', id)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('serpVolumesPingback', 'tag', tag)
            const localVarPath = `/v2/serp/serp/volumes/pingback/{id}/{tag}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SERPApi - functional programming interface
 * @export
 */
export const SERPApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SERPApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Search Cluster Query
         * @param {string} workspaceId 
         * @param {SerpClusterGroupSearchRequest} serpClusterGroupSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchClusterQuery(workspaceId: string, serpClusterGroupSearchRequest: SerpClusterGroupSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SerpClusterKeywordResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchClusterQuery(workspaceId, serpClusterGroupSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.searchClusterQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Add Queries
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {SerpClusterAddQueryRequests} serpClusterAddQueryRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterAddQueries(customerId: string, campaignId: string, groupId: string, workspaceId: string, serpClusterAddQueryRequests: SerpClusterAddQueryRequests, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterAddQueries(customerId, campaignId, groupId, workspaceId, serpClusterAddQueryRequests, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterAddQueries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Delete Campaign
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterDeleteCampaign(customerId: string, campaignId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterDeleteCampaign(customerId, campaignId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterDeleteCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Delete Customer
         * @param {string} customerId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterDeleteCustomer(customerId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterDeleteCustomer(customerId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterDeleteCustomer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Delete Group
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterDeleteGroup(customerId: string, campaignId: string, groupId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterDeleteGroup(customerId, campaignId, groupId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterDeleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Delete Group Queries
         * @param {string} customerId 
         * @param {string} campaignId 
         * @param {string} groupId 
         * @param {string} workspaceId 
         * @param {SerpQueryRequest} serpQueryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterDeleteGroupQueries(customerId: string, campaignId: string, groupId: string, workspaceId: string, serpQueryRequest: SerpQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterDeleteGroupQueries(customerId, campaignId, groupId, workspaceId, serpQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterDeleteGroupQueries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Get Graph Nodes
         * @param {string} workspaceId 
         * @param {SerpClusterGroupIntersectionsRequest} serpClusterGroupIntersectionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterGetGraphNodes(workspaceId: string, serpClusterGroupIntersectionsRequest: SerpClusterGroupIntersectionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SerpKeywordRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterGetGraphNodes(workspaceId, serpClusterGroupIntersectionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterGetGraphNodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Get Matching Groups To Query
         * @param {string} workspaceId 
         * @param {SerpClusterBestGroupsRequest} serpClusterBestGroupsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterGetMatchingGroupsToQuery(workspaceId: string, serpClusterBestGroupsRequest: SerpClusterBestGroupsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SerpGroupIntersection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterGetMatchingGroupsToQuery(workspaceId, serpClusterBestGroupsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterGetMatchingGroupsToQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Get Related Keywords To Query
         * @param {string} workspaceId 
         * @param {SerpClusterKeywordIntersectionsRequest} serpClusterKeywordIntersectionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterGetRelatedKeywordsToQuery(workspaceId: string, serpClusterKeywordIntersectionsRequest: SerpClusterKeywordIntersectionsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SerpKeywordRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterGetRelatedKeywordsToQuery(workspaceId, serpClusterKeywordIntersectionsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterGetRelatedKeywordsToQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Cluster Split To Sub Clusters
         * @param {string} workspaceId 
         * @param {SerpClusterGroupSubClustersRequest} serpClusterGroupSubClustersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpClusterSplitToSubClusters(workspaceId: string, serpClusterGroupSubClustersRequest: SerpClusterGroupSubClustersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SerpSubclusterKeywordsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpClusterSplitToSubClusters(workspaceId, serpClusterGroupSubClustersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpClusterSplitToSubClusters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Search
         * @param {string} workspaceId 
         * @param {SerpSearchRequests} serpSearchRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpSearch(workspaceId: string, serpSearchRequests: SerpSearchRequests, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpSearch(workspaceId, serpSearchRequests, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Volumes
         * @param {string} workspaceId 
         * @param {SerpVolumeRequest} serpVolumeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpVolumes(workspaceId: string, serpVolumeRequest: SerpVolumeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpVolumes(workspaceId, serpVolumeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpVolumes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serp Volumes Pingback
         * @param {string} id 
         * @param {string | null} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serpVolumesPingback(id: string, tag: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serpVolumesPingback(id, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SERPApi.serpVolumesPingback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SERPApi - factory interface
 * @export
 */
export const SERPApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SERPApiFp(configuration)
    return {
        /**
         * 
         * @summary Search Cluster Query
         * @param {SERPApiSearchClusterQueryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchClusterQuery(requestParameters: SERPApiSearchClusterQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpClusterKeywordResponse>> {
            return localVarFp.searchClusterQuery(requestParameters.workspaceId, requestParameters.serpClusterGroupSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Add Queries
         * @param {SERPApiSerpClusterAddQueriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterAddQueries(requestParameters: SERPApiSerpClusterAddQueriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.serpClusterAddQueries(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, requestParameters.serpClusterAddQueryRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Delete Campaign
         * @param {SERPApiSerpClusterDeleteCampaignRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteCampaign(requestParameters: SERPApiSerpClusterDeleteCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.serpClusterDeleteCampaign(requestParameters.customerId, requestParameters.campaignId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Delete Customer
         * @param {SERPApiSerpClusterDeleteCustomerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteCustomer(requestParameters: SERPApiSerpClusterDeleteCustomerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.serpClusterDeleteCustomer(requestParameters.customerId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Delete Group
         * @param {SERPApiSerpClusterDeleteGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteGroup(requestParameters: SERPApiSerpClusterDeleteGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.serpClusterDeleteGroup(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Delete Group Queries
         * @param {SERPApiSerpClusterDeleteGroupQueriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterDeleteGroupQueries(requestParameters: SERPApiSerpClusterDeleteGroupQueriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.serpClusterDeleteGroupQueries(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, requestParameters.serpQueryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Get Graph Nodes
         * @param {SERPApiSerpClusterGetGraphNodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterGetGraphNodes(requestParameters: SERPApiSerpClusterGetGraphNodesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpKeywordRelation>> {
            return localVarFp.serpClusterGetGraphNodes(requestParameters.workspaceId, requestParameters.serpClusterGroupIntersectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Get Matching Groups To Query
         * @param {SERPApiSerpClusterGetMatchingGroupsToQueryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterGetMatchingGroupsToQuery(requestParameters: SERPApiSerpClusterGetMatchingGroupsToQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpGroupIntersection>> {
            return localVarFp.serpClusterGetMatchingGroupsToQuery(requestParameters.workspaceId, requestParameters.serpClusterBestGroupsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Get Related Keywords To Query
         * @param {SERPApiSerpClusterGetRelatedKeywordsToQueryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterGetRelatedKeywordsToQuery(requestParameters: SERPApiSerpClusterGetRelatedKeywordsToQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpKeywordRelation>> {
            return localVarFp.serpClusterGetRelatedKeywordsToQuery(requestParameters.workspaceId, requestParameters.serpClusterKeywordIntersectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Cluster Split To Sub Clusters
         * @param {SERPApiSerpClusterSplitToSubClustersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpClusterSplitToSubClusters(requestParameters: SERPApiSerpClusterSplitToSubClustersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpSubclusterKeywordsResponse>> {
            return localVarFp.serpClusterSplitToSubClusters(requestParameters.workspaceId, requestParameters.serpClusterGroupSubClustersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Search
         * @param {SERPApiSerpSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpSearch(requestParameters: SERPApiSerpSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskResponse>> {
            return localVarFp.serpSearch(requestParameters.workspaceId, requestParameters.serpSearchRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Volumes
         * @param {SERPApiSerpVolumesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpVolumes(requestParameters: SERPApiSerpVolumesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.serpVolumes(requestParameters.workspaceId, requestParameters.serpVolumeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serp Volumes Pingback
         * @param {SERPApiSerpVolumesPingbackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serpVolumesPingback(requestParameters: SERPApiSerpVolumesPingbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse> {
            return localVarFp.serpVolumesPingback(requestParameters.id, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SERPApi - interface
 * @export
 * @interface SERPApi
 */
export interface SERPApiInterface {
    /**
     * 
     * @summary Search Cluster Query
     * @param {SERPApiSearchClusterQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    searchClusterQuery(requestParameters: SERPApiSearchClusterQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpClusterKeywordResponse>>;

    /**
     * 
     * @summary Serp Cluster Add Queries
     * @param {SERPApiSerpClusterAddQueriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterAddQueries(requestParameters: SERPApiSerpClusterAddQueriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Serp Cluster Delete Campaign
     * @param {SERPApiSerpClusterDeleteCampaignRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterDeleteCampaign(requestParameters: SERPApiSerpClusterDeleteCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Serp Cluster Delete Customer
     * @param {SERPApiSerpClusterDeleteCustomerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterDeleteCustomer(requestParameters: SERPApiSerpClusterDeleteCustomerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Serp Cluster Delete Group
     * @param {SERPApiSerpClusterDeleteGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterDeleteGroup(requestParameters: SERPApiSerpClusterDeleteGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Serp Cluster Delete Group Queries
     * @param {SERPApiSerpClusterDeleteGroupQueriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterDeleteGroupQueries(requestParameters: SERPApiSerpClusterDeleteGroupQueriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Serp Cluster Get Graph Nodes
     * @param {SERPApiSerpClusterGetGraphNodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterGetGraphNodes(requestParameters: SERPApiSerpClusterGetGraphNodesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpKeywordRelation>>;

    /**
     * 
     * @summary Serp Cluster Get Matching Groups To Query
     * @param {SERPApiSerpClusterGetMatchingGroupsToQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterGetMatchingGroupsToQuery(requestParameters: SERPApiSerpClusterGetMatchingGroupsToQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpGroupIntersection>>;

    /**
     * 
     * @summary Serp Cluster Get Related Keywords To Query
     * @param {SERPApiSerpClusterGetRelatedKeywordsToQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterGetRelatedKeywordsToQuery(requestParameters: SERPApiSerpClusterGetRelatedKeywordsToQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpKeywordRelation>>;

    /**
     * 
     * @summary Serp Cluster Split To Sub Clusters
     * @param {SERPApiSerpClusterSplitToSubClustersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpClusterSplitToSubClusters(requestParameters: SERPApiSerpClusterSplitToSubClustersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SerpSubclusterKeywordsResponse>>;

    /**
     * 
     * @summary Serp Search
     * @param {SERPApiSerpSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpSearch(requestParameters: SERPApiSerpSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskResponse>>;

    /**
     * 
     * @summary Serp Volumes
     * @param {SERPApiSerpVolumesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpVolumes(requestParameters: SERPApiSerpVolumesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

    /**
     * 
     * @summary Serp Volumes Pingback
     * @param {SERPApiSerpVolumesPingbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApiInterface
     */
    serpVolumesPingback(requestParameters: SERPApiSerpVolumesPingbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskResponse>;

}

/**
 * Request parameters for searchClusterQuery operation in SERPApi.
 * @export
 * @interface SERPApiSearchClusterQueryRequest
 */
export interface SERPApiSearchClusterQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSearchClusterQuery
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpClusterGroupSearchRequest}
     * @memberof SERPApiSearchClusterQuery
     */
    readonly serpClusterGroupSearchRequest: SerpClusterGroupSearchRequest
}

/**
 * Request parameters for serpClusterAddQueries operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterAddQueriesRequest
 */
export interface SERPApiSerpClusterAddQueriesRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterAddQueries
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterAddQueries
     */
    readonly campaignId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterAddQueries
     */
    readonly groupId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterAddQueries
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpClusterAddQueryRequests}
     * @memberof SERPApiSerpClusterAddQueries
     */
    readonly serpClusterAddQueryRequests: SerpClusterAddQueryRequests
}

/**
 * Request parameters for serpClusterDeleteCampaign operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterDeleteCampaignRequest
 */
export interface SERPApiSerpClusterDeleteCampaignRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteCampaign
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteCampaign
     */
    readonly campaignId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteCampaign
     */
    readonly workspaceId: string
}

/**
 * Request parameters for serpClusterDeleteCustomer operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterDeleteCustomerRequest
 */
export interface SERPApiSerpClusterDeleteCustomerRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteCustomer
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteCustomer
     */
    readonly workspaceId: string
}

/**
 * Request parameters for serpClusterDeleteGroup operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterDeleteGroupRequest
 */
export interface SERPApiSerpClusterDeleteGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroup
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroup
     */
    readonly campaignId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroup
     */
    readonly groupId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroup
     */
    readonly workspaceId: string
}

/**
 * Request parameters for serpClusterDeleteGroupQueries operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterDeleteGroupQueriesRequest
 */
export interface SERPApiSerpClusterDeleteGroupQueriesRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroupQueries
     */
    readonly customerId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroupQueries
     */
    readonly campaignId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroupQueries
     */
    readonly groupId: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterDeleteGroupQueries
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpQueryRequest}
     * @memberof SERPApiSerpClusterDeleteGroupQueries
     */
    readonly serpQueryRequest: SerpQueryRequest
}

/**
 * Request parameters for serpClusterGetGraphNodes operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterGetGraphNodesRequest
 */
export interface SERPApiSerpClusterGetGraphNodesRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterGetGraphNodes
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpClusterGroupIntersectionsRequest}
     * @memberof SERPApiSerpClusterGetGraphNodes
     */
    readonly serpClusterGroupIntersectionsRequest: SerpClusterGroupIntersectionsRequest
}

/**
 * Request parameters for serpClusterGetMatchingGroupsToQuery operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterGetMatchingGroupsToQueryRequest
 */
export interface SERPApiSerpClusterGetMatchingGroupsToQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterGetMatchingGroupsToQuery
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpClusterBestGroupsRequest}
     * @memberof SERPApiSerpClusterGetMatchingGroupsToQuery
     */
    readonly serpClusterBestGroupsRequest: SerpClusterBestGroupsRequest
}

/**
 * Request parameters for serpClusterGetRelatedKeywordsToQuery operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterGetRelatedKeywordsToQueryRequest
 */
export interface SERPApiSerpClusterGetRelatedKeywordsToQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterGetRelatedKeywordsToQuery
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpClusterKeywordIntersectionsRequest}
     * @memberof SERPApiSerpClusterGetRelatedKeywordsToQuery
     */
    readonly serpClusterKeywordIntersectionsRequest: SerpClusterKeywordIntersectionsRequest
}

/**
 * Request parameters for serpClusterSplitToSubClusters operation in SERPApi.
 * @export
 * @interface SERPApiSerpClusterSplitToSubClustersRequest
 */
export interface SERPApiSerpClusterSplitToSubClustersRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpClusterSplitToSubClusters
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpClusterGroupSubClustersRequest}
     * @memberof SERPApiSerpClusterSplitToSubClusters
     */
    readonly serpClusterGroupSubClustersRequest: SerpClusterGroupSubClustersRequest
}

/**
 * Request parameters for serpSearch operation in SERPApi.
 * @export
 * @interface SERPApiSerpSearchRequest
 */
export interface SERPApiSerpSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpSearch
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpSearchRequests}
     * @memberof SERPApiSerpSearch
     */
    readonly serpSearchRequests: SerpSearchRequests
}

/**
 * Request parameters for serpVolumes operation in SERPApi.
 * @export
 * @interface SERPApiSerpVolumesRequest
 */
export interface SERPApiSerpVolumesRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpVolumes
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SerpVolumeRequest}
     * @memberof SERPApiSerpVolumes
     */
    readonly serpVolumeRequest: SerpVolumeRequest
}

/**
 * Request parameters for serpVolumesPingback operation in SERPApi.
 * @export
 * @interface SERPApiSerpVolumesPingbackRequest
 */
export interface SERPApiSerpVolumesPingbackRequest {
    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpVolumesPingback
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof SERPApiSerpVolumesPingback
     */
    readonly tag: string | null
}

/**
 * SERPApi - object-oriented interface
 * @export
 * @class SERPApi
 * @extends {BaseAPI}
 */
export class SERPApi extends BaseAPI implements SERPApiInterface {
    /**
     * 
     * @summary Search Cluster Query
     * @param {SERPApiSearchClusterQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public searchClusterQuery(requestParameters: SERPApiSearchClusterQueryRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).searchClusterQuery(requestParameters.workspaceId, requestParameters.serpClusterGroupSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Add Queries
     * @param {SERPApiSerpClusterAddQueriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterAddQueries(requestParameters: SERPApiSerpClusterAddQueriesRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterAddQueries(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, requestParameters.serpClusterAddQueryRequests, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Delete Campaign
     * @param {SERPApiSerpClusterDeleteCampaignRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterDeleteCampaign(requestParameters: SERPApiSerpClusterDeleteCampaignRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterDeleteCampaign(requestParameters.customerId, requestParameters.campaignId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Delete Customer
     * @param {SERPApiSerpClusterDeleteCustomerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterDeleteCustomer(requestParameters: SERPApiSerpClusterDeleteCustomerRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterDeleteCustomer(requestParameters.customerId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Delete Group
     * @param {SERPApiSerpClusterDeleteGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterDeleteGroup(requestParameters: SERPApiSerpClusterDeleteGroupRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterDeleteGroup(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Delete Group Queries
     * @param {SERPApiSerpClusterDeleteGroupQueriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterDeleteGroupQueries(requestParameters: SERPApiSerpClusterDeleteGroupQueriesRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterDeleteGroupQueries(requestParameters.customerId, requestParameters.campaignId, requestParameters.groupId, requestParameters.workspaceId, requestParameters.serpQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Get Graph Nodes
     * @param {SERPApiSerpClusterGetGraphNodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterGetGraphNodes(requestParameters: SERPApiSerpClusterGetGraphNodesRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterGetGraphNodes(requestParameters.workspaceId, requestParameters.serpClusterGroupIntersectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Get Matching Groups To Query
     * @param {SERPApiSerpClusterGetMatchingGroupsToQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterGetMatchingGroupsToQuery(requestParameters: SERPApiSerpClusterGetMatchingGroupsToQueryRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterGetMatchingGroupsToQuery(requestParameters.workspaceId, requestParameters.serpClusterBestGroupsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Get Related Keywords To Query
     * @param {SERPApiSerpClusterGetRelatedKeywordsToQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterGetRelatedKeywordsToQuery(requestParameters: SERPApiSerpClusterGetRelatedKeywordsToQueryRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterGetRelatedKeywordsToQuery(requestParameters.workspaceId, requestParameters.serpClusterKeywordIntersectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Cluster Split To Sub Clusters
     * @param {SERPApiSerpClusterSplitToSubClustersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpClusterSplitToSubClusters(requestParameters: SERPApiSerpClusterSplitToSubClustersRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpClusterSplitToSubClusters(requestParameters.workspaceId, requestParameters.serpClusterGroupSubClustersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Search
     * @param {SERPApiSerpSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpSearch(requestParameters: SERPApiSerpSearchRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpSearch(requestParameters.workspaceId, requestParameters.serpSearchRequests, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Volumes
     * @param {SERPApiSerpVolumesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpVolumes(requestParameters: SERPApiSerpVolumesRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpVolumes(requestParameters.workspaceId, requestParameters.serpVolumeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serp Volumes Pingback
     * @param {SERPApiSerpVolumesPingbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SERPApi
     */
    public serpVolumesPingback(requestParameters: SERPApiSerpVolumesPingbackRequest, options?: RawAxiosRequestConfig) {
        return SERPApiFp(this.configuration).serpVolumesPingback(requestParameters.id, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchedulesApi - axios parameter creator
 * @export
 */
export const SchedulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Schedules
         * @param {string} workspaceId 
         * @param {Array<ScheduleCreateRequest>} scheduleCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedules: async (workspaceId: string, scheduleCreateRequest: Array<ScheduleCreateRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createSchedules', 'workspaceId', workspaceId)
            // verify required parameter 'scheduleCreateRequest' is not null or undefined
            assertParamExists('createSchedules', 'scheduleCreateRequest', scheduleCreateRequest)
            const localVarPath = `/v2/schedules/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedule: async (scheduleId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('deleteSchedule', 'scheduleId', scheduleId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteSchedule', 'workspaceId', workspaceId)
            const localVarPath = `/v2/schedules/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedule: async (scheduleId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('getSchedule', 'scheduleId', scheduleId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSchedule', 'workspaceId', workspaceId)
            const localVarPath = `/v2/schedules/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Schedule Url Details
         * @param {string} scheduleId 
         * @param {string} urlId 
         * @param {string} domainId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleUrlDetails: async (scheduleId: string, urlId: string, domainId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('getScheduleUrlDetails', 'scheduleId', scheduleId)
            // verify required parameter 'urlId' is not null or undefined
            assertParamExists('getScheduleUrlDetails', 'urlId', urlId)
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('getScheduleUrlDetails', 'domainId', domainId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScheduleUrlDetails', 'workspaceId', workspaceId)
            const localVarPath = `/v2/schedules/{schedule_id}/urls/{domain_id}/{url_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)))
                .replace(`{${"url_id"}}`, encodeURIComponent(String(urlId)))
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Schedules
         * @param {string} workspaceId 
         * @param {ScheduleSearchRequest} scheduleSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedules: async (workspaceId: string, scheduleSearchRequest: ScheduleSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSchedules', 'workspaceId', workspaceId)
            // verify required parameter 'scheduleSearchRequest' is not null or undefined
            assertParamExists('getSchedules', 'scheduleSearchRequest', scheduleSearchRequest)
            const localVarPath = `/v2/schedules/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSchedule: async (scheduleId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('runSchedule', 'scheduleId', scheduleId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('runSchedule', 'workspaceId', workspaceId)
            const localVarPath = `/v2/schedules/run/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Schedule Urls
         * @param {string} workspaceId 
         * @param {ScheduleUrlSearchRequest} scheduleUrlSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScheduleUrls: async (workspaceId: string, scheduleUrlSearchRequest: ScheduleUrlSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchScheduleUrls', 'workspaceId', workspaceId)
            // verify required parameter 'scheduleUrlSearchRequest' is not null or undefined
            assertParamExists('searchScheduleUrls', 'scheduleUrlSearchRequest', scheduleUrlSearchRequest)
            const localVarPath = `/v2/schedules/urls/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleUrlSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {ScheduleUpdateRequest} scheduleUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchedule: async (scheduleId: string, workspaceId: string, scheduleUpdateRequest: ScheduleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('updateSchedule', 'scheduleId', scheduleId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateSchedule', 'workspaceId', workspaceId)
            // verify required parameter 'scheduleUpdateRequest' is not null or undefined
            assertParamExists('updateSchedule', 'scheduleUpdateRequest', scheduleUpdateRequest)
            const localVarPath = `/v2/schedules/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchedulesApi - functional programming interface
 * @export
 */
export const SchedulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchedulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Schedules
         * @param {string} workspaceId 
         * @param {Array<ScheduleCreateRequest>} scheduleCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSchedules(workspaceId: string, scheduleCreateRequest: Array<ScheduleCreateRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSchedules(workspaceId, scheduleCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.createSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSchedule(scheduleId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSchedule(scheduleId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.deleteSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchedule(scheduleId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchedule(scheduleId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.getSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Schedule Url Details
         * @param {string} scheduleId 
         * @param {string} urlId 
         * @param {string} domainId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduleUrlDetails(scheduleId: string, urlId: string, domainId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleUrlDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduleUrlDetails(scheduleId, urlId, domainId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.getScheduleUrlDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Schedules
         * @param {string} workspaceId 
         * @param {ScheduleSearchRequest} scheduleSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchedules(workspaceId: string, scheduleSearchRequest: ScheduleSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchedules(workspaceId, scheduleSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.getSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Run Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runSchedule(scheduleId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runSchedule(scheduleId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.runSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Schedule Urls
         * @param {string} workspaceId 
         * @param {ScheduleUrlSearchRequest} scheduleUrlSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchScheduleUrls(workspaceId: string, scheduleUrlSearchRequest: ScheduleUrlSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduleUrlResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchScheduleUrls(workspaceId, scheduleUrlSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.searchScheduleUrls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Schedule
         * @param {string} scheduleId 
         * @param {string} workspaceId 
         * @param {ScheduleUpdateRequest} scheduleUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSchedule(scheduleId: string, workspaceId: string, scheduleUpdateRequest: ScheduleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSchedule(scheduleId, workspaceId, scheduleUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.updateSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchedulesApi - factory interface
 * @export
 */
export const SchedulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchedulesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Schedules
         * @param {SchedulesApiCreateSchedulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedules(requestParameters: SchedulesApiCreateSchedulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScheduleResponse>> {
            return localVarFp.createSchedules(requestParameters.workspaceId, requestParameters.scheduleCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Schedule
         * @param {SchedulesApiDeleteScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedule(requestParameters: SchedulesApiDeleteScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteSchedule(requestParameters.scheduleId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Schedule
         * @param {SchedulesApiGetScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedule(requestParameters: SchedulesApiGetScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleResponse> {
            return localVarFp.getSchedule(requestParameters.scheduleId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Schedule Url Details
         * @param {SchedulesApiGetScheduleUrlDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleUrlDetails(requestParameters: SchedulesApiGetScheduleUrlDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleUrlDetailResponse> {
            return localVarFp.getScheduleUrlDetails(requestParameters.scheduleId, requestParameters.urlId, requestParameters.domainId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Schedules
         * @param {SchedulesApiGetSchedulesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedules(requestParameters: SchedulesApiGetSchedulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScheduleResponse>> {
            return localVarFp.getSchedules(requestParameters.workspaceId, requestParameters.scheduleSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run Schedule
         * @param {SchedulesApiRunScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSchedule(requestParameters: SchedulesApiRunScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.runSchedule(requestParameters.scheduleId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Schedule Urls
         * @param {SchedulesApiSearchScheduleUrlsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScheduleUrls(requestParameters: SchedulesApiSearchScheduleUrlsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScheduleUrlResponse>> {
            return localVarFp.searchScheduleUrls(requestParameters.workspaceId, requestParameters.scheduleUrlSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Schedule
         * @param {SchedulesApiUpdateScheduleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchedule(requestParameters: SchedulesApiUpdateScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleResponse> {
            return localVarFp.updateSchedule(requestParameters.scheduleId, requestParameters.workspaceId, requestParameters.scheduleUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchedulesApi - interface
 * @export
 * @interface SchedulesApi
 */
export interface SchedulesApiInterface {
    /**
     * 
     * @summary Create Schedules
     * @param {SchedulesApiCreateSchedulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    createSchedules(requestParameters: SchedulesApiCreateSchedulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScheduleResponse>>;

    /**
     * 
     * @summary Delete Schedule
     * @param {SchedulesApiDeleteScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    deleteSchedule(requestParameters: SchedulesApiDeleteScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Get Schedule
     * @param {SchedulesApiGetScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    getSchedule(requestParameters: SchedulesApiGetScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleResponse>;

    /**
     * 
     * @summary Get Schedule Url Details
     * @param {SchedulesApiGetScheduleUrlDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    getScheduleUrlDetails(requestParameters: SchedulesApiGetScheduleUrlDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleUrlDetailResponse>;

    /**
     * 
     * @summary Get Schedules
     * @param {SchedulesApiGetSchedulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    getSchedules(requestParameters: SchedulesApiGetSchedulesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScheduleResponse>>;

    /**
     * 
     * @summary Run Schedule
     * @param {SchedulesApiRunScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    runSchedule(requestParameters: SchedulesApiRunScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Search Schedule Urls
     * @param {SchedulesApiSearchScheduleUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    searchScheduleUrls(requestParameters: SchedulesApiSearchScheduleUrlsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScheduleUrlResponse>>;

    /**
     * 
     * @summary Update Schedule
     * @param {SchedulesApiUpdateScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApiInterface
     */
    updateSchedule(requestParameters: SchedulesApiUpdateScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleResponse>;

}

/**
 * Request parameters for createSchedules operation in SchedulesApi.
 * @export
 * @interface SchedulesApiCreateSchedulesRequest
 */
export interface SchedulesApiCreateSchedulesRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiCreateSchedules
     */
    readonly workspaceId: string

    /**
     * 
     * @type {Array<ScheduleCreateRequest>}
     * @memberof SchedulesApiCreateSchedules
     */
    readonly scheduleCreateRequest: Array<ScheduleCreateRequest>
}

/**
 * Request parameters for deleteSchedule operation in SchedulesApi.
 * @export
 * @interface SchedulesApiDeleteScheduleRequest
 */
export interface SchedulesApiDeleteScheduleRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiDeleteSchedule
     */
    readonly scheduleId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiDeleteSchedule
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getSchedule operation in SchedulesApi.
 * @export
 * @interface SchedulesApiGetScheduleRequest
 */
export interface SchedulesApiGetScheduleRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiGetSchedule
     */
    readonly scheduleId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiGetSchedule
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getScheduleUrlDetails operation in SchedulesApi.
 * @export
 * @interface SchedulesApiGetScheduleUrlDetailsRequest
 */
export interface SchedulesApiGetScheduleUrlDetailsRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiGetScheduleUrlDetails
     */
    readonly scheduleId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiGetScheduleUrlDetails
     */
    readonly urlId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiGetScheduleUrlDetails
     */
    readonly domainId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiGetScheduleUrlDetails
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getSchedules operation in SchedulesApi.
 * @export
 * @interface SchedulesApiGetSchedulesRequest
 */
export interface SchedulesApiGetSchedulesRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiGetSchedules
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ScheduleSearchRequest}
     * @memberof SchedulesApiGetSchedules
     */
    readonly scheduleSearchRequest: ScheduleSearchRequest
}

/**
 * Request parameters for runSchedule operation in SchedulesApi.
 * @export
 * @interface SchedulesApiRunScheduleRequest
 */
export interface SchedulesApiRunScheduleRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiRunSchedule
     */
    readonly scheduleId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiRunSchedule
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchScheduleUrls operation in SchedulesApi.
 * @export
 * @interface SchedulesApiSearchScheduleUrlsRequest
 */
export interface SchedulesApiSearchScheduleUrlsRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiSearchScheduleUrls
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ScheduleUrlSearchRequest}
     * @memberof SchedulesApiSearchScheduleUrls
     */
    readonly scheduleUrlSearchRequest: ScheduleUrlSearchRequest
}

/**
 * Request parameters for updateSchedule operation in SchedulesApi.
 * @export
 * @interface SchedulesApiUpdateScheduleRequest
 */
export interface SchedulesApiUpdateScheduleRequest {
    /**
     * 
     * @type {string}
     * @memberof SchedulesApiUpdateSchedule
     */
    readonly scheduleId: string

    /**
     * 
     * @type {string}
     * @memberof SchedulesApiUpdateSchedule
     */
    readonly workspaceId: string

    /**
     * 
     * @type {ScheduleUpdateRequest}
     * @memberof SchedulesApiUpdateSchedule
     */
    readonly scheduleUpdateRequest: ScheduleUpdateRequest
}

/**
 * SchedulesApi - object-oriented interface
 * @export
 * @class SchedulesApi
 * @extends {BaseAPI}
 */
export class SchedulesApi extends BaseAPI implements SchedulesApiInterface {
    /**
     * 
     * @summary Create Schedules
     * @param {SchedulesApiCreateSchedulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public createSchedules(requestParameters: SchedulesApiCreateSchedulesRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).createSchedules(requestParameters.workspaceId, requestParameters.scheduleCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Schedule
     * @param {SchedulesApiDeleteScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public deleteSchedule(requestParameters: SchedulesApiDeleteScheduleRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).deleteSchedule(requestParameters.scheduleId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Schedule
     * @param {SchedulesApiGetScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public getSchedule(requestParameters: SchedulesApiGetScheduleRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).getSchedule(requestParameters.scheduleId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Schedule Url Details
     * @param {SchedulesApiGetScheduleUrlDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public getScheduleUrlDetails(requestParameters: SchedulesApiGetScheduleUrlDetailsRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).getScheduleUrlDetails(requestParameters.scheduleId, requestParameters.urlId, requestParameters.domainId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Schedules
     * @param {SchedulesApiGetSchedulesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public getSchedules(requestParameters: SchedulesApiGetSchedulesRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).getSchedules(requestParameters.workspaceId, requestParameters.scheduleSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run Schedule
     * @param {SchedulesApiRunScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public runSchedule(requestParameters: SchedulesApiRunScheduleRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).runSchedule(requestParameters.scheduleId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Schedule Urls
     * @param {SchedulesApiSearchScheduleUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public searchScheduleUrls(requestParameters: SchedulesApiSearchScheduleUrlsRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).searchScheduleUrls(requestParameters.workspaceId, requestParameters.scheduleUrlSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Schedule
     * @param {SchedulesApiUpdateScheduleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public updateSchedule(requestParameters: SchedulesApiUpdateScheduleRequest, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).updateSchedule(requestParameters.scheduleId, requestParameters.workspaceId, requestParameters.scheduleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecretsApi - axios parameter creator
 * @export
 */
export const SecretsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Secret
         * @param {string} workspaceId 
         * @param {SecretCreateRequest} secretCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret: async (workspaceId: string, secretCreateRequest: SecretCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createSecret', 'workspaceId', workspaceId)
            // verify required parameter 'secretCreateRequest' is not null or undefined
            assertParamExists('createSecret', 'secretCreateRequest', secretCreateRequest)
            const localVarPath = `/v2/secrets/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Secret
         * @param {string} secretId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecret: async (secretId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteSecret', 'secretId', secretId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteSecret', 'workspaceId', workspaceId)
            const localVarPath = `/v2/secrets/{secret_id}`
                .replace(`{${"secret_id"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Secret
         * @param {string} secretId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecret: async (secretId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('getSecret', 'secretId', secretId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSecret', 'workspaceId', workspaceId)
            const localVarPath = `/v2/secrets/{secret_id}`
                .replace(`{${"secret_id"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Secret
         * @param {string} workspaceId 
         * @param {SecretSearchRequest} secretSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSecret: async (workspaceId: string, secretSearchRequest: SecretSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchSecret', 'workspaceId', workspaceId)
            // verify required parameter 'secretSearchRequest' is not null or undefined
            assertParamExists('searchSecret', 'secretSearchRequest', secretSearchRequest)
            const localVarPath = `/v2/secrets/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Secret
         * @param {string} secretId 
         * @param {string} workspaceId 
         * @param {SecretUpdateRequest} secretUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSecret: async (secretId: string, workspaceId: string, secretUpdateRequest: SecretUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('updateSecret', 'secretId', secretId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateSecret', 'workspaceId', workspaceId)
            // verify required parameter 'secretUpdateRequest' is not null or undefined
            assertParamExists('updateSecret', 'secretUpdateRequest', secretUpdateRequest)
            const localVarPath = `/v2/secrets/{secret_id}`
                .replace(`{${"secret_id"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secretUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecretsApi - functional programming interface
 * @export
 */
export const SecretsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecretsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Secret
         * @param {string} workspaceId 
         * @param {SecretCreateRequest} secretCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSecret(workspaceId: string, secretCreateRequest: SecretCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSecret(workspaceId, secretCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.createSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Secret
         * @param {string} secretId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSecret(secretId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSecret(secretId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.deleteSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Secret
         * @param {string} secretId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecret(secretId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecret(secretId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.getSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Secret
         * @param {string} workspaceId 
         * @param {SecretSearchRequest} secretSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSecret(workspaceId: string, secretSearchRequest: SecretSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SecretResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSecret(workspaceId, secretSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.searchSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Secret
         * @param {string} secretId 
         * @param {string} workspaceId 
         * @param {SecretUpdateRequest} secretUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSecret(secretId: string, workspaceId: string, secretUpdateRequest: SecretUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSecret(secretId, workspaceId, secretUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.updateSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecretsApi - factory interface
 * @export
 */
export const SecretsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecretsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Secret
         * @param {SecretsApiCreateSecretRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret(requestParameters: SecretsApiCreateSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<SecretResponse> {
            return localVarFp.createSecret(requestParameters.workspaceId, requestParameters.secretCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Secret
         * @param {SecretsApiDeleteSecretRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecret(requestParameters: SecretsApiDeleteSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteSecret(requestParameters.secretId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Secret
         * @param {SecretsApiGetSecretRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecret(requestParameters: SecretsApiGetSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<SecretResponse> {
            return localVarFp.getSecret(requestParameters.secretId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Secret
         * @param {SecretsApiSearchSecretRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSecret(requestParameters: SecretsApiSearchSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SecretResponse>> {
            return localVarFp.searchSecret(requestParameters.workspaceId, requestParameters.secretSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Secret
         * @param {SecretsApiUpdateSecretRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSecret(requestParameters: SecretsApiUpdateSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<SecretResponse> {
            return localVarFp.updateSecret(requestParameters.secretId, requestParameters.workspaceId, requestParameters.secretUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecretsApi - interface
 * @export
 * @interface SecretsApi
 */
export interface SecretsApiInterface {
    /**
     * 
     * @summary Create Secret
     * @param {SecretsApiCreateSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApiInterface
     */
    createSecret(requestParameters: SecretsApiCreateSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<SecretResponse>;

    /**
     * 
     * @summary Delete Secret
     * @param {SecretsApiDeleteSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApiInterface
     */
    deleteSecret(requestParameters: SecretsApiDeleteSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Get Secret
     * @param {SecretsApiGetSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApiInterface
     */
    getSecret(requestParameters: SecretsApiGetSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<SecretResponse>;

    /**
     * 
     * @summary Search Secret
     * @param {SecretsApiSearchSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApiInterface
     */
    searchSecret(requestParameters: SecretsApiSearchSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SecretResponse>>;

    /**
     * 
     * @summary Update Secret
     * @param {SecretsApiUpdateSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApiInterface
     */
    updateSecret(requestParameters: SecretsApiUpdateSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<SecretResponse>;

}

/**
 * Request parameters for createSecret operation in SecretsApi.
 * @export
 * @interface SecretsApiCreateSecretRequest
 */
export interface SecretsApiCreateSecretRequest {
    /**
     * 
     * @type {string}
     * @memberof SecretsApiCreateSecret
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SecretCreateRequest}
     * @memberof SecretsApiCreateSecret
     */
    readonly secretCreateRequest: SecretCreateRequest
}

/**
 * Request parameters for deleteSecret operation in SecretsApi.
 * @export
 * @interface SecretsApiDeleteSecretRequest
 */
export interface SecretsApiDeleteSecretRequest {
    /**
     * 
     * @type {string}
     * @memberof SecretsApiDeleteSecret
     */
    readonly secretId: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiDeleteSecret
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getSecret operation in SecretsApi.
 * @export
 * @interface SecretsApiGetSecretRequest
 */
export interface SecretsApiGetSecretRequest {
    /**
     * 
     * @type {string}
     * @memberof SecretsApiGetSecret
     */
    readonly secretId: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiGetSecret
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchSecret operation in SecretsApi.
 * @export
 * @interface SecretsApiSearchSecretRequest
 */
export interface SecretsApiSearchSecretRequest {
    /**
     * 
     * @type {string}
     * @memberof SecretsApiSearchSecret
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SecretSearchRequest}
     * @memberof SecretsApiSearchSecret
     */
    readonly secretSearchRequest: SecretSearchRequest
}

/**
 * Request parameters for updateSecret operation in SecretsApi.
 * @export
 * @interface SecretsApiUpdateSecretRequest
 */
export interface SecretsApiUpdateSecretRequest {
    /**
     * 
     * @type {string}
     * @memberof SecretsApiUpdateSecret
     */
    readonly secretId: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiUpdateSecret
     */
    readonly workspaceId: string

    /**
     * 
     * @type {SecretUpdateRequest}
     * @memberof SecretsApiUpdateSecret
     */
    readonly secretUpdateRequest: SecretUpdateRequest
}

/**
 * SecretsApi - object-oriented interface
 * @export
 * @class SecretsApi
 * @extends {BaseAPI}
 */
export class SecretsApi extends BaseAPI implements SecretsApiInterface {
    /**
     * 
     * @summary Create Secret
     * @param {SecretsApiCreateSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public createSecret(requestParameters: SecretsApiCreateSecretRequest, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).createSecret(requestParameters.workspaceId, requestParameters.secretCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Secret
     * @param {SecretsApiDeleteSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public deleteSecret(requestParameters: SecretsApiDeleteSecretRequest, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).deleteSecret(requestParameters.secretId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Secret
     * @param {SecretsApiGetSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public getSecret(requestParameters: SecretsApiGetSecretRequest, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).getSecret(requestParameters.secretId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Secret
     * @param {SecretsApiSearchSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public searchSecret(requestParameters: SecretsApiSearchSecretRequest, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).searchSecret(requestParameters.workspaceId, requestParameters.secretSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Secret
     * @param {SecretsApiUpdateSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public updateSecret(requestParameters: SecretsApiUpdateSecretRequest, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).updateSecret(requestParameters.secretId, requestParameters.workspaceId, requestParameters.secretUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SemanticSearchApi - axios parameter creator
 * @export
 */
export const SemanticSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Similar Docs By Doc Id
         * @param {string} workspaceId 
         * @param {DocumentSimilarityRequest} documentSimilarityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarDocsByDocId: async (workspaceId: string, documentSimilarityRequest: DocumentSimilarityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSimilarDocsByDocId', 'workspaceId', workspaceId)
            // verify required parameter 'documentSimilarityRequest' is not null or undefined
            assertParamExists('getSimilarDocsByDocId', 'documentSimilarityRequest', documentSimilarityRequest)
            const localVarPath = `/v2/similarities/document/live`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentSimilarityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Similar Docs By Query
         * @param {string} workspaceId 
         * @param {QuerySimilarityRequest} querySimilarityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarDocsByQuery: async (workspaceId: string, querySimilarityRequest: QuerySimilarityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSimilarDocsByQuery', 'workspaceId', workspaceId)
            // verify required parameter 'querySimilarityRequest' is not null or undefined
            assertParamExists('getSimilarDocsByQuery', 'querySimilarityRequest', querySimilarityRequest)
            const localVarPath = `/v2/similarities/query/live`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(querySimilarityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Schedule Similar Docs By Doc Id
         * @param {string} workspaceId 
         * @param {DocumentSimilarityTaskRequest} documentSimilarityTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleSimilarDocsByDocId: async (workspaceId: string, documentSimilarityTaskRequest: DocumentSimilarityTaskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('scheduleSimilarDocsByDocId', 'workspaceId', workspaceId)
            // verify required parameter 'documentSimilarityTaskRequest' is not null or undefined
            assertParamExists('scheduleSimilarDocsByDocId', 'documentSimilarityTaskRequest', documentSimilarityTaskRequest)
            const localVarPath = `/v2/similarities/document`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentSimilarityTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Schedule Similar Docs By Query
         * @param {string} workspaceId 
         * @param {QuerySimilarityTaskRequest} querySimilarityTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleSimilarDocsByQuery: async (workspaceId: string, querySimilarityTaskRequest: QuerySimilarityTaskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('scheduleSimilarDocsByQuery', 'workspaceId', workspaceId)
            // verify required parameter 'querySimilarityTaskRequest' is not null or undefined
            assertParamExists('scheduleSimilarDocsByQuery', 'querySimilarityTaskRequest', querySimilarityTaskRequest)
            const localVarPath = `/v2/similarities/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(querySimilarityTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SemanticSearchApi - functional programming interface
 * @export
 */
export const SemanticSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SemanticSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Similar Docs By Doc Id
         * @param {string} workspaceId 
         * @param {DocumentSimilarityRequest} documentSimilarityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarDocsByDocId(workspaceId: string, documentSimilarityRequest: DocumentSimilarityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VectorDocumentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimilarDocsByDocId(workspaceId, documentSimilarityRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SemanticSearchApi.getSimilarDocsByDocId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Similar Docs By Query
         * @param {string} workspaceId 
         * @param {QuerySimilarityRequest} querySimilarityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarDocsByQuery(workspaceId: string, querySimilarityRequest: QuerySimilarityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VectorDocumentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimilarDocsByQuery(workspaceId, querySimilarityRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SemanticSearchApi.getSimilarDocsByQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Schedule Similar Docs By Doc Id
         * @param {string} workspaceId 
         * @param {DocumentSimilarityTaskRequest} documentSimilarityTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleSimilarDocsByDocId(workspaceId: string, documentSimilarityTaskRequest: DocumentSimilarityTaskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VectorDocumentsTaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleSimilarDocsByDocId(workspaceId, documentSimilarityTaskRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SemanticSearchApi.scheduleSimilarDocsByDocId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Schedule Similar Docs By Query
         * @param {string} workspaceId 
         * @param {QuerySimilarityTaskRequest} querySimilarityTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleSimilarDocsByQuery(workspaceId: string, querySimilarityTaskRequest: QuerySimilarityTaskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VectorDocumentsTaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleSimilarDocsByQuery(workspaceId, querySimilarityTaskRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SemanticSearchApi.scheduleSimilarDocsByQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SemanticSearchApi - factory interface
 * @export
 */
export const SemanticSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SemanticSearchApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Similar Docs By Doc Id
         * @param {SemanticSearchApiGetSimilarDocsByDocIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarDocsByDocId(requestParameters: SemanticSearchApiGetSimilarDocsByDocIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<VectorDocumentResponse>> {
            return localVarFp.getSimilarDocsByDocId(requestParameters.workspaceId, requestParameters.documentSimilarityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Similar Docs By Query
         * @param {SemanticSearchApiGetSimilarDocsByQueryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarDocsByQuery(requestParameters: SemanticSearchApiGetSimilarDocsByQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<VectorDocumentResponse>> {
            return localVarFp.getSimilarDocsByQuery(requestParameters.workspaceId, requestParameters.querySimilarityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Schedule Similar Docs By Doc Id
         * @param {SemanticSearchApiScheduleSimilarDocsByDocIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleSimilarDocsByDocId(requestParameters: SemanticSearchApiScheduleSimilarDocsByDocIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<VectorDocumentsTaskResponse> {
            return localVarFp.scheduleSimilarDocsByDocId(requestParameters.workspaceId, requestParameters.documentSimilarityTaskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Schedule Similar Docs By Query
         * @param {SemanticSearchApiScheduleSimilarDocsByQueryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleSimilarDocsByQuery(requestParameters: SemanticSearchApiScheduleSimilarDocsByQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<VectorDocumentsTaskResponse> {
            return localVarFp.scheduleSimilarDocsByQuery(requestParameters.workspaceId, requestParameters.querySimilarityTaskRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SemanticSearchApi - interface
 * @export
 * @interface SemanticSearchApi
 */
export interface SemanticSearchApiInterface {
    /**
     * 
     * @summary Get Similar Docs By Doc Id
     * @param {SemanticSearchApiGetSimilarDocsByDocIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApiInterface
     */
    getSimilarDocsByDocId(requestParameters: SemanticSearchApiGetSimilarDocsByDocIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<VectorDocumentResponse>>;

    /**
     * 
     * @summary Get Similar Docs By Query
     * @param {SemanticSearchApiGetSimilarDocsByQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApiInterface
     */
    getSimilarDocsByQuery(requestParameters: SemanticSearchApiGetSimilarDocsByQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<VectorDocumentResponse>>;

    /**
     * 
     * @summary Schedule Similar Docs By Doc Id
     * @param {SemanticSearchApiScheduleSimilarDocsByDocIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApiInterface
     */
    scheduleSimilarDocsByDocId(requestParameters: SemanticSearchApiScheduleSimilarDocsByDocIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<VectorDocumentsTaskResponse>;

    /**
     * 
     * @summary Schedule Similar Docs By Query
     * @param {SemanticSearchApiScheduleSimilarDocsByQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApiInterface
     */
    scheduleSimilarDocsByQuery(requestParameters: SemanticSearchApiScheduleSimilarDocsByQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<VectorDocumentsTaskResponse>;

}

/**
 * Request parameters for getSimilarDocsByDocId operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiGetSimilarDocsByDocIdRequest
 */
export interface SemanticSearchApiGetSimilarDocsByDocIdRequest {
    /**
     * 
     * @type {string}
     * @memberof SemanticSearchApiGetSimilarDocsByDocId
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DocumentSimilarityRequest}
     * @memberof SemanticSearchApiGetSimilarDocsByDocId
     */
    readonly documentSimilarityRequest: DocumentSimilarityRequest
}

/**
 * Request parameters for getSimilarDocsByQuery operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiGetSimilarDocsByQueryRequest
 */
export interface SemanticSearchApiGetSimilarDocsByQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof SemanticSearchApiGetSimilarDocsByQuery
     */
    readonly workspaceId: string

    /**
     * 
     * @type {QuerySimilarityRequest}
     * @memberof SemanticSearchApiGetSimilarDocsByQuery
     */
    readonly querySimilarityRequest: QuerySimilarityRequest
}

/**
 * Request parameters for scheduleSimilarDocsByDocId operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiScheduleSimilarDocsByDocIdRequest
 */
export interface SemanticSearchApiScheduleSimilarDocsByDocIdRequest {
    /**
     * 
     * @type {string}
     * @memberof SemanticSearchApiScheduleSimilarDocsByDocId
     */
    readonly workspaceId: string

    /**
     * 
     * @type {DocumentSimilarityTaskRequest}
     * @memberof SemanticSearchApiScheduleSimilarDocsByDocId
     */
    readonly documentSimilarityTaskRequest: DocumentSimilarityTaskRequest
}

/**
 * Request parameters for scheduleSimilarDocsByQuery operation in SemanticSearchApi.
 * @export
 * @interface SemanticSearchApiScheduleSimilarDocsByQueryRequest
 */
export interface SemanticSearchApiScheduleSimilarDocsByQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof SemanticSearchApiScheduleSimilarDocsByQuery
     */
    readonly workspaceId: string

    /**
     * 
     * @type {QuerySimilarityTaskRequest}
     * @memberof SemanticSearchApiScheduleSimilarDocsByQuery
     */
    readonly querySimilarityTaskRequest: QuerySimilarityTaskRequest
}

/**
 * SemanticSearchApi - object-oriented interface
 * @export
 * @class SemanticSearchApi
 * @extends {BaseAPI}
 */
export class SemanticSearchApi extends BaseAPI implements SemanticSearchApiInterface {
    /**
     * 
     * @summary Get Similar Docs By Doc Id
     * @param {SemanticSearchApiGetSimilarDocsByDocIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public getSimilarDocsByDocId(requestParameters: SemanticSearchApiGetSimilarDocsByDocIdRequest, options?: RawAxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).getSimilarDocsByDocId(requestParameters.workspaceId, requestParameters.documentSimilarityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Similar Docs By Query
     * @param {SemanticSearchApiGetSimilarDocsByQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public getSimilarDocsByQuery(requestParameters: SemanticSearchApiGetSimilarDocsByQueryRequest, options?: RawAxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).getSimilarDocsByQuery(requestParameters.workspaceId, requestParameters.querySimilarityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Schedule Similar Docs By Doc Id
     * @param {SemanticSearchApiScheduleSimilarDocsByDocIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public scheduleSimilarDocsByDocId(requestParameters: SemanticSearchApiScheduleSimilarDocsByDocIdRequest, options?: RawAxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).scheduleSimilarDocsByDocId(requestParameters.workspaceId, requestParameters.documentSimilarityTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Schedule Similar Docs By Query
     * @param {SemanticSearchApiScheduleSimilarDocsByQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchApi
     */
    public scheduleSimilarDocsByQuery(requestParameters: SemanticSearchApiScheduleSimilarDocsByQueryRequest, options?: RawAxiosRequestConfig) {
        return SemanticSearchApiFp(this.configuration).scheduleSimilarDocsByQuery(requestParameters.workspaceId, requestParameters.querySimilarityTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ShopifyApi - axios parameter creator
 * @export
 */
export const ShopifyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Data Request
         * @param {CustomerDataRequestPayload} customerDataRequestPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDataRequest: async (customerDataRequestPayload: CustomerDataRequestPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerDataRequestPayload' is not null or undefined
            assertParamExists('customerDataRequest', 'customerDataRequestPayload', customerDataRequestPayload)
            const localVarPath = `/v2/integrations/shopify/webhooks/customers/data_request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerDataRequestPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Redact
         * @param {CustomerRedactPayload} customerRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerRedact: async (customerRedactPayload: CustomerRedactPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerRedactPayload' is not null or undefined
            assertParamExists('customerRedact', 'customerRedactPayload', customerRedactPayload)
            const localVarPath = `/v2/integrations/shopify/webhooks/customers/redact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerRedactPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Shopify
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopify: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getShopify', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/shopify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Shop Redact
         * @param {ShopRedactPayload} shopRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopRedact: async (shopRedactPayload: ShopRedactPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shopRedactPayload' is not null or undefined
            assertParamExists('shopRedact', 'shopRedactPayload', shopRedactPayload)
            const localVarPath = `/v2/integrations/shopify/webhooks/shop/redact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopRedactPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle subscription cancellation webhooks from Shopify.
         * @summary Subscription Cancel
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionCancel: async (xShopifyHmacSha256?: string, xShopifyTopic?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/integrations/shopify/webhooks/billing/subscription_cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xShopifyHmacSha256 != null) {
                localVarHeaderParameter['x-shopify-hmac-sha256'] = String(xShopifyHmacSha256);
            }
            if (xShopifyTopic != null) {
                localVarHeaderParameter['x-shopify-topic'] = String(xShopifyTopic);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
         * @summary Subscription Update
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionUpdate: async (xShopifyHmacSha256?: string, xShopifyTopic?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/integrations/shopify/webhooks/billing/subscription_update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xShopifyHmacSha256 != null) {
                localVarHeaderParameter['x-shopify-hmac-sha256'] = String(xShopifyHmacSha256);
            }
            if (xShopifyTopic != null) {
                localVarHeaderParameter['x-shopify-topic'] = String(xShopifyTopic);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShopifyApi - functional programming interface
 * @export
 */
export const ShopifyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShopifyApiAxiosParamCreator(configuration)
    return {
        /**
         * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Data Request
         * @param {CustomerDataRequestPayload} customerDataRequestPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerDataRequest(customerDataRequestPayload: CustomerDataRequestPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerDataRequest(customerDataRequestPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopifyApi.customerDataRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Redact
         * @param {CustomerRedactPayload} customerRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerRedact(customerRedactPayload: CustomerRedactPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerRedact(customerRedactPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopifyApi.customerRedact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Shopify
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShopify(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopifyIntegrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShopify(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopifyApi.getShopify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Shop Redact
         * @param {ShopRedactPayload} shopRedactPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopRedact(shopRedactPayload: ShopRedactPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopRedact(shopRedactPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopifyApi.shopRedact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle subscription cancellation webhooks from Shopify.
         * @summary Subscription Cancel
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionCancel(xShopifyHmacSha256?: string, xShopifyTopic?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionCancel(xShopifyHmacSha256, xShopifyTopic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopifyApi.subscriptionCancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
         * @summary Subscription Update
         * @param {string} [xShopifyHmacSha256] 
         * @param {string} [xShopifyTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionUpdate(xShopifyHmacSha256?: string, xShopifyTopic?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionUpdate(xShopifyHmacSha256, xShopifyTopic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopifyApi.subscriptionUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShopifyApi - factory interface
 * @export
 */
export const ShopifyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShopifyApiFp(configuration)
    return {
        /**
         * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Data Request
         * @param {ShopifyApiCustomerDataRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDataRequest(requestParameters: ShopifyApiCustomerDataRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.customerDataRequest(requestParameters.customerDataRequestPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Customer Redact
         * @param {ShopifyApiCustomerRedactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerRedact(requestParameters: ShopifyApiCustomerRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.customerRedact(requestParameters.customerRedactPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Shopify
         * @param {ShopifyApiGetShopifyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShopify(requestParameters: ShopifyApiGetShopifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ShopifyIntegrationResponse> {
            return localVarFp.getShopify(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
         * @summary Shop Redact
         * @param {ShopifyApiShopRedactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopRedact(requestParameters: ShopifyApiShopRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.shopRedact(requestParameters.shopRedactPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle subscription cancellation webhooks from Shopify.
         * @summary Subscription Cancel
         * @param {ShopifyApiSubscriptionCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionCancel(requestParameters: ShopifyApiSubscriptionCancelRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.subscriptionCancel(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
         * @summary Subscription Update
         * @param {ShopifyApiSubscriptionUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionUpdate(requestParameters: ShopifyApiSubscriptionUpdateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.subscriptionUpdate(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShopifyApi - interface
 * @export
 * @interface ShopifyApi
 */
export interface ShopifyApiInterface {
    /**
     * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Data Request
     * @param {ShopifyApiCustomerDataRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApiInterface
     */
    customerDataRequest(requestParameters: ShopifyApiCustomerDataRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Redact
     * @param {ShopifyApiCustomerRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApiInterface
     */
    customerRedact(requestParameters: ShopifyApiCustomerRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Get Shopify
     * @param {ShopifyApiGetShopifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApiInterface
     */
    getShopify(requestParameters: ShopifyApiGetShopifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ShopifyIntegrationResponse>;

    /**
     * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Shop Redact
     * @param {ShopifyApiShopRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApiInterface
     */
    shopRedact(requestParameters: ShopifyApiShopRedactRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle subscription cancellation webhooks from Shopify.
     * @summary Subscription Cancel
     * @param {ShopifyApiSubscriptionCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApiInterface
     */
    subscriptionCancel(requestParameters?: ShopifyApiSubscriptionCancelRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
     * @summary Subscription Update
     * @param {ShopifyApiSubscriptionUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApiInterface
     */
    subscriptionUpdate(requestParameters?: ShopifyApiSubscriptionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

}

/**
 * Request parameters for customerDataRequest operation in ShopifyApi.
 * @export
 * @interface ShopifyApiCustomerDataRequestRequest
 */
export interface ShopifyApiCustomerDataRequestRequest {
    /**
     * 
     * @type {CustomerDataRequestPayload}
     * @memberof ShopifyApiCustomerDataRequest
     */
    readonly customerDataRequestPayload: CustomerDataRequestPayload
}

/**
 * Request parameters for customerRedact operation in ShopifyApi.
 * @export
 * @interface ShopifyApiCustomerRedactRequest
 */
export interface ShopifyApiCustomerRedactRequest {
    /**
     * 
     * @type {CustomerRedactPayload}
     * @memberof ShopifyApiCustomerRedact
     */
    readonly customerRedactPayload: CustomerRedactPayload
}

/**
 * Request parameters for getShopify operation in ShopifyApi.
 * @export
 * @interface ShopifyApiGetShopifyRequest
 */
export interface ShopifyApiGetShopifyRequest {
    /**
     * 
     * @type {string}
     * @memberof ShopifyApiGetShopify
     */
    readonly workspaceId: string
}

/**
 * Request parameters for shopRedact operation in ShopifyApi.
 * @export
 * @interface ShopifyApiShopRedactRequest
 */
export interface ShopifyApiShopRedactRequest {
    /**
     * 
     * @type {ShopRedactPayload}
     * @memberof ShopifyApiShopRedact
     */
    readonly shopRedactPayload: ShopRedactPayload
}

/**
 * Request parameters for subscriptionCancel operation in ShopifyApi.
 * @export
 * @interface ShopifyApiSubscriptionCancelRequest
 */
export interface ShopifyApiSubscriptionCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof ShopifyApiSubscriptionCancel
     */
    readonly xShopifyHmacSha256?: string

    /**
     * 
     * @type {string}
     * @memberof ShopifyApiSubscriptionCancel
     */
    readonly xShopifyTopic?: string
}

/**
 * Request parameters for subscriptionUpdate operation in ShopifyApi.
 * @export
 * @interface ShopifyApiSubscriptionUpdateRequest
 */
export interface ShopifyApiSubscriptionUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ShopifyApiSubscriptionUpdate
     */
    readonly xShopifyHmacSha256?: string

    /**
     * 
     * @type {string}
     * @memberof ShopifyApiSubscriptionUpdate
     */
    readonly xShopifyTopic?: string
}

/**
 * ShopifyApi - object-oriented interface
 * @export
 * @class ShopifyApi
 * @extends {BaseAPI}
 */
export class ShopifyApi extends BaseAPI implements ShopifyApiInterface {
    /**
     * Handle customer data request webhooks from Shopify.  This endpoint is called when a customer requests their data from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Data Request
     * @param {ShopifyApiCustomerDataRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApi
     */
    public customerDataRequest(requestParameters: ShopifyApiCustomerDataRequestRequest, options?: RawAxiosRequestConfig) {
        return ShopifyApiFp(this.configuration).customerDataRequest(requestParameters.customerDataRequestPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle customer redact webhooks from Shopify.  This endpoint is called when a customer requests their data to be deleted from a Shopify store.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Customer Redact
     * @param {ShopifyApiCustomerRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApi
     */
    public customerRedact(requestParameters: ShopifyApiCustomerRedactRequest, options?: RawAxiosRequestConfig) {
        return ShopifyApiFp(this.configuration).customerRedact(requestParameters.customerRedactPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Shopify
     * @param {ShopifyApiGetShopifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApi
     */
    public getShopify(requestParameters: ShopifyApiGetShopifyRequest, options?: RawAxiosRequestConfig) {
        return ShopifyApiFp(this.configuration).getShopify(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle shop redact webhooks from Shopify.  This endpoint is called 48 hours after a store owner uninstalls the app.  Args:     request: The FastAPI request object     payload: The webhook payload  Returns:     A 200 OK response if the webhook is valid and processed successfully
     * @summary Shop Redact
     * @param {ShopifyApiShopRedactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApi
     */
    public shopRedact(requestParameters: ShopifyApiShopRedactRequest, options?: RawAxiosRequestConfig) {
        return ShopifyApiFp(this.configuration).shopRedact(requestParameters.shopRedactPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle subscription cancellation webhooks from Shopify.
     * @summary Subscription Cancel
     * @param {ShopifyApiSubscriptionCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApi
     */
    public subscriptionCancel(requestParameters: ShopifyApiSubscriptionCancelRequest = {}, options?: RawAxiosRequestConfig) {
        return ShopifyApiFp(this.configuration).subscriptionCancel(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle subscription update webhooks from Shopify.  This is called when a subscription is created, updated, or activated.
     * @summary Subscription Update
     * @param {ShopifyApiSubscriptionUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopifyApi
     */
    public subscriptionUpdate(requestParameters: ShopifyApiSubscriptionUpdateRequest = {}, options?: RawAxiosRequestConfig) {
        return ShopifyApiFp(this.configuration).subscriptionUpdate(requestParameters.xShopifyHmacSha256, requestParameters.xShopifyTopic, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SlackApi - axios parameter creator
 * @export
 */
export const SlackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Slack Channels
         * @param {string} slackTeamId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackChannels: async (slackTeamId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slackTeamId' is not null or undefined
            assertParamExists('getSlackChannels', 'slackTeamId', slackTeamId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSlackChannels', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/slack/{slack_team_id}/channels`
                .replace(`{${"slack_team_id"}}`, encodeURIComponent(String(slackTeamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Slack Workspaces
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackWorkspaces: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSlackWorkspaces', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/slack/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SlackApi - functional programming interface
 * @export
 */
export const SlackApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SlackApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Slack Channels
         * @param {string} slackTeamId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlackChannels(slackTeamId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SlackChannelResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlackChannels(slackTeamId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlackApi.getSlackChannels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Slack Workspaces
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlackWorkspaces(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SlackWorkspaceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlackWorkspaces(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlackApi.getSlackWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SlackApi - factory interface
 * @export
 */
export const SlackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SlackApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Slack Channels
         * @param {SlackApiGetSlackChannelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackChannels(requestParameters: SlackApiGetSlackChannelsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackChannelResponse>> {
            return localVarFp.getSlackChannels(requestParameters.slackTeamId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Slack Workspaces
         * @param {SlackApiGetSlackWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlackWorkspaces(requestParameters: SlackApiGetSlackWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackWorkspaceResponse>> {
            return localVarFp.getSlackWorkspaces(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SlackApi - interface
 * @export
 * @interface SlackApi
 */
export interface SlackApiInterface {
    /**
     * 
     * @summary Get Slack Channels
     * @param {SlackApiGetSlackChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackApiInterface
     */
    getSlackChannels(requestParameters: SlackApiGetSlackChannelsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackChannelResponse>>;

    /**
     * 
     * @summary Get Slack Workspaces
     * @param {SlackApiGetSlackWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackApiInterface
     */
    getSlackWorkspaces(requestParameters: SlackApiGetSlackWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SlackWorkspaceResponse>>;

}

/**
 * Request parameters for getSlackChannels operation in SlackApi.
 * @export
 * @interface SlackApiGetSlackChannelsRequest
 */
export interface SlackApiGetSlackChannelsRequest {
    /**
     * 
     * @type {string}
     * @memberof SlackApiGetSlackChannels
     */
    readonly slackTeamId: string

    /**
     * 
     * @type {string}
     * @memberof SlackApiGetSlackChannels
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getSlackWorkspaces operation in SlackApi.
 * @export
 * @interface SlackApiGetSlackWorkspacesRequest
 */
export interface SlackApiGetSlackWorkspacesRequest {
    /**
     * 
     * @type {string}
     * @memberof SlackApiGetSlackWorkspaces
     */
    readonly workspaceId: string
}

/**
 * SlackApi - object-oriented interface
 * @export
 * @class SlackApi
 * @extends {BaseAPI}
 */
export class SlackApi extends BaseAPI implements SlackApiInterface {
    /**
     * 
     * @summary Get Slack Channels
     * @param {SlackApiGetSlackChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackApi
     */
    public getSlackChannels(requestParameters: SlackApiGetSlackChannelsRequest, options?: RawAxiosRequestConfig) {
        return SlackApiFp(this.configuration).getSlackChannels(requestParameters.slackTeamId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Slack Workspaces
     * @param {SlackApiGetSlackWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlackApi
     */
    public getSlackWorkspaces(requestParameters: SlackApiGetSlackWorkspacesRequest, options?: RawAxiosRequestConfig) {
        return SlackApiFp(this.configuration).getSlackWorkspaces(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Tag
         * @param {string} workspaceId 
         * @param {TagCreateRequest} tagCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag: async (workspaceId: string, tagCreateRequest: TagCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createTag', 'workspaceId', workspaceId)
            // verify required parameter 'tagCreateRequest' is not null or undefined
            assertParamExists('createTag', 'tagCreateRequest', tagCreateRequest)
            const localVarPath = `/v2/tags/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Tag
         * @param {string} tagId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (tagId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('deleteTag', 'tagId', tagId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteTag', 'workspaceId', workspaceId)
            const localVarPath = `/v2/tags/{tag_id}`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Tags
         * @param {string} workspaceId 
         * @param {TagSearchRequest} tagSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTags: async (workspaceId: string, tagSearchRequest: TagSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchTags', 'workspaceId', workspaceId)
            // verify required parameter 'tagSearchRequest' is not null or undefined
            assertParamExists('searchTags', 'tagSearchRequest', tagSearchRequest)
            const localVarPath = `/v2/tags/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Tag
         * @param {string} tagId 
         * @param {string} workspaceId 
         * @param {TagUpdateRequest} tagUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag: async (tagId: string, workspaceId: string, tagUpdateRequest: TagUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('updateTag', 'tagId', tagId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateTag', 'workspaceId', workspaceId)
            // verify required parameter 'tagUpdateRequest' is not null or undefined
            assertParamExists('updateTag', 'tagUpdateRequest', tagUpdateRequest)
            const localVarPath = `/v2/tags/{tag_id}`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Tag
         * @param {string} workspaceId 
         * @param {TagCreateRequest} tagCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTag(workspaceId: string, tagCreateRequest: TagCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTag(workspaceId, tagCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.createTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Tag
         * @param {string} tagId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(tagId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(tagId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.deleteTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Tags
         * @param {string} workspaceId 
         * @param {TagSearchRequest} tagSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTags(workspaceId: string, tagSearchRequest: TagSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTags(workspaceId, tagSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.searchTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Tag
         * @param {string} tagId 
         * @param {string} workspaceId 
         * @param {TagUpdateRequest} tagUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTag(tagId: string, workspaceId: string, tagUpdateRequest: TagUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTag(tagId, workspaceId, tagUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.updateTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Tag
         * @param {TagsApiCreateTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTag(requestParameters: TagsApiCreateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagResponse> {
            return localVarFp.createTag(requestParameters.workspaceId, requestParameters.tagCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Tag
         * @param {TagsApiDeleteTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(requestParameters: TagsApiDeleteTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteTag(requestParameters.tagId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Tags
         * @param {TagsApiSearchTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTags(requestParameters: TagsApiSearchTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<TagResponse>> {
            return localVarFp.searchTags(requestParameters.workspaceId, requestParameters.tagSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Tag
         * @param {TagsApiUpdateTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(requestParameters: TagsApiUpdateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagResponse> {
            return localVarFp.updateTag(requestParameters.tagId, requestParameters.workspaceId, requestParameters.tagUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - interface
 * @export
 * @interface TagsApi
 */
export interface TagsApiInterface {
    /**
     * 
     * @summary Create Tag
     * @param {TagsApiCreateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    createTag(requestParameters: TagsApiCreateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagResponse>;

    /**
     * 
     * @summary Delete Tag
     * @param {TagsApiDeleteTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    deleteTag(requestParameters: TagsApiDeleteTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Search Tags
     * @param {TagsApiSearchTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    searchTags(requestParameters: TagsApiSearchTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<TagResponse>>;

    /**
     * 
     * @summary Update Tag
     * @param {TagsApiUpdateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiInterface
     */
    updateTag(requestParameters: TagsApiUpdateTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagResponse>;

}

/**
 * Request parameters for createTag operation in TagsApi.
 * @export
 * @interface TagsApiCreateTagRequest
 */
export interface TagsApiCreateTagRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiCreateTag
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TagCreateRequest}
     * @memberof TagsApiCreateTag
     */
    readonly tagCreateRequest: TagCreateRequest
}

/**
 * Request parameters for deleteTag operation in TagsApi.
 * @export
 * @interface TagsApiDeleteTagRequest
 */
export interface TagsApiDeleteTagRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiDeleteTag
     */
    readonly tagId: string

    /**
     * 
     * @type {string}
     * @memberof TagsApiDeleteTag
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchTags operation in TagsApi.
 * @export
 * @interface TagsApiSearchTagsRequest
 */
export interface TagsApiSearchTagsRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiSearchTags
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TagSearchRequest}
     * @memberof TagsApiSearchTags
     */
    readonly tagSearchRequest: TagSearchRequest
}

/**
 * Request parameters for updateTag operation in TagsApi.
 * @export
 * @interface TagsApiUpdateTagRequest
 */
export interface TagsApiUpdateTagRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiUpdateTag
     */
    readonly tagId: string

    /**
     * 
     * @type {string}
     * @memberof TagsApiUpdateTag
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TagUpdateRequest}
     * @memberof TagsApiUpdateTag
     */
    readonly tagUpdateRequest: TagUpdateRequest
}

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI implements TagsApiInterface {
    /**
     * 
     * @summary Create Tag
     * @param {TagsApiCreateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public createTag(requestParameters: TagsApiCreateTagRequest, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).createTag(requestParameters.workspaceId, requestParameters.tagCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Tag
     * @param {TagsApiDeleteTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTag(requestParameters: TagsApiDeleteTagRequest, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteTag(requestParameters.tagId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Tags
     * @param {TagsApiSearchTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public searchTags(requestParameters: TagsApiSearchTagsRequest, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).searchTags(requestParameters.workspaceId, requestParameters.tagSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Tag
     * @param {TagsApiUpdateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public updateTag(requestParameters: TagsApiUpdateTagRequest, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTag(requestParameters.tagId, requestParameters.workspaceId, requestParameters.tagUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TrackingApi - axios parameter creator
 * @export
 */
export const TrackingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Search Events
         * @param {string} workspaceId 
         * @param {TrackingEventSearchRequest} trackingEventSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEvents: async (workspaceId: string, trackingEventSearchRequest: TrackingEventSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchEvents', 'workspaceId', workspaceId)
            // verify required parameter 'trackingEventSearchRequest' is not null or undefined
            assertParamExists('searchEvents', 'trackingEventSearchRequest', trackingEventSearchRequest)
            const localVarPath = `/v2/tracking/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingEventSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Links
         * @param {string} workspaceId 
         * @param {TrackingLinkSearchRequest} trackingLinkSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLinks: async (workspaceId: string, trackingLinkSearchRequest: TrackingLinkSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchLinks', 'workspaceId', workspaceId)
            // verify required parameter 'trackingLinkSearchRequest' is not null or undefined
            assertParamExists('searchLinks', 'trackingLinkSearchRequest', trackingLinkSearchRequest)
            const localVarPath = `/v2/tracking/links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingLinkSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Sources
         * @param {string} workspaceId 
         * @param {TrackingSourceSearchRequest} trackingSourceSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSources: async (workspaceId: string, trackingSourceSearchRequest: TrackingSourceSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchSources', 'workspaceId', workspaceId)
            // verify required parameter 'trackingSourceSearchRequest' is not null or undefined
            assertParamExists('searchSources', 'trackingSourceSearchRequest', trackingSourceSearchRequest)
            const localVarPath = `/v2/tracking/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingSourceSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Track Click
         * @param {string} workspaceId 
         * @param {TrackingSourceCreateRequest} trackingSourceCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackClick: async (workspaceId: string, trackingSourceCreateRequest: TrackingSourceCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('trackClick', 'workspaceId', workspaceId)
            // verify required parameter 'trackingSourceCreateRequest' is not null or undefined
            assertParamExists('trackClick', 'trackingSourceCreateRequest', trackingSourceCreateRequest)
            const localVarPath = `/v2/tracking/clk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingSourceCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Track Event
         * @param {string} workspaceId 
         * @param {TrackingEventCreateRequests} trackingEventCreateRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackEvent: async (workspaceId: string, trackingEventCreateRequests: TrackingEventCreateRequests, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('trackEvent', 'workspaceId', workspaceId)
            // verify required parameter 'trackingEventCreateRequests' is not null or undefined
            assertParamExists('trackEvent', 'trackingEventCreateRequests', trackingEventCreateRequests)
            const localVarPath = `/v2/tracking/evnt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingEventCreateRequests, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Track Link
         * @param {string} workspaceId 
         * @param {TrackingLinksCreateRequest} trackingLinksCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackLink: async (workspaceId: string, trackingLinksCreateRequest: TrackingLinksCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('trackLink', 'workspaceId', workspaceId)
            // verify required parameter 'trackingLinksCreateRequest' is not null or undefined
            assertParamExists('trackLink', 'trackingLinksCreateRequest', trackingLinksCreateRequest)
            const localVarPath = `/v2/tracking/lnk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackingLinksCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackingApi - functional programming interface
 * @export
 */
export const TrackingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Search Events
         * @param {string} workspaceId 
         * @param {TrackingEventSearchRequest} trackingEventSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchEvents(workspaceId: string, trackingEventSearchRequest: TrackingEventSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchEvents(workspaceId, trackingEventSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackingApi.searchEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Links
         * @param {string} workspaceId 
         * @param {TrackingLinkSearchRequest} trackingLinkSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchLinks(workspaceId: string, trackingLinkSearchRequest: TrackingLinkSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingLinksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchLinks(workspaceId, trackingLinkSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackingApi.searchLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Sources
         * @param {string} workspaceId 
         * @param {TrackingSourceSearchRequest} trackingSourceSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSources(workspaceId: string, trackingSourceSearchRequest: TrackingSourceSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingSourcesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSources(workspaceId, trackingSourceSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackingApi.searchSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Track Click
         * @param {string} workspaceId 
         * @param {TrackingSourceCreateRequest} trackingSourceCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackClick(workspaceId: string, trackingSourceCreateRequest: TrackingSourceCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackClick(workspaceId, trackingSourceCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackingApi.trackClick']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Track Event
         * @param {string} workspaceId 
         * @param {TrackingEventCreateRequests} trackingEventCreateRequests 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackEvent(workspaceId: string, trackingEventCreateRequests: TrackingEventCreateRequests, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackEvent(workspaceId, trackingEventCreateRequests, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackingApi.trackEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Track Link
         * @param {string} workspaceId 
         * @param {TrackingLinksCreateRequest} trackingLinksCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackLink(workspaceId: string, trackingLinksCreateRequest: TrackingLinksCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackLink(workspaceId, trackingLinksCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TrackingApi.trackLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TrackingApi - factory interface
 * @export
 */
export const TrackingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackingApiFp(configuration)
    return {
        /**
         * 
         * @summary Search Events
         * @param {TrackingApiSearchEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEvents(requestParameters: TrackingApiSearchEventsRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrackingEventsResponse> {
            return localVarFp.searchEvents(requestParameters.workspaceId, requestParameters.trackingEventSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Links
         * @param {TrackingApiSearchLinksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLinks(requestParameters: TrackingApiSearchLinksRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrackingLinksResponse> {
            return localVarFp.searchLinks(requestParameters.workspaceId, requestParameters.trackingLinkSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Sources
         * @param {TrackingApiSearchSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSources(requestParameters: TrackingApiSearchSourcesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrackingSourcesResponse> {
            return localVarFp.searchSources(requestParameters.workspaceId, requestParameters.trackingSourceSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Track Click
         * @param {TrackingApiTrackClickRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackClick(requestParameters: TrackingApiTrackClickRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.trackClick(requestParameters.workspaceId, requestParameters.trackingSourceCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Track Event
         * @param {TrackingApiTrackEventRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackEvent(requestParameters: TrackingApiTrackEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.trackEvent(requestParameters.workspaceId, requestParameters.trackingEventCreateRequests, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Track Link
         * @param {TrackingApiTrackLinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackLink(requestParameters: TrackingApiTrackLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.trackLink(requestParameters.workspaceId, requestParameters.trackingLinksCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrackingApi - interface
 * @export
 * @interface TrackingApi
 */
export interface TrackingApiInterface {
    /**
     * 
     * @summary Search Events
     * @param {TrackingApiSearchEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApiInterface
     */
    searchEvents(requestParameters: TrackingApiSearchEventsRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrackingEventsResponse>;

    /**
     * 
     * @summary Search Links
     * @param {TrackingApiSearchLinksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApiInterface
     */
    searchLinks(requestParameters: TrackingApiSearchLinksRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrackingLinksResponse>;

    /**
     * 
     * @summary Search Sources
     * @param {TrackingApiSearchSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApiInterface
     */
    searchSources(requestParameters: TrackingApiSearchSourcesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TrackingSourcesResponse>;

    /**
     * 
     * @summary Track Click
     * @param {TrackingApiTrackClickRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApiInterface
     */
    trackClick(requestParameters: TrackingApiTrackClickRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Track Event
     * @param {TrackingApiTrackEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApiInterface
     */
    trackEvent(requestParameters: TrackingApiTrackEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Track Link
     * @param {TrackingApiTrackLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApiInterface
     */
    trackLink(requestParameters: TrackingApiTrackLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

}

/**
 * Request parameters for searchEvents operation in TrackingApi.
 * @export
 * @interface TrackingApiSearchEventsRequest
 */
export interface TrackingApiSearchEventsRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingApiSearchEvents
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TrackingEventSearchRequest}
     * @memberof TrackingApiSearchEvents
     */
    readonly trackingEventSearchRequest: TrackingEventSearchRequest
}

/**
 * Request parameters for searchLinks operation in TrackingApi.
 * @export
 * @interface TrackingApiSearchLinksRequest
 */
export interface TrackingApiSearchLinksRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingApiSearchLinks
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TrackingLinkSearchRequest}
     * @memberof TrackingApiSearchLinks
     */
    readonly trackingLinkSearchRequest: TrackingLinkSearchRequest
}

/**
 * Request parameters for searchSources operation in TrackingApi.
 * @export
 * @interface TrackingApiSearchSourcesRequest
 */
export interface TrackingApiSearchSourcesRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingApiSearchSources
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TrackingSourceSearchRequest}
     * @memberof TrackingApiSearchSources
     */
    readonly trackingSourceSearchRequest: TrackingSourceSearchRequest
}

/**
 * Request parameters for trackClick operation in TrackingApi.
 * @export
 * @interface TrackingApiTrackClickRequest
 */
export interface TrackingApiTrackClickRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingApiTrackClick
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TrackingSourceCreateRequest}
     * @memberof TrackingApiTrackClick
     */
    readonly trackingSourceCreateRequest: TrackingSourceCreateRequest
}

/**
 * Request parameters for trackEvent operation in TrackingApi.
 * @export
 * @interface TrackingApiTrackEventRequest
 */
export interface TrackingApiTrackEventRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingApiTrackEvent
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TrackingEventCreateRequests}
     * @memberof TrackingApiTrackEvent
     */
    readonly trackingEventCreateRequests: TrackingEventCreateRequests
}

/**
 * Request parameters for trackLink operation in TrackingApi.
 * @export
 * @interface TrackingApiTrackLinkRequest
 */
export interface TrackingApiTrackLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof TrackingApiTrackLink
     */
    readonly workspaceId: string

    /**
     * 
     * @type {TrackingLinksCreateRequest}
     * @memberof TrackingApiTrackLink
     */
    readonly trackingLinksCreateRequest: TrackingLinksCreateRequest
}

/**
 * TrackingApi - object-oriented interface
 * @export
 * @class TrackingApi
 * @extends {BaseAPI}
 */
export class TrackingApi extends BaseAPI implements TrackingApiInterface {
    /**
     * 
     * @summary Search Events
     * @param {TrackingApiSearchEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    public searchEvents(requestParameters: TrackingApiSearchEventsRequest, options?: RawAxiosRequestConfig) {
        return TrackingApiFp(this.configuration).searchEvents(requestParameters.workspaceId, requestParameters.trackingEventSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Links
     * @param {TrackingApiSearchLinksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    public searchLinks(requestParameters: TrackingApiSearchLinksRequest, options?: RawAxiosRequestConfig) {
        return TrackingApiFp(this.configuration).searchLinks(requestParameters.workspaceId, requestParameters.trackingLinkSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Sources
     * @param {TrackingApiSearchSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    public searchSources(requestParameters: TrackingApiSearchSourcesRequest, options?: RawAxiosRequestConfig) {
        return TrackingApiFp(this.configuration).searchSources(requestParameters.workspaceId, requestParameters.trackingSourceSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Track Click
     * @param {TrackingApiTrackClickRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    public trackClick(requestParameters: TrackingApiTrackClickRequest, options?: RawAxiosRequestConfig) {
        return TrackingApiFp(this.configuration).trackClick(requestParameters.workspaceId, requestParameters.trackingSourceCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Track Event
     * @param {TrackingApiTrackEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    public trackEvent(requestParameters: TrackingApiTrackEventRequest, options?: RawAxiosRequestConfig) {
        return TrackingApiFp(this.configuration).trackEvent(requestParameters.workspaceId, requestParameters.trackingEventCreateRequests, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Track Link
     * @param {TrackingApiTrackLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingApi
     */
    public trackLink(requestParameters: TrackingApiTrackLinkRequest, options?: RawAxiosRequestConfig) {
        return TrackingApiFp(this.configuration).trackLink(requestParameters.workspaceId, requestParameters.trackingLinksCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebAuthApi - axios parameter creator
 * @export
 */
export const WebAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate user account
         * @summary Activate Account
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAccount: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('activateAccount', 'token', token)
            const localVarPath = `/v2/auth/activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current authenticated user details.  This endpoint returns the current user\'s details including their product plans and API key workspace information. It follows DDD principles by delegating the business logic to the application service layer.  Args:     user: The current authenticated user (injected by dependency)     request: The HTTP request object     user_service: The user application service (injected by dependency)  Returns:     UserResponse: The user details response
         * @summary Get User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Password recovery page
         * @summary Password Recovery Page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordRecoveryPage: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/recover-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle password recovery form submission
         * @summary Password Recovery Submit
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordRecoverySubmit: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('passwordRecoverySubmit', 'email', email)
            const localVarPath = `/v2/auth/recover-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (email !== undefined) { 
                localVarFormParams.set('email', email as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registration page
         * @summary Register Page
         * @param {string | null} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPage: async (next?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle registration form submission
         * @summary Register Submit
         * @param {string} name 
         * @param {string} email 
         * @param {string} password 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSubmit: async (name: string, email: string, password: string, next?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('registerSubmit', 'name', name)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('registerSubmit', 'email', email)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('registerSubmit', 'password', password)
            const localVarPath = `/v2/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (name !== undefined) { 
                localVarFormParams.set('name', name as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.set('email', email as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (next !== undefined) { 
                localVarFormParams.set('next', next as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset password page
         * @summary Reset Password Page
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordPage: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('resetPasswordPage', 'token', token)
            const localVarPath = `/v2/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle reset password form submission
         * @summary Reset Password Submit
         * @param {string} token 
         * @param {string} password 
         * @param {string} confirmPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordSubmit: async (token: string, password: string, confirmPassword: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('resetPasswordSubmit', 'token', token)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('resetPasswordSubmit', 'password', password)
            // verify required parameter 'confirmPassword' is not null or undefined
            assertParamExists('resetPasswordSubmit', 'confirmPassword', confirmPassword)
            const localVarPath = `/v2/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (token !== undefined) { 
                localVarFormParams.set('token', token as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (confirmPassword !== undefined) { 
                localVarFormParams.set('confirm_password', confirmPassword as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * SSO login page
         * @summary Sso Login Page
         * @param {string | null} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoLoginPage: async (next?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/oauth/sso`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle SSO login form submission
         * @summary Sso Login Submit
         * @param {string} email 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoLoginSubmit: async (email: string, next?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('ssoLoginSubmit', 'email', email)
            const localVarPath = `/v2/auth/oauth/sso`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (email !== undefined) { 
                localVarFormParams.set('email', email as any);
            }
    
            if (next !== undefined) { 
                localVarFormParams.set('next', next as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebAuthApi - functional programming interface
 * @export
 */
export const WebAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate user account
         * @summary Activate Account
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAccount(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateAccount(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebAuthApi.activateAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current authenticated user details.  This endpoint returns the current user\'s details including their product plans and API key workspace information. It follows DDD principles by delegating the business logic to the application service layer.  Args:     user: The current authenticated user (injected by dependency)     request: The HTTP request object     user_service: The user application service (injected by dependency)  Returns:     UserResponse: The user details response
         * @summary Get User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebAuthApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Password recovery page
         * @summary Password Recovery Page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passwordRecoveryPage(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passwordRecoveryPage(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebAuthApi.passwordRecoveryPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle password recovery form submission
         * @summary Password Recovery Submit
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passwordRecoverySubmit(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passwordRecoverySubmit(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebAuthApi.passwordRecoverySubmit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Registration page
         * @summary Register Page
         * @param {string | null} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerPage(next?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerPage(next, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebAuthApi.registerPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle registration form submission
         * @summary Register Submit
         * @param {string} name 
         * @param {string} email 
         * @param {string} password 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerSubmit(name: string, email: string, password: string, next?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerSubmit(name, email, password, next, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebAuthApi.registerSubmit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset password page
         * @summary Reset Password Page
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPasswordPage(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPasswordPage(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebAuthApi.resetPasswordPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle reset password form submission
         * @summary Reset Password Submit
         * @param {string} token 
         * @param {string} password 
         * @param {string} confirmPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPasswordSubmit(token: string, password: string, confirmPassword: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPasswordSubmit(token, password, confirmPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebAuthApi.resetPasswordSubmit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * SSO login page
         * @summary Sso Login Page
         * @param {string | null} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoLoginPage(next?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoLoginPage(next, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebAuthApi.ssoLoginPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle SSO login form submission
         * @summary Sso Login Submit
         * @param {string} email 
         * @param {string} [next] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssoLoginSubmit(email: string, next?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoLoginSubmit(email, next, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebAuthApi.ssoLoginSubmit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebAuthApi - factory interface
 * @export
 */
export const WebAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebAuthApiFp(configuration)
    return {
        /**
         * Activate user account
         * @summary Activate Account
         * @param {WebAuthApiActivateAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAccount(requestParameters: WebAuthApiActivateAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.activateAccount(requestParameters.token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current authenticated user details.  This endpoint returns the current user\'s details including their product plans and API key workspace information. It follows DDD principles by delegating the business logic to the application service layer.  Args:     user: The current authenticated user (injected by dependency)     request: The HTTP request object     user_service: The user application service (injected by dependency)  Returns:     UserResponse: The user details response
         * @summary Get User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Password recovery page
         * @summary Password Recovery Page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordRecoveryPage(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.passwordRecoveryPage(options).then((request) => request(axios, basePath));
        },
        /**
         * Handle password recovery form submission
         * @summary Password Recovery Submit
         * @param {WebAuthApiPasswordRecoverySubmitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordRecoverySubmit(requestParameters: WebAuthApiPasswordRecoverySubmitRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.passwordRecoverySubmit(requestParameters.email, options).then((request) => request(axios, basePath));
        },
        /**
         * Registration page
         * @summary Register Page
         * @param {WebAuthApiRegisterPageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPage(requestParameters: WebAuthApiRegisterPageRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.registerPage(requestParameters.next, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle registration form submission
         * @summary Register Submit
         * @param {WebAuthApiRegisterSubmitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSubmit(requestParameters: WebAuthApiRegisterSubmitRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.registerSubmit(requestParameters.name, requestParameters.email, requestParameters.password, requestParameters.next, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset password page
         * @summary Reset Password Page
         * @param {WebAuthApiResetPasswordPageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordPage(requestParameters: WebAuthApiResetPasswordPageRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.resetPasswordPage(requestParameters.token, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle reset password form submission
         * @summary Reset Password Submit
         * @param {WebAuthApiResetPasswordSubmitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordSubmit(requestParameters: WebAuthApiResetPasswordSubmitRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.resetPasswordSubmit(requestParameters.token, requestParameters.password, requestParameters.confirmPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * SSO login page
         * @summary Sso Login Page
         * @param {WebAuthApiSsoLoginPageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoLoginPage(requestParameters: WebAuthApiSsoLoginPageRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.ssoLoginPage(requestParameters.next, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle SSO login form submission
         * @summary Sso Login Submit
         * @param {WebAuthApiSsoLoginSubmitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoLoginSubmit(requestParameters: WebAuthApiSsoLoginSubmitRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.ssoLoginSubmit(requestParameters.email, requestParameters.next, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebAuthApi - interface
 * @export
 * @interface WebAuthApi
 */
export interface WebAuthApiInterface {
    /**
     * Activate user account
     * @summary Activate Account
     * @param {WebAuthApiActivateAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApiInterface
     */
    activateAccount(requestParameters: WebAuthApiActivateAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Get current authenticated user details.  This endpoint returns the current user\'s details including their product plans and API key workspace information. It follows DDD principles by delegating the business logic to the application service layer.  Args:     user: The current authenticated user (injected by dependency)     request: The HTTP request object     user_service: The user application service (injected by dependency)  Returns:     UserResponse: The user details response
     * @summary Get User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApiInterface
     */
    getUser(options?: RawAxiosRequestConfig): AxiosPromise<UserResponse>;

    /**
     * Password recovery page
     * @summary Password Recovery Page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApiInterface
     */
    passwordRecoveryPage(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle password recovery form submission
     * @summary Password Recovery Submit
     * @param {WebAuthApiPasswordRecoverySubmitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApiInterface
     */
    passwordRecoverySubmit(requestParameters: WebAuthApiPasswordRecoverySubmitRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Registration page
     * @summary Register Page
     * @param {WebAuthApiRegisterPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApiInterface
     */
    registerPage(requestParameters?: WebAuthApiRegisterPageRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle registration form submission
     * @summary Register Submit
     * @param {WebAuthApiRegisterSubmitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApiInterface
     */
    registerSubmit(requestParameters: WebAuthApiRegisterSubmitRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Reset password page
     * @summary Reset Password Page
     * @param {WebAuthApiResetPasswordPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApiInterface
     */
    resetPasswordPage(requestParameters: WebAuthApiResetPasswordPageRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle reset password form submission
     * @summary Reset Password Submit
     * @param {WebAuthApiResetPasswordSubmitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApiInterface
     */
    resetPasswordSubmit(requestParameters: WebAuthApiResetPasswordSubmitRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * SSO login page
     * @summary Sso Login Page
     * @param {WebAuthApiSsoLoginPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApiInterface
     */
    ssoLoginPage(requestParameters?: WebAuthApiSsoLoginPageRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Handle SSO login form submission
     * @summary Sso Login Submit
     * @param {WebAuthApiSsoLoginSubmitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApiInterface
     */
    ssoLoginSubmit(requestParameters: WebAuthApiSsoLoginSubmitRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

}

/**
 * Request parameters for activateAccount operation in WebAuthApi.
 * @export
 * @interface WebAuthApiActivateAccountRequest
 */
export interface WebAuthApiActivateAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof WebAuthApiActivateAccount
     */
    readonly token: string
}

/**
 * Request parameters for passwordRecoverySubmit operation in WebAuthApi.
 * @export
 * @interface WebAuthApiPasswordRecoverySubmitRequest
 */
export interface WebAuthApiPasswordRecoverySubmitRequest {
    /**
     * 
     * @type {string}
     * @memberof WebAuthApiPasswordRecoverySubmit
     */
    readonly email: string
}

/**
 * Request parameters for registerPage operation in WebAuthApi.
 * @export
 * @interface WebAuthApiRegisterPageRequest
 */
export interface WebAuthApiRegisterPageRequest {
    /**
     * 
     * @type {string}
     * @memberof WebAuthApiRegisterPage
     */
    readonly next?: string | null
}

/**
 * Request parameters for registerSubmit operation in WebAuthApi.
 * @export
 * @interface WebAuthApiRegisterSubmitRequest
 */
export interface WebAuthApiRegisterSubmitRequest {
    /**
     * 
     * @type {string}
     * @memberof WebAuthApiRegisterSubmit
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof WebAuthApiRegisterSubmit
     */
    readonly email: string

    /**
     * 
     * @type {string}
     * @memberof WebAuthApiRegisterSubmit
     */
    readonly password: string

    /**
     * 
     * @type {string}
     * @memberof WebAuthApiRegisterSubmit
     */
    readonly next?: string
}

/**
 * Request parameters for resetPasswordPage operation in WebAuthApi.
 * @export
 * @interface WebAuthApiResetPasswordPageRequest
 */
export interface WebAuthApiResetPasswordPageRequest {
    /**
     * 
     * @type {string}
     * @memberof WebAuthApiResetPasswordPage
     */
    readonly token: string
}

/**
 * Request parameters for resetPasswordSubmit operation in WebAuthApi.
 * @export
 * @interface WebAuthApiResetPasswordSubmitRequest
 */
export interface WebAuthApiResetPasswordSubmitRequest {
    /**
     * 
     * @type {string}
     * @memberof WebAuthApiResetPasswordSubmit
     */
    readonly token: string

    /**
     * 
     * @type {string}
     * @memberof WebAuthApiResetPasswordSubmit
     */
    readonly password: string

    /**
     * 
     * @type {string}
     * @memberof WebAuthApiResetPasswordSubmit
     */
    readonly confirmPassword: string
}

/**
 * Request parameters for ssoLoginPage operation in WebAuthApi.
 * @export
 * @interface WebAuthApiSsoLoginPageRequest
 */
export interface WebAuthApiSsoLoginPageRequest {
    /**
     * 
     * @type {string}
     * @memberof WebAuthApiSsoLoginPage
     */
    readonly next?: string | null
}

/**
 * Request parameters for ssoLoginSubmit operation in WebAuthApi.
 * @export
 * @interface WebAuthApiSsoLoginSubmitRequest
 */
export interface WebAuthApiSsoLoginSubmitRequest {
    /**
     * 
     * @type {string}
     * @memberof WebAuthApiSsoLoginSubmit
     */
    readonly email: string

    /**
     * 
     * @type {string}
     * @memberof WebAuthApiSsoLoginSubmit
     */
    readonly next?: string
}

/**
 * WebAuthApi - object-oriented interface
 * @export
 * @class WebAuthApi
 * @extends {BaseAPI}
 */
export class WebAuthApi extends BaseAPI implements WebAuthApiInterface {
    /**
     * Activate user account
     * @summary Activate Account
     * @param {WebAuthApiActivateAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApi
     */
    public activateAccount(requestParameters: WebAuthApiActivateAccountRequest, options?: RawAxiosRequestConfig) {
        return WebAuthApiFp(this.configuration).activateAccount(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current authenticated user details.  This endpoint returns the current user\'s details including their product plans and API key workspace information. It follows DDD principles by delegating the business logic to the application service layer.  Args:     user: The current authenticated user (injected by dependency)     request: The HTTP request object     user_service: The user application service (injected by dependency)  Returns:     UserResponse: The user details response
     * @summary Get User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApi
     */
    public getUser(options?: RawAxiosRequestConfig) {
        return WebAuthApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Password recovery page
     * @summary Password Recovery Page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApi
     */
    public passwordRecoveryPage(options?: RawAxiosRequestConfig) {
        return WebAuthApiFp(this.configuration).passwordRecoveryPage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle password recovery form submission
     * @summary Password Recovery Submit
     * @param {WebAuthApiPasswordRecoverySubmitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApi
     */
    public passwordRecoverySubmit(requestParameters: WebAuthApiPasswordRecoverySubmitRequest, options?: RawAxiosRequestConfig) {
        return WebAuthApiFp(this.configuration).passwordRecoverySubmit(requestParameters.email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registration page
     * @summary Register Page
     * @param {WebAuthApiRegisterPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApi
     */
    public registerPage(requestParameters: WebAuthApiRegisterPageRequest = {}, options?: RawAxiosRequestConfig) {
        return WebAuthApiFp(this.configuration).registerPage(requestParameters.next, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle registration form submission
     * @summary Register Submit
     * @param {WebAuthApiRegisterSubmitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApi
     */
    public registerSubmit(requestParameters: WebAuthApiRegisterSubmitRequest, options?: RawAxiosRequestConfig) {
        return WebAuthApiFp(this.configuration).registerSubmit(requestParameters.name, requestParameters.email, requestParameters.password, requestParameters.next, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset password page
     * @summary Reset Password Page
     * @param {WebAuthApiResetPasswordPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApi
     */
    public resetPasswordPage(requestParameters: WebAuthApiResetPasswordPageRequest, options?: RawAxiosRequestConfig) {
        return WebAuthApiFp(this.configuration).resetPasswordPage(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle reset password form submission
     * @summary Reset Password Submit
     * @param {WebAuthApiResetPasswordSubmitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApi
     */
    public resetPasswordSubmit(requestParameters: WebAuthApiResetPasswordSubmitRequest, options?: RawAxiosRequestConfig) {
        return WebAuthApiFp(this.configuration).resetPasswordSubmit(requestParameters.token, requestParameters.password, requestParameters.confirmPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * SSO login page
     * @summary Sso Login Page
     * @param {WebAuthApiSsoLoginPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApi
     */
    public ssoLoginPage(requestParameters: WebAuthApiSsoLoginPageRequest = {}, options?: RawAxiosRequestConfig) {
        return WebAuthApiFp(this.configuration).ssoLoginPage(requestParameters.next, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle SSO login form submission
     * @summary Sso Login Submit
     * @param {WebAuthApiSsoLoginSubmitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAuthApi
     */
    public ssoLoginSubmit(requestParameters: WebAuthApiSsoLoginSubmitRequest, options?: RawAxiosRequestConfig) {
        return WebAuthApiFp(this.configuration).ssoLoginSubmit(requestParameters.email, requestParameters.next, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WordPressApi - axios parameter creator
 * @export
 */
export const WordPressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Wordpress Post Categories
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostCategories: async (integrationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('getWordpressPostCategories', 'integrationId', integrationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWordpressPostCategories', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/wordpress/{integration_id}/categories`
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Wordpress Post Tags
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostTags: async (integrationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('getWordpressPostTags', 'integrationId', integrationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWordpressPostTags', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/wordpress/{integration_id}/tags`
                .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Wordpress Sites
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressSites: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWordpressSites', 'workspaceId', workspaceId)
            const localVarPath = `/v2/integrations/wordpress/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspace_id'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WordPressApi - functional programming interface
 * @export
 */
export const WordPressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WordPressApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Wordpress Post Categories
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWordpressPostCategories(integrationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WordPressCategoryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWordpressPostCategories(integrationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WordPressApi.getWordpressPostCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Wordpress Post Tags
         * @param {string} integrationId 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWordpressPostTags(integrationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WordPressTagsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWordpressPostTags(integrationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WordPressApi.getWordpressPostTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Wordpress Sites
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWordpressSites(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WordPressSiteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWordpressSites(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WordPressApi.getWordpressSites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WordPressApi - factory interface
 * @export
 */
export const WordPressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WordPressApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Wordpress Post Categories
         * @param {WordPressApiGetWordpressPostCategoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostCategories(requestParameters: WordPressApiGetWordpressPostCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressCategoryResponse>> {
            return localVarFp.getWordpressPostCategories(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Wordpress Post Tags
         * @param {WordPressApiGetWordpressPostTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressPostTags(requestParameters: WordPressApiGetWordpressPostTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressTagsResponse>> {
            return localVarFp.getWordpressPostTags(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Wordpress Sites
         * @param {WordPressApiGetWordpressSitesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWordpressSites(requestParameters: WordPressApiGetWordpressSitesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressSiteResponse>> {
            return localVarFp.getWordpressSites(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WordPressApi - interface
 * @export
 * @interface WordPressApi
 */
export interface WordPressApiInterface {
    /**
     * 
     * @summary Get Wordpress Post Categories
     * @param {WordPressApiGetWordpressPostCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApiInterface
     */
    getWordpressPostCategories(requestParameters: WordPressApiGetWordpressPostCategoriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressCategoryResponse>>;

    /**
     * 
     * @summary Get Wordpress Post Tags
     * @param {WordPressApiGetWordpressPostTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApiInterface
     */
    getWordpressPostTags(requestParameters: WordPressApiGetWordpressPostTagsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressTagsResponse>>;

    /**
     * 
     * @summary Get Wordpress Sites
     * @param {WordPressApiGetWordpressSitesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApiInterface
     */
    getWordpressSites(requestParameters: WordPressApiGetWordpressSitesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WordPressSiteResponse>>;

}

/**
 * Request parameters for getWordpressPostCategories operation in WordPressApi.
 * @export
 * @interface WordPressApiGetWordpressPostCategoriesRequest
 */
export interface WordPressApiGetWordpressPostCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof WordPressApiGetWordpressPostCategories
     */
    readonly integrationId: string

    /**
     * 
     * @type {string}
     * @memberof WordPressApiGetWordpressPostCategories
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getWordpressPostTags operation in WordPressApi.
 * @export
 * @interface WordPressApiGetWordpressPostTagsRequest
 */
export interface WordPressApiGetWordpressPostTagsRequest {
    /**
     * 
     * @type {string}
     * @memberof WordPressApiGetWordpressPostTags
     */
    readonly integrationId: string

    /**
     * 
     * @type {string}
     * @memberof WordPressApiGetWordpressPostTags
     */
    readonly workspaceId: string
}

/**
 * Request parameters for getWordpressSites operation in WordPressApi.
 * @export
 * @interface WordPressApiGetWordpressSitesRequest
 */
export interface WordPressApiGetWordpressSitesRequest {
    /**
     * 
     * @type {string}
     * @memberof WordPressApiGetWordpressSites
     */
    readonly workspaceId: string
}

/**
 * WordPressApi - object-oriented interface
 * @export
 * @class WordPressApi
 * @extends {BaseAPI}
 */
export class WordPressApi extends BaseAPI implements WordPressApiInterface {
    /**
     * 
     * @summary Get Wordpress Post Categories
     * @param {WordPressApiGetWordpressPostCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApi
     */
    public getWordpressPostCategories(requestParameters: WordPressApiGetWordpressPostCategoriesRequest, options?: RawAxiosRequestConfig) {
        return WordPressApiFp(this.configuration).getWordpressPostCategories(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Wordpress Post Tags
     * @param {WordPressApiGetWordpressPostTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApi
     */
    public getWordpressPostTags(requestParameters: WordPressApiGetWordpressPostTagsRequest, options?: RawAxiosRequestConfig) {
        return WordPressApiFp(this.configuration).getWordpressPostTags(requestParameters.integrationId, requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Wordpress Sites
     * @param {WordPressApiGetWordpressSitesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApi
     */
    public getWordpressSites(requestParameters: WordPressApiGetWordpressSitesRequest, options?: RawAxiosRequestConfig) {
        return WordPressApiFp(this.configuration).getWordpressSites(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkspacesApi - axios parameter creator
 * @export
 */
export const WorkspacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Workspace User
         * @param {string} workspaceId 
         * @param {WorkspaceUserCreateRequest} workspaceUserCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspaceUser: async (workspaceId: string, workspaceUserCreateRequest: WorkspaceUserCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addWorkspaceUser', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceUserCreateRequest' is not null or undefined
            assertParamExists('addWorkspaceUser', 'workspaceUserCreateRequest', workspaceUserCreateRequest)
            const localVarPath = `/v2/workspaces/{workspace_id}/add-member`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUserCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Workspace
         * @param {WorkspaceCreateRequest} workspaceCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace: async (workspaceCreateRequest: WorkspaceCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceCreateRequest' is not null or undefined
            assertParamExists('createWorkspace', 'workspaceCreateRequest', workspaceCreateRequest)
            const localVarPath = `/v2/workspaces/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Workspace
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/v2/workspaces/{workspace_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Workspace User
         * @param {string} workspaceId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceUser: async (workspaceId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspaceUser', 'workspaceId', workspaceId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteWorkspaceUser', 'userId', userId)
            const localVarPath = `/v2/workspaces/{workspace_id}/{user_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Workspace
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/v2/workspaces/{workspace_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search My Workspaces
         * @param {WorkspaceSearchRequest} workspaceSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMyWorkspaces: async (workspaceSearchRequest: WorkspaceSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceSearchRequest' is not null or undefined
            assertParamExists('searchMyWorkspaces', 'workspaceSearchRequest', workspaceSearchRequest)
            const localVarPath = `/v2/workspaces/me/my_workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Workspace Users
         * @param {string} workspaceId 
         * @param {WorkspaceUsersSearchRequest} workspaceUsersSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorkspaceUsers: async (workspaceId: string, workspaceUsersSearchRequest: WorkspaceUsersSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchWorkspaceUsers', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceUsersSearchRequest' is not null or undefined
            assertParamExists('searchWorkspaceUsers', 'workspaceUsersSearchRequest', workspaceUsersSearchRequest)
            const localVarPath = `/v2/workspaces/{workspace_id}/users`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUsersSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Workspace
         * @param {string} workspaceId 
         * @param {WorkspaceUpdateRequest} workspaceUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace: async (workspaceId: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceUpdateRequest' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceUpdateRequest', workspaceUpdateRequest)
            const localVarPath = `/v2/workspaces/{workspace_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Workspace User
         * @param {string} workspaceId 
         * @param {string} userId 
         * @param {WorkspaceUserUpdateRequest} workspaceUserUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceUser: async (workspaceId: string, userId: string, workspaceUserUpdateRequest: WorkspaceUserUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspaceUser', 'workspaceId', workspaceId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateWorkspaceUser', 'userId', userId)
            // verify required parameter 'workspaceUserUpdateRequest' is not null or undefined
            assertParamExists('updateWorkspaceUser', 'workspaceUserUpdateRequest', workspaceUserUpdateRequest)
            const localVarPath = `/v2/workspaces/{workspace_id}/{user_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUserUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspacesApi - functional programming interface
 * @export
 */
export const WorkspacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspacesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Workspace User
         * @param {string} workspaceId 
         * @param {WorkspaceUserCreateRequest} workspaceUserCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addWorkspaceUser(workspaceId: string, workspaceUserCreateRequest: WorkspaceUserCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addWorkspaceUser(workspaceId, workspaceUserCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.addWorkspaceUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Workspace
         * @param {WorkspaceCreateRequest} workspaceCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspace(workspaceCreateRequest: WorkspaceCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspace(workspaceCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.createWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Workspace
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspace(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspace(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.deleteWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Workspace User
         * @param {string} workspaceId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceUser(workspaceId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceUser(workspaceId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.deleteWorkspaceUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Workspace
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspace(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspace(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.getWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search My Workspaces
         * @param {WorkspaceSearchRequest} workspaceSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMyWorkspaces(workspaceSearchRequest: WorkspaceSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceRole>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMyWorkspaces(workspaceSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.searchMyWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Workspace Users
         * @param {string} workspaceId 
         * @param {WorkspaceUsersSearchRequest} workspaceUsersSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchWorkspaceUsers(workspaceId: string, workspaceUsersSearchRequest: WorkspaceUsersSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceUserResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchWorkspaceUsers(workspaceId, workspaceUsersSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.searchWorkspaceUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Workspace
         * @param {string} workspaceId 
         * @param {WorkspaceUpdateRequest} workspaceUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspace(workspaceId: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspace(workspaceId, workspaceUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.updateWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Workspace User
         * @param {string} workspaceId 
         * @param {string} userId 
         * @param {WorkspaceUserUpdateRequest} workspaceUserUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspaceUser(workspaceId: string, userId: string, workspaceUserUpdateRequest: WorkspaceUserUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceUser(workspaceId, userId, workspaceUserUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.updateWorkspaceUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspacesApi - factory interface
 * @export
 */
export const WorkspacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspacesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Workspace User
         * @param {WorkspacesApiAddWorkspaceUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspaceUser(requestParameters: WorkspacesApiAddWorkspaceUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.addWorkspaceUser(requestParameters.workspaceId, requestParameters.workspaceUserCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Workspace
         * @param {WorkspacesApiCreateWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(requestParameters: WorkspacesApiCreateWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceResponse> {
            return localVarFp.createWorkspace(requestParameters.workspaceCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Workspace
         * @param {WorkspacesApiDeleteWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(requestParameters: WorkspacesApiDeleteWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteWorkspace(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Workspace User
         * @param {WorkspacesApiDeleteWorkspaceUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceUser(requestParameters: WorkspacesApiDeleteWorkspaceUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteWorkspaceUser(requestParameters.workspaceId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Workspace
         * @param {WorkspacesApiGetWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(requestParameters: WorkspacesApiGetWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceResponse> {
            return localVarFp.getWorkspace(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search My Workspaces
         * @param {WorkspacesApiSearchMyWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMyWorkspaces(requestParameters: WorkspacesApiSearchMyWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceRole>> {
            return localVarFp.searchMyWorkspaces(requestParameters.workspaceSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Workspace Users
         * @param {WorkspacesApiSearchWorkspaceUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchWorkspaceUsers(requestParameters: WorkspacesApiSearchWorkspaceUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceUserResponse>> {
            return localVarFp.searchWorkspaceUsers(requestParameters.workspaceId, requestParameters.workspaceUsersSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Workspace
         * @param {WorkspacesApiUpdateWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace(requestParameters: WorkspacesApiUpdateWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.updateWorkspace(requestParameters.workspaceId, requestParameters.workspaceUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Workspace User
         * @param {WorkspacesApiUpdateWorkspaceUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceUser(requestParameters: WorkspacesApiUpdateWorkspaceUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.updateWorkspaceUser(requestParameters.workspaceId, requestParameters.userId, requestParameters.workspaceUserUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspacesApi - interface
 * @export
 * @interface WorkspacesApi
 */
export interface WorkspacesApiInterface {
    /**
     * 
     * @summary Add Workspace User
     * @param {WorkspacesApiAddWorkspaceUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    addWorkspaceUser(requestParameters: WorkspacesApiAddWorkspaceUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Create Workspace
     * @param {WorkspacesApiCreateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    createWorkspace(requestParameters: WorkspacesApiCreateWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceResponse>;

    /**
     * 
     * @summary Delete Workspace
     * @param {WorkspacesApiDeleteWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    deleteWorkspace(requestParameters: WorkspacesApiDeleteWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Delete Workspace User
     * @param {WorkspacesApiDeleteWorkspaceUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    deleteWorkspaceUser(requestParameters: WorkspacesApiDeleteWorkspaceUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Get Workspace
     * @param {WorkspacesApiGetWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    getWorkspace(requestParameters: WorkspacesApiGetWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceResponse>;

    /**
     * 
     * @summary Search My Workspaces
     * @param {WorkspacesApiSearchMyWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    searchMyWorkspaces(requestParameters: WorkspacesApiSearchMyWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceRole>>;

    /**
     * 
     * @summary Search Workspace Users
     * @param {WorkspacesApiSearchWorkspaceUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    searchWorkspaceUsers(requestParameters: WorkspacesApiSearchWorkspaceUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceUserResponse>>;

    /**
     * 
     * @summary Update Workspace
     * @param {WorkspacesApiUpdateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    updateWorkspace(requestParameters: WorkspacesApiUpdateWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * 
     * @summary Update Workspace User
     * @param {WorkspacesApiUpdateWorkspaceUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    updateWorkspaceUser(requestParameters: WorkspacesApiUpdateWorkspaceUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

}

/**
 * Request parameters for addWorkspaceUser operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiAddWorkspaceUserRequest
 */
export interface WorkspacesApiAddWorkspaceUserRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiAddWorkspaceUser
     */
    readonly workspaceId: string

    /**
     * 
     * @type {WorkspaceUserCreateRequest}
     * @memberof WorkspacesApiAddWorkspaceUser
     */
    readonly workspaceUserCreateRequest: WorkspaceUserCreateRequest
}

/**
 * Request parameters for createWorkspace operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiCreateWorkspaceRequest
 */
export interface WorkspacesApiCreateWorkspaceRequest {
    /**
     * 
     * @type {WorkspaceCreateRequest}
     * @memberof WorkspacesApiCreateWorkspace
     */
    readonly workspaceCreateRequest: WorkspaceCreateRequest
}

/**
 * Request parameters for deleteWorkspace operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiDeleteWorkspaceRequest
 */
export interface WorkspacesApiDeleteWorkspaceRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiDeleteWorkspace
     */
    readonly workspaceId: string
}

/**
 * Request parameters for deleteWorkspaceUser operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiDeleteWorkspaceUserRequest
 */
export interface WorkspacesApiDeleteWorkspaceUserRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiDeleteWorkspaceUser
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiDeleteWorkspaceUser
     */
    readonly userId: string
}

/**
 * Request parameters for getWorkspace operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiGetWorkspaceRequest
 */
export interface WorkspacesApiGetWorkspaceRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiGetWorkspace
     */
    readonly workspaceId: string
}

/**
 * Request parameters for searchMyWorkspaces operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiSearchMyWorkspacesRequest
 */
export interface WorkspacesApiSearchMyWorkspacesRequest {
    /**
     * 
     * @type {WorkspaceSearchRequest}
     * @memberof WorkspacesApiSearchMyWorkspaces
     */
    readonly workspaceSearchRequest: WorkspaceSearchRequest
}

/**
 * Request parameters for searchWorkspaceUsers operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiSearchWorkspaceUsersRequest
 */
export interface WorkspacesApiSearchWorkspaceUsersRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiSearchWorkspaceUsers
     */
    readonly workspaceId: string

    /**
     * 
     * @type {WorkspaceUsersSearchRequest}
     * @memberof WorkspacesApiSearchWorkspaceUsers
     */
    readonly workspaceUsersSearchRequest: WorkspaceUsersSearchRequest
}

/**
 * Request parameters for updateWorkspace operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiUpdateWorkspaceRequest
 */
export interface WorkspacesApiUpdateWorkspaceRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiUpdateWorkspace
     */
    readonly workspaceId: string

    /**
     * 
     * @type {WorkspaceUpdateRequest}
     * @memberof WorkspacesApiUpdateWorkspace
     */
    readonly workspaceUpdateRequest: WorkspaceUpdateRequest
}

/**
 * Request parameters for updateWorkspaceUser operation in WorkspacesApi.
 * @export
 * @interface WorkspacesApiUpdateWorkspaceUserRequest
 */
export interface WorkspacesApiUpdateWorkspaceUserRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiUpdateWorkspaceUser
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof WorkspacesApiUpdateWorkspaceUser
     */
    readonly userId: string

    /**
     * 
     * @type {WorkspaceUserUpdateRequest}
     * @memberof WorkspacesApiUpdateWorkspaceUser
     */
    readonly workspaceUserUpdateRequest: WorkspaceUserUpdateRequest
}

/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class WorkspacesApi
 * @extends {BaseAPI}
 */
export class WorkspacesApi extends BaseAPI implements WorkspacesApiInterface {
    /**
     * 
     * @summary Add Workspace User
     * @param {WorkspacesApiAddWorkspaceUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public addWorkspaceUser(requestParameters: WorkspacesApiAddWorkspaceUserRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).addWorkspaceUser(requestParameters.workspaceId, requestParameters.workspaceUserCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Workspace
     * @param {WorkspacesApiCreateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public createWorkspace(requestParameters: WorkspacesApiCreateWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).createWorkspace(requestParameters.workspaceCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Workspace
     * @param {WorkspacesApiDeleteWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public deleteWorkspace(requestParameters: WorkspacesApiDeleteWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).deleteWorkspace(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Workspace User
     * @param {WorkspacesApiDeleteWorkspaceUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public deleteWorkspaceUser(requestParameters: WorkspacesApiDeleteWorkspaceUserRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).deleteWorkspaceUser(requestParameters.workspaceId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Workspace
     * @param {WorkspacesApiGetWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public getWorkspace(requestParameters: WorkspacesApiGetWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).getWorkspace(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search My Workspaces
     * @param {WorkspacesApiSearchMyWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public searchMyWorkspaces(requestParameters: WorkspacesApiSearchMyWorkspacesRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).searchMyWorkspaces(requestParameters.workspaceSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Workspace Users
     * @param {WorkspacesApiSearchWorkspaceUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public searchWorkspaceUsers(requestParameters: WorkspacesApiSearchWorkspaceUsersRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).searchWorkspaceUsers(requestParameters.workspaceId, requestParameters.workspaceUsersSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Workspace
     * @param {WorkspacesApiUpdateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public updateWorkspace(requestParameters: WorkspacesApiUpdateWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).updateWorkspace(requestParameters.workspaceId, requestParameters.workspaceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Workspace User
     * @param {WorkspacesApiUpdateWorkspaceUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public updateWorkspaceUser(requestParameters: WorkspacesApiUpdateWorkspaceUserRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).updateWorkspaceUser(requestParameters.workspaceId, requestParameters.userId, requestParameters.workspaceUserUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkspacesSSOApi - axios parameter creator
 * @export
 */
export const WorkspacesSSOApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create SSO settings for a workspace. Admin endpoint - requires workspace admin permissions.
         * @summary Create Workspace Sso Settings
         * @param {string} workspaceId 
         * @param {WorkspaceSSOCreateRequest} workspaceSSOCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspaceSsoSettings: async (workspaceId: string, workspaceSSOCreateRequest: WorkspaceSSOCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createWorkspaceSsoSettings', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceSSOCreateRequest' is not null or undefined
            assertParamExists('createWorkspaceSsoSettings', 'workspaceSSOCreateRequest', workspaceSSOCreateRequest)
            const localVarPath = `/v2/workspaces/{workspace_id}/sso`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceSSOCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete SSO settings for a workspace and provider. Admin endpoint - requires workspace admin permissions.
         * @summary Delete Workspace Sso Settings
         * @param {string} workspaceId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceSsoSettings: async (workspaceId: string, provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspaceSsoSettings', 'workspaceId', workspaceId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('deleteWorkspaceSsoSettings', 'provider', provider)
            const localVarPath = `/v2/workspaces/{workspace_id}/sso/{provider}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SSO settings for a specific workspace and provider. Admin endpoint - requires workspace admin permissions.
         * @summary Get Workspace Sso Settings
         * @param {string} workspaceId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSsoSettings: async (workspaceId: string, provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceSsoSettings', 'workspaceId', workspaceId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('getWorkspaceSsoSettings', 'provider', provider)
            const localVarPath = `/v2/workspaces/{workspace_id}/sso/{provider}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all SSO settings for a workspace. Admin endpoint - requires workspace admin permissions.
         * @summary List Workspace Sso Settings
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceSsoSettings: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listWorkspaceSsoSettings', 'workspaceId', workspaceId)
            const localVarPath = `/v2/workspaces/{workspace_id}/sso`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update SSO settings for a workspace and provider. Admin endpoint - requires workspace admin permissions.
         * @summary Update Workspace Sso Settings
         * @param {string} workspaceId 
         * @param {string} provider 
         * @param {WorkspaceSSOUpdateRequest} workspaceSSOUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceSsoSettings: async (workspaceId: string, provider: string, workspaceSSOUpdateRequest: WorkspaceSSOUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspaceSsoSettings', 'workspaceId', workspaceId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('updateWorkspaceSsoSettings', 'provider', provider)
            // verify required parameter 'workspaceSSOUpdateRequest' is not null or undefined
            assertParamExists('updateWorkspaceSsoSettings', 'workspaceSSOUpdateRequest', workspaceSSOUpdateRequest)
            const localVarPath = `/v2/workspaces/{workspace_id}/sso/{provider}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceSSOUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspacesSSOApi - functional programming interface
 * @export
 */
export const WorkspacesSSOApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspacesSSOApiAxiosParamCreator(configuration)
    return {
        /**
         * Create SSO settings for a workspace. Admin endpoint - requires workspace admin permissions.
         * @summary Create Workspace Sso Settings
         * @param {string} workspaceId 
         * @param {WorkspaceSSOCreateRequest} workspaceSSOCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspaceSsoSettings(workspaceId: string, workspaceSSOCreateRequest: WorkspaceSSOCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSSOResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspaceSsoSettings(workspaceId, workspaceSSOCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesSSOApi.createWorkspaceSsoSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete SSO settings for a workspace and provider. Admin endpoint - requires workspace admin permissions.
         * @summary Delete Workspace Sso Settings
         * @param {string} workspaceId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceSsoSettings(workspaceId: string, provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceSsoSettings(workspaceId, provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesSSOApi.deleteWorkspaceSsoSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SSO settings for a specific workspace and provider. Admin endpoint - requires workspace admin permissions.
         * @summary Get Workspace Sso Settings
         * @param {string} workspaceId 
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceSsoSettings(workspaceId: string, provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSSOResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceSsoSettings(workspaceId, provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesSSOApi.getWorkspaceSsoSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all SSO settings for a workspace. Admin endpoint - requires workspace admin permissions.
         * @summary List Workspace Sso Settings
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkspaceSsoSettings(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSSOListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkspaceSsoSettings(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesSSOApi.listWorkspaceSsoSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update SSO settings for a workspace and provider. Admin endpoint - requires workspace admin permissions.
         * @summary Update Workspace Sso Settings
         * @param {string} workspaceId 
         * @param {string} provider 
         * @param {WorkspaceSSOUpdateRequest} workspaceSSOUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspaceSsoSettings(workspaceId: string, provider: string, workspaceSSOUpdateRequest: WorkspaceSSOUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSSOResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceSsoSettings(workspaceId, provider, workspaceSSOUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesSSOApi.updateWorkspaceSsoSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspacesSSOApi - factory interface
 * @export
 */
export const WorkspacesSSOApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspacesSSOApiFp(configuration)
    return {
        /**
         * Create SSO settings for a workspace. Admin endpoint - requires workspace admin permissions.
         * @summary Create Workspace Sso Settings
         * @param {WorkspacesSSOApiCreateWorkspaceSsoSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspaceSsoSettings(requestParameters: WorkspacesSSOApiCreateWorkspaceSsoSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSSOResponse> {
            return localVarFp.createWorkspaceSsoSettings(requestParameters.workspaceId, requestParameters.workspaceSSOCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete SSO settings for a workspace and provider. Admin endpoint - requires workspace admin permissions.
         * @summary Delete Workspace Sso Settings
         * @param {WorkspacesSSOApiDeleteWorkspaceSsoSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceSsoSettings(requestParameters: WorkspacesSSOApiDeleteWorkspaceSsoSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteWorkspaceSsoSettings(requestParameters.workspaceId, requestParameters.provider, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SSO settings for a specific workspace and provider. Admin endpoint - requires workspace admin permissions.
         * @summary Get Workspace Sso Settings
         * @param {WorkspacesSSOApiGetWorkspaceSsoSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSsoSettings(requestParameters: WorkspacesSSOApiGetWorkspaceSsoSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSSOResponse> {
            return localVarFp.getWorkspaceSsoSettings(requestParameters.workspaceId, requestParameters.provider, options).then((request) => request(axios, basePath));
        },
        /**
         * List all SSO settings for a workspace. Admin endpoint - requires workspace admin permissions.
         * @summary List Workspace Sso Settings
         * @param {WorkspacesSSOApiListWorkspaceSsoSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceSsoSettings(requestParameters: WorkspacesSSOApiListWorkspaceSsoSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSSOListResponse> {
            return localVarFp.listWorkspaceSsoSettings(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update SSO settings for a workspace and provider. Admin endpoint - requires workspace admin permissions.
         * @summary Update Workspace Sso Settings
         * @param {WorkspacesSSOApiUpdateWorkspaceSsoSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceSsoSettings(requestParameters: WorkspacesSSOApiUpdateWorkspaceSsoSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSSOResponse> {
            return localVarFp.updateWorkspaceSsoSettings(requestParameters.workspaceId, requestParameters.provider, requestParameters.workspaceSSOUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspacesSSOApi - interface
 * @export
 * @interface WorkspacesSSOApi
 */
export interface WorkspacesSSOApiInterface {
    /**
     * Create SSO settings for a workspace. Admin endpoint - requires workspace admin permissions.
     * @summary Create Workspace Sso Settings
     * @param {WorkspacesSSOApiCreateWorkspaceSsoSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSOApiInterface
     */
    createWorkspaceSsoSettings(requestParameters: WorkspacesSSOApiCreateWorkspaceSsoSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSSOResponse>;

    /**
     * Delete SSO settings for a workspace and provider. Admin endpoint - requires workspace admin permissions.
     * @summary Delete Workspace Sso Settings
     * @param {WorkspacesSSOApiDeleteWorkspaceSsoSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSOApiInterface
     */
    deleteWorkspaceSsoSettings(requestParameters: WorkspacesSSOApiDeleteWorkspaceSsoSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * Get SSO settings for a specific workspace and provider. Admin endpoint - requires workspace admin permissions.
     * @summary Get Workspace Sso Settings
     * @param {WorkspacesSSOApiGetWorkspaceSsoSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSOApiInterface
     */
    getWorkspaceSsoSettings(requestParameters: WorkspacesSSOApiGetWorkspaceSsoSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSSOResponse>;

    /**
     * List all SSO settings for a workspace. Admin endpoint - requires workspace admin permissions.
     * @summary List Workspace Sso Settings
     * @param {WorkspacesSSOApiListWorkspaceSsoSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSOApiInterface
     */
    listWorkspaceSsoSettings(requestParameters: WorkspacesSSOApiListWorkspaceSsoSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSSOListResponse>;

    /**
     * Update SSO settings for a workspace and provider. Admin endpoint - requires workspace admin permissions.
     * @summary Update Workspace Sso Settings
     * @param {WorkspacesSSOApiUpdateWorkspaceSsoSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSOApiInterface
     */
    updateWorkspaceSsoSettings(requestParameters: WorkspacesSSOApiUpdateWorkspaceSsoSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSSOResponse>;

}

/**
 * Request parameters for createWorkspaceSsoSettings operation in WorkspacesSSOApi.
 * @export
 * @interface WorkspacesSSOApiCreateWorkspaceSsoSettingsRequest
 */
export interface WorkspacesSSOApiCreateWorkspaceSsoSettingsRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesSSOApiCreateWorkspaceSsoSettings
     */
    readonly workspaceId: string

    /**
     * 
     * @type {WorkspaceSSOCreateRequest}
     * @memberof WorkspacesSSOApiCreateWorkspaceSsoSettings
     */
    readonly workspaceSSOCreateRequest: WorkspaceSSOCreateRequest
}

/**
 * Request parameters for deleteWorkspaceSsoSettings operation in WorkspacesSSOApi.
 * @export
 * @interface WorkspacesSSOApiDeleteWorkspaceSsoSettingsRequest
 */
export interface WorkspacesSSOApiDeleteWorkspaceSsoSettingsRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesSSOApiDeleteWorkspaceSsoSettings
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof WorkspacesSSOApiDeleteWorkspaceSsoSettings
     */
    readonly provider: string
}

/**
 * Request parameters for getWorkspaceSsoSettings operation in WorkspacesSSOApi.
 * @export
 * @interface WorkspacesSSOApiGetWorkspaceSsoSettingsRequest
 */
export interface WorkspacesSSOApiGetWorkspaceSsoSettingsRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesSSOApiGetWorkspaceSsoSettings
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof WorkspacesSSOApiGetWorkspaceSsoSettings
     */
    readonly provider: string
}

/**
 * Request parameters for listWorkspaceSsoSettings operation in WorkspacesSSOApi.
 * @export
 * @interface WorkspacesSSOApiListWorkspaceSsoSettingsRequest
 */
export interface WorkspacesSSOApiListWorkspaceSsoSettingsRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesSSOApiListWorkspaceSsoSettings
     */
    readonly workspaceId: string
}

/**
 * Request parameters for updateWorkspaceSsoSettings operation in WorkspacesSSOApi.
 * @export
 * @interface WorkspacesSSOApiUpdateWorkspaceSsoSettingsRequest
 */
export interface WorkspacesSSOApiUpdateWorkspaceSsoSettingsRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesSSOApiUpdateWorkspaceSsoSettings
     */
    readonly workspaceId: string

    /**
     * 
     * @type {string}
     * @memberof WorkspacesSSOApiUpdateWorkspaceSsoSettings
     */
    readonly provider: string

    /**
     * 
     * @type {WorkspaceSSOUpdateRequest}
     * @memberof WorkspacesSSOApiUpdateWorkspaceSsoSettings
     */
    readonly workspaceSSOUpdateRequest: WorkspaceSSOUpdateRequest
}

/**
 * WorkspacesSSOApi - object-oriented interface
 * @export
 * @class WorkspacesSSOApi
 * @extends {BaseAPI}
 */
export class WorkspacesSSOApi extends BaseAPI implements WorkspacesSSOApiInterface {
    /**
     * Create SSO settings for a workspace. Admin endpoint - requires workspace admin permissions.
     * @summary Create Workspace Sso Settings
     * @param {WorkspacesSSOApiCreateWorkspaceSsoSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSOApi
     */
    public createWorkspaceSsoSettings(requestParameters: WorkspacesSSOApiCreateWorkspaceSsoSettingsRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesSSOApiFp(this.configuration).createWorkspaceSsoSettings(requestParameters.workspaceId, requestParameters.workspaceSSOCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete SSO settings for a workspace and provider. Admin endpoint - requires workspace admin permissions.
     * @summary Delete Workspace Sso Settings
     * @param {WorkspacesSSOApiDeleteWorkspaceSsoSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSOApi
     */
    public deleteWorkspaceSsoSettings(requestParameters: WorkspacesSSOApiDeleteWorkspaceSsoSettingsRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesSSOApiFp(this.configuration).deleteWorkspaceSsoSettings(requestParameters.workspaceId, requestParameters.provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SSO settings for a specific workspace and provider. Admin endpoint - requires workspace admin permissions.
     * @summary Get Workspace Sso Settings
     * @param {WorkspacesSSOApiGetWorkspaceSsoSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSOApi
     */
    public getWorkspaceSsoSettings(requestParameters: WorkspacesSSOApiGetWorkspaceSsoSettingsRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesSSOApiFp(this.configuration).getWorkspaceSsoSettings(requestParameters.workspaceId, requestParameters.provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all SSO settings for a workspace. Admin endpoint - requires workspace admin permissions.
     * @summary List Workspace Sso Settings
     * @param {WorkspacesSSOApiListWorkspaceSsoSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSOApi
     */
    public listWorkspaceSsoSettings(requestParameters: WorkspacesSSOApiListWorkspaceSsoSettingsRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesSSOApiFp(this.configuration).listWorkspaceSsoSettings(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update SSO settings for a workspace and provider. Admin endpoint - requires workspace admin permissions.
     * @summary Update Workspace Sso Settings
     * @param {WorkspacesSSOApiUpdateWorkspaceSsoSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSOApi
     */
    public updateWorkspaceSsoSettings(requestParameters: WorkspacesSSOApiUpdateWorkspaceSsoSettingsRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesSSOApiFp(this.configuration).updateWorkspaceSsoSettings(requestParameters.workspaceId, requestParameters.provider, requestParameters.workspaceSSOUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkspacesSSODomainVerificationApi - axios parameter creator
 * @export
 */
export const WorkspacesSSODomainVerificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new domain verification record. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
         * @summary Create Domain Verification
         * @param {string} workspaceId 
         * @param {WorkspaceSSODomainVerificationCreateRequest} workspaceSSODomainVerificationCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainVerification: async (workspaceId: string, workspaceSSODomainVerificationCreateRequest: WorkspaceSSODomainVerificationCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createDomainVerification', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceSSODomainVerificationCreateRequest' is not null or undefined
            assertParamExists('createDomainVerification', 'workspaceSSODomainVerificationCreateRequest', workspaceSSODomainVerificationCreateRequest)
            const localVarPath = `/v2/workspaces/{workspace_id}/sso/domain-verification`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceSSODomainVerificationCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a domain verification record. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
         * @summary Delete Domain Verification
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainVerification: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteDomainVerification', 'workspaceId', workspaceId)
            const localVarPath = `/v2/workspaces/{workspace_id}/sso/domain-verification`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all domain verifications for a workspace. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
         * @summary List Domain Verifications
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomainVerifications: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listDomainVerifications', 'workspaceId', workspaceId)
            const localVarPath = `/v2/workspaces/{workspace_id}/sso/domain-verification`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify a domain by checking DNS TXT records. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
         * @summary Verify Domain
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyDomain: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('verifyDomain', 'workspaceId', workspaceId)
            const localVarPath = `/v2/workspaces/{workspace_id}/sso/domain-verification/verify`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Api-Key", configuration)

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspacesSSODomainVerificationApi - functional programming interface
 * @export
 */
export const WorkspacesSSODomainVerificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspacesSSODomainVerificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new domain verification record. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
         * @summary Create Domain Verification
         * @param {string} workspaceId 
         * @param {WorkspaceSSODomainVerificationCreateRequest} workspaceSSODomainVerificationCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomainVerification(workspaceId: string, workspaceSSODomainVerificationCreateRequest: WorkspaceSSODomainVerificationCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSSODomainVerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDomainVerification(workspaceId, workspaceSSODomainVerificationCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesSSODomainVerificationApi.createDomainVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a domain verification record. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
         * @summary Delete Domain Verification
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomainVerification(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Completed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomainVerification(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesSSODomainVerificationApi.deleteDomainVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all domain verifications for a workspace. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
         * @summary List Domain Verifications
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDomainVerifications(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceSSODomainVerificationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDomainVerifications(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesSSODomainVerificationApi.listDomainVerifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify a domain by checking DNS TXT records. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
         * @summary Verify Domain
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyDomain(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSSODomainVerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyDomain(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesSSODomainVerificationApi.verifyDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspacesSSODomainVerificationApi - factory interface
 * @export
 */
export const WorkspacesSSODomainVerificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspacesSSODomainVerificationApiFp(configuration)
    return {
        /**
         * Create a new domain verification record. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
         * @summary Create Domain Verification
         * @param {WorkspacesSSODomainVerificationApiCreateDomainVerificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainVerification(requestParameters: WorkspacesSSODomainVerificationApiCreateDomainVerificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSSODomainVerificationResponse> {
            return localVarFp.createDomainVerification(requestParameters.workspaceId, requestParameters.workspaceSSODomainVerificationCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a domain verification record. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
         * @summary Delete Domain Verification
         * @param {WorkspacesSSODomainVerificationApiDeleteDomainVerificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainVerification(requestParameters: WorkspacesSSODomainVerificationApiDeleteDomainVerificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed> {
            return localVarFp.deleteDomainVerification(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all domain verifications for a workspace. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
         * @summary List Domain Verifications
         * @param {WorkspacesSSODomainVerificationApiListDomainVerificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomainVerifications(requestParameters: WorkspacesSSODomainVerificationApiListDomainVerificationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceSSODomainVerificationResponse>> {
            return localVarFp.listDomainVerifications(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify a domain by checking DNS TXT records. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
         * @summary Verify Domain
         * @param {WorkspacesSSODomainVerificationApiVerifyDomainRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyDomain(requestParameters: WorkspacesSSODomainVerificationApiVerifyDomainRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSSODomainVerificationResponse> {
            return localVarFp.verifyDomain(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspacesSSODomainVerificationApi - interface
 * @export
 * @interface WorkspacesSSODomainVerificationApi
 */
export interface WorkspacesSSODomainVerificationApiInterface {
    /**
     * Create a new domain verification record. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
     * @summary Create Domain Verification
     * @param {WorkspacesSSODomainVerificationApiCreateDomainVerificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSODomainVerificationApiInterface
     */
    createDomainVerification(requestParameters: WorkspacesSSODomainVerificationApiCreateDomainVerificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSSODomainVerificationResponse>;

    /**
     * Delete a domain verification record. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
     * @summary Delete Domain Verification
     * @param {WorkspacesSSODomainVerificationApiDeleteDomainVerificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSODomainVerificationApiInterface
     */
    deleteDomainVerification(requestParameters: WorkspacesSSODomainVerificationApiDeleteDomainVerificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Completed>;

    /**
     * List all domain verifications for a workspace. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
     * @summary List Domain Verifications
     * @param {WorkspacesSSODomainVerificationApiListDomainVerificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSODomainVerificationApiInterface
     */
    listDomainVerifications(requestParameters: WorkspacesSSODomainVerificationApiListDomainVerificationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceSSODomainVerificationResponse>>;

    /**
     * Verify a domain by checking DNS TXT records. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
     * @summary Verify Domain
     * @param {WorkspacesSSODomainVerificationApiVerifyDomainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSODomainVerificationApiInterface
     */
    verifyDomain(requestParameters: WorkspacesSSODomainVerificationApiVerifyDomainRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSSODomainVerificationResponse>;

}

/**
 * Request parameters for createDomainVerification operation in WorkspacesSSODomainVerificationApi.
 * @export
 * @interface WorkspacesSSODomainVerificationApiCreateDomainVerificationRequest
 */
export interface WorkspacesSSODomainVerificationApiCreateDomainVerificationRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesSSODomainVerificationApiCreateDomainVerification
     */
    readonly workspaceId: string

    /**
     * 
     * @type {WorkspaceSSODomainVerificationCreateRequest}
     * @memberof WorkspacesSSODomainVerificationApiCreateDomainVerification
     */
    readonly workspaceSSODomainVerificationCreateRequest: WorkspaceSSODomainVerificationCreateRequest
}

/**
 * Request parameters for deleteDomainVerification operation in WorkspacesSSODomainVerificationApi.
 * @export
 * @interface WorkspacesSSODomainVerificationApiDeleteDomainVerificationRequest
 */
export interface WorkspacesSSODomainVerificationApiDeleteDomainVerificationRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesSSODomainVerificationApiDeleteDomainVerification
     */
    readonly workspaceId: string
}

/**
 * Request parameters for listDomainVerifications operation in WorkspacesSSODomainVerificationApi.
 * @export
 * @interface WorkspacesSSODomainVerificationApiListDomainVerificationsRequest
 */
export interface WorkspacesSSODomainVerificationApiListDomainVerificationsRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesSSODomainVerificationApiListDomainVerifications
     */
    readonly workspaceId: string
}

/**
 * Request parameters for verifyDomain operation in WorkspacesSSODomainVerificationApi.
 * @export
 * @interface WorkspacesSSODomainVerificationApiVerifyDomainRequest
 */
export interface WorkspacesSSODomainVerificationApiVerifyDomainRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkspacesSSODomainVerificationApiVerifyDomain
     */
    readonly workspaceId: string
}

/**
 * WorkspacesSSODomainVerificationApi - object-oriented interface
 * @export
 * @class WorkspacesSSODomainVerificationApi
 * @extends {BaseAPI}
 */
export class WorkspacesSSODomainVerificationApi extends BaseAPI implements WorkspacesSSODomainVerificationApiInterface {
    /**
     * Create a new domain verification record. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
     * @summary Create Domain Verification
     * @param {WorkspacesSSODomainVerificationApiCreateDomainVerificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSODomainVerificationApi
     */
    public createDomainVerification(requestParameters: WorkspacesSSODomainVerificationApiCreateDomainVerificationRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesSSODomainVerificationApiFp(this.configuration).createDomainVerification(requestParameters.workspaceId, requestParameters.workspaceSSODomainVerificationCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a domain verification record. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
     * @summary Delete Domain Verification
     * @param {WorkspacesSSODomainVerificationApiDeleteDomainVerificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSODomainVerificationApi
     */
    public deleteDomainVerification(requestParameters: WorkspacesSSODomainVerificationApiDeleteDomainVerificationRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesSSODomainVerificationApiFp(this.configuration).deleteDomainVerification(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all domain verifications for a workspace. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
     * @summary List Domain Verifications
     * @param {WorkspacesSSODomainVerificationApiListDomainVerificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSODomainVerificationApi
     */
    public listDomainVerifications(requestParameters: WorkspacesSSODomainVerificationApiListDomainVerificationsRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesSSODomainVerificationApiFp(this.configuration).listDomainVerifications(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify a domain by checking DNS TXT records. Admin endpoint - requires workspace admin permissions. Enterprise feature - requires enterprise subscription.
     * @summary Verify Domain
     * @param {WorkspacesSSODomainVerificationApiVerifyDomainRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesSSODomainVerificationApi
     */
    public verifyDomain(requestParameters: WorkspacesSSODomainVerificationApiVerifyDomainRequest, options?: RawAxiosRequestConfig) {
        return WorkspacesSSODomainVerificationApiFp(this.configuration).verifyDomain(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



